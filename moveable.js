!function (t, n) { "object" == typeof exports && "undefined" != typeof module ? module.exports = n() : "function" == typeof define && define.amd ? define(n) : (t = t || self).Moveable = n() }(this, function () { "use strict"; var r = function (t, n) { return (r = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, n) { t.__proto__ = n } || function (t, n) { for (var e in n) n.hasOwnProperty(e) && (t[e] = n[e]) })(t, n) }; function i(t, n) { function e() { this.constructor = t } r(t, n), t.prototype = null === n ? Object.create(n) : (e.prototype = n.prototype, new e) } var u = function () { return (u = Object.assign || function (t) { for (var n, e = 1, r = arguments.length; e < r; e++)for (var i in n = arguments[e]) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]); return t }).apply(this, arguments) }; function y(n, e) { return function (t) { t && (n[e] = t) } } function a(n, e, r) { return function (t) { t && (n[e][r] = t) } } function e(e, r) { return function (t) { var n = t.prototype; e.forEach(function (t) { r(n, t) }) } } var b = function () { function t() { this.keys = [], this.values = [] } var n = t.prototype; return n.get = function (t) { return this.values[this.keys.indexOf(t)] }, n.set = function (t, n) { var e = this.keys, r = this.values, i = e.indexOf(t), o = -1 === i ? e.length : i; e[o] = t, r[o] = n }, t }(), x = function () { function t() { this.object = {} } var n = t.prototype; return n.get = function (t) { return this.object[t] }, n.set = function (t, n) { this.object[t] = n }, t }(), E = "function" == typeof Map, o = function () { function t() { } var n = t.prototype; return n.connect = function (t, n) { this.prev = t, this.next = n, t && (t.next = this), n && (n.prev = this) }, n.disconnect = function () { var t = this.prev, n = this.next; t && (t.next = n), n && (n.prev = t) }, n.getIndex = function () { for (var t = this, n = -1; t;)t = t.prev, ++n; return n }, t }(); var S = function () { function t(t, n, e, r, i, o, a, s) { this.prevList = t, this.list = n, this.added = e, this.removed = r, this.changed = i, this.maintained = o, this.changedBeforeAdded = a, this.fixed = s } var n = t.prototype; return Object.defineProperty(n, "ordered", { get: function () { return this.cacheOrdered || this.caculateOrdered(), this.cacheOrdered }, enumerable: !0, configurable: !0 }), Object.defineProperty(n, "pureChanged", { get: function () { return this.cachePureChanged || this.caculateOrdered(), this.cachePureChanged }, enumerable: !0, configurable: !0 }), n.caculateOrdered = function () { var t, e, s, u, n = (t = this.changedBeforeAdded, e = this.fixed, s = [], u = [], t.forEach(function (t) { var n = t[0], e = t[1], r = new o; s[n] = r, u[e] = r }), s.forEach(function (t, n) { t.connect(s[n - 1]) }), t.filter(function (t, n) { return !e[n] }).map(function (t, n) { var e = t[0], r = t[1]; if (e === r) return [0, 0]; var i = s[e], o = u[r - 1], a = i.getIndex(); return i.disconnect(), o ? i.connect(o, o.next) : i.connect(void 0, s[0]), [a, i.getIndex()] })), c = this.changed, l = []; this.cacheOrdered = n.filter(function (t, n) { var e = t[0], r = t[1], i = c[n], o = i[0], a = i[1]; if (e !== r) return l.push([o, a]), !0 }), this.cachePureChanged = l }, t }(); function p(t, n, e) { var r = E ? Map : e ? x : b, i = e || function (t) { return t }, o = [], a = [], s = [], u = t.map(i), c = n.map(i), l = new r, f = new r, p = [], d = [], h = {}, v = [], g = 0, m = 0; return u.forEach(function (t, n) { l.set(t, n) }), c.forEach(function (t, n) { f.set(t, n) }), u.forEach(function (t, n) { var e = f.get(t); void 0 === e ? (++m, a.push(n)) : h[e] = m }), c.forEach(function (t, n) { var e = l.get(t); void 0 === e ? (o.push(n), ++g) : (s.push([e, n]), m = h[n] || 0, p.push([e - m, n - g]), d.push(n === e), e !== n && v.push([e, n])) }), a.reverse(), new S(t, n, o, a, v, s, p, d) } var t = function () { function t(t, n) { void 0 === t && (t = []), this.findKeyCallback = n, this.list = [].slice.call(t) } return t.prototype.update = function (t) { var n = [].slice.call(t), e = p(this.list, n, this.findKeyCallback); return this.list = n, e }, t }(), n = "string", s = "number", c = "undefined"; function l(t) { return typeof t === n } function h(t, r) { return void 0 === r && (r = "-"), t.replace(/([a-z])([A-Z])/g, function (t, n, e) { return "" + n + r + e.toLowerCase() }) } var f = function (t, n) { return (f = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, n) { t.__proto__ = n } || function (t, n) { for (var e in n) n.hasOwnProperty(e) && (t[e] = n[e]) })(t, n) }; function d(t, n) { function e() { this.constructor = t } f(t, n), t.prototype = null === n ? Object.create(n) : (e.prototype = n.prototype, new e) } var v = function () { return (v = Object.assign || function (t) { for (var n, e = 1, r = arguments.length; e < r; e++)for (var i in n = arguments[e]) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]); return t }).apply(this, arguments) }; function g(t, n) { var e = {}; for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && n.indexOf(r) < 0 && (e[r] = t[r]); if (null != t && "function" == typeof Object.getOwnPropertySymbols) for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)n.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (e[r[i]] = t[r[i]]); return e } function m(t, n) { if (t === n) return !1; for (var e in t) if (!(e in n)) return !0; for (var e in n) if (t[e] !== n[e]) return !0; return !1 } function M(i, o) { var a = Object.keys(i), e = Object.keys(o), t = p(a, e, function (t) { return t }), r = {}, s = {}, u = {}; return t.added.forEach(function (t) { var n = e[t]; r[n] = o[n] }), t.removed.forEach(function (t) { var n = a[t]; s[n] = i[n] }), t.maintained.forEach(function (t) { var n = t[0], e = a[n], r = [i[e], o[e]]; i[e] !== o[e] && (u[e] = r) }), { added: r, removed: s, changed: u } } function w(t) { t.forEach(function (t) { t() }) } function D(t) { var n = 0; return t.map(function (t) { return null == t ? "$compat" + ++n : "" + t }) } function C(t, n, e, r) { return l(t) || typeof t === s ? new G("text_" + t, n, e, r, null, {}) : new ("string" == typeof t.type ? T : t.type.prototype.render ? N : F)(t.type, n, e, r, t.ref, t.props) } function R(t) { var e = []; return t.forEach(function (t) { var n; e = e.concat((n = t, Array.isArray(n) ? R(t) : t)) }), e } function O(t) { var n = t.className, e = g(t, ["className"]); return null != n && (e.class = n), delete e.style, delete e.children, e } function P(t, n) { if (!n) return t; for (var e in n) typeof t[e] === c && (t[e] = n[e]); return t } function _(t, n) { for (var e = [], r = 2; r < arguments.length; r++)e[r - 2] = arguments[r]; var i = n || {}, o = i.key, a = i.ref, s = g(i, ["key", "ref"]); return { type: t, key: o, ref: a, props: v(v({}, s), { children: R(e).filter(function (t) { return null != t && !1 !== t }) }) } } var B = function () { function t(t, n, e, r, i, o) { void 0 === o && (o = {}), this.type = t, this.key = n, this.index = e, this.container = r, this.ref = i, this.props = o, this._providers = [] } var n = t.prototype; return n._should = function (t, n) { return !0 }, n._update = function (t, n, e, r) { if (this.base && !l(n) && !r && !this._should(n.props, e)) return !1; this.original = n, this._setState(e); var i = this.props; return l(n) || (this.props = n.props, this.ref = n.ref), this._render(t, this.base ? i : {}, e), !0 }, n._mounted = function () { var t = this.ref; t && t(this.base) }, n._setState = function (t) { }, n._updated = function () { var t = this.ref; t && t(this.base) }, n._destroy = function () { var t = this.ref; t && t(null) }, t }(); function z(t) { var n = {}, e = {}; for (var r in t) 0 === r.indexOf("on") ? e[r.replace("on", "").toLowerCase()] = t[r] : n[r] = t[r]; return { attributes: n, events: e } } var G = function (t) { function n() { return null !== t && t.apply(this, arguments) || this } d(n, t); var e = n.prototype; return e._render = function (t) { var n = this, e = !this.base; return e && (this.base = document.createTextNode(this.type.replace("text_", ""))), t.push(function () { e ? n._mounted() : n._updated() }), !0 }, e._unmount = function () { this.base.parentNode.removeChild(this.base) }, n }(B), T = function (n) { function t() { var t = null !== n && n.apply(this, arguments) || this; return t.events = {}, t._isSVG = !1, t } d(t, n); var e = t.prototype; return e.addEventListener = function (t, n) { var e = this.events; e[t] = function (t) { t.nativeEvent = t, n(t) }, this.base.addEventListener(t, e[t]) }, e.removeEventListener = function (t) { var n = this.events; this.base.removeEventListener(t, n[t]), delete n[t] }, e._should = function (t) { return m(this.props, t) }, e._render = function (t, n) { var e, r, i, o = this, a = !this.base; a && (e = this._hasSVG(), this._isSVG = e, (i = this.props.portalContainer) || (r = this.type, i = e ? document.createElementNS("http://www.w3.org/2000/svg", r) : document.createElement(r)), this.base = i), q(this, this._providers, this.props.children, t, null); var s = this.base, u = z(n), c = u.attributes, l = u.events, f = z(this.props), p = f.attributes, d = f.events; return function (t, n, e) { var r = M(t, n), i = r.added, o = r.removed, a = r.changed; for (var s in i) e.setAttribute(s, i[s]); for (var s in a) e.setAttribute(s, a[s][1]); for (var s in o) e.removeAttribute(s) }(O(c), O(p), s), function (t, n, e) { var r = M(t, n), i = r.added, o = r.removed, a = r.changed; for (var s in o) e.removeEventListener(s); for (var s in i) e.addEventListener(s, i[s]); for (var s in a) e.removeEventListener(s), e.addEventListener(s, a[s][1]); for (var s in o) e.removeEventListener(s) }(l, d, this), function (t, n, e) { var r = e.style, i = M(t, n), o = i.added, a = i.removed, s = i.changed; for (var u in o) { var c = h(u, "-"); r.setProperty ? r.setProperty(c, o[u]) : r[c] = o[u] } for (var u in s) { c = h(u, "-"); r.setProperty ? r.setProperty(c, s[u][1]) : r[c] = s[u][1] } for (var u in a) { c = h(u, "-"); r.removeProperty ? r.removeProperty(c) : r[c] = "" } }(n.style || {}, this.props.style || {}, s), t.push(function () { a ? o._mounted() : o._updated() }), !0 }, e._unmount = function () { var t = this.events, n = this.base; for (var e in t) n.removeEventListener(e, t[e]); this._providers.forEach(function (t) { t._unmount() }), this.events = {}, this.props.portalContainer || n.parentNode.removeChild(n) }, e._hasSVG = function () { if (this._isSVG || "svg" === this.type) return !0; var t = k(this.container); return t && "ownerSVGElement" in t }, t }(B); function k(t) { if (!t) return null; var n = t.base; return n instanceof Node ? n : k(t.container) } function A(t) { if (!t) return null; if (t instanceof Node) return t; var n = t.$_provider._providers; return n.length ? A(n[0].base) : null } var F = function (t) { function n() { return null !== t && t.apply(this, arguments) || this } d(n, t); var e = n.prototype; return e._render = function (t) { var n = this.type(this.props); return q(this, this._providers, n ? [n] : [], t), !0 }, e._unmount = function () { this._providers.forEach(function (t) { t._unmount() }) }, n }(B), I = function (e) { function t(t) { var n = e.call(this, "container", "container", 0, null) || this; return n.base = t, n } d(t, e); var n = t.prototype; return n._render = function () { return !0 }, n._unmount = function () { }, t }(B), N = function (a) { function t(t, n, e, r, i, o) { return void 0 === o && (o = {}), a.call(this, t, n, e, r, i, P(o, t.defaultProps)) || this } d(t, a); var n = t.prototype; return n._should = function (t, n) { return this.base.shouldComponentUpdate(P(t, this.type.defaultProps), n || this.base.state) }, n._render = function (t, n, e) { var r = this; this.props = P(this.props, this.type.defaultProps); var i = !this.base; i ? (this.base = new this.type(this.props), this.base.$_provider = this) : this.base.props = this.props; var o = this.base, a = o.state, s = o.render(); s && s.props && !s.props.children.length && (s.props.children = this.props.children), q(this, this._providers, s ? [s] : [], t, e, null), t.push(function () { i ? (r._mounted(), o.componentDidMount()) : (r._updated(), o.componentDidUpdate(n, a)) }) }, n._setState = function (t) { t && (this.base.state = t) }, n._unmount = function () { this._providers.forEach(function (t) { t._unmount() }), clearTimeout(this.base.$_timer), this.base.componentWillUnmount() }, t }(B), j = function () { function t(t) { void 0 === t && (t = {}), this.props = t, this.state = {}, this.$_timer = 0, this.$_state = {} } var n = t.prototype; return n.shouldComponentUpdate = function (t, n) { return !0 }, n.render = function () { return null }, n.setState = function (t, n, e) { var r = this; this.$_timer || (this.$_state = {}), clearTimeout(this.$_timer), this.$_timer = 0, this.$_state = v(v({}, this.$_state), t), e ? this.$_setState(n, e) : this.$_timer = setTimeout(function () { r.$_timer = 0, r.$_setState(n, e) }) }, n.forceUpdate = function (t) { this.setState({}, t, !0) }, n.componentDidMount = function () { }, n.componentDidUpdate = function (t, n) { }, n.componentWillUnmount = function () { }, n.$_setState = function (t, n) { var e = [], r = this.$_provider; q(r.container, [r], [r.original], e, v(v({}, this.state), this.$_state), n) && (t && e.push(t), w(e)) }, t }(), Y = function (t) { function n() { return null !== t && t.apply(this, arguments) || this } return d(n, t), n.prototype.shouldComponentUpdate = function (t, n) { return m(this.props, t) || m(this.state, n) }, n }(j), X = function (t) { function n() { return null !== t && t.apply(this, arguments) || this } d(n, t); var e = n.prototype; return e.componentDidMount = function () { var t = this.props, n = t.element, e = t.container; this._portalProvider = new I(e), L(n, e, this._portalProvider) }, e.componentDidUpdate = function () { var t = this.props; L(t.element, t.container, this._portalProvider) }, e.componentWillUnmount = function () { L(null, this.props.container, this._portalProvider), this._portalProvider = null }, n }(Y); function W(i, a, o) { var s = o.map(function (t) { return l(t) ? null : t.key }), t = p(D(a.map(function (t) { return t.key })), D(s), function (t) { return t }); t.removed.forEach(function (t) { a.splice(t, 1)[0]._unmount() }), t.ordered.forEach(function (t) { var n = t[0], e = t[1], r = a.splice(n, 1)[0]; a.splice(e, 0, r); var i = A(r.base), o = A(a[e + 1] && a[e + 1].base); i && i.parentNode.insertBefore(i, o) }), t.added.forEach(function (t) { a.splice(t, 0, C(o[t], s[t], t, i)) }); var n = t.maintained.filter(function (t) { t[0]; var n = t[1], e = o[n], r = a[n]; return (l(e) ? "text_" + e : e.type) !== r.type ? (r._unmount(), a.splice(n, 1, C(e, s[n], n, i)), !0) : (r.index = n, !1) }); return function () { for (var t = 0, n = 0, e = arguments.length; n < e; n++)t += arguments[n].length; for (var r = Array(t), i = 0, n = 0; n < e; n++)for (var o = arguments[n], a = 0, s = o.length; a < s; a++, i++)r[i] = o[a]; return r }(t.added, n.map(function (t) { t[0]; return t[1] })) } function q(i, o, e, r, a, s) { var t = W(i, o, e), n = o.filter(function (t, n) { return t._update(r, e[n], a, s) }), u = k(i); return u && t.reverse().forEach(function (t) { var n, e = o[t], r = A(e.base); r && (u === r || r.parentNode || (n = function (t, n) { for (var e = t._providers, r = e.length, i = n.index + 1; i < r; ++i) { var o = A(e[i].base); if (o) return o } return null }(i, e), u.insertBefore(r, n))) }), 0 < n.length } function L(t, n, e) { void 0 === e && (e = n.__REACT_COMPAT__); var r, i, o, a, s = !!e; return e = e || new I(n), i = t ? [t] : [], a = [], q(r = e, r._providers, i, a, o), w(a), s || (n.__REACT_COMPAT__ = e), e } function H(t, n, e) { var r = n.__REACT_COMPAT__; t && !r && (n.innerHTML = ""), L(t, n, r), e && e() } function V(t, n) { for (var e = t.length, r = 0; r < e; ++r)if (n(t[r], r)) return !0; return !1 } function U(t, n) { for (var e = t.length, r = 0; r < e; ++r)if (n(t[r], r)) return t[r]; return null } function $(t, n) { try { return new RegExp(t, "g").exec(n) } catch (t) { return null } } function Z(t) { return t.replace(/_/g, ".") } function K(t, i) { var o = null, a = "-1"; return V(t, function (t) { var n, e, r = $("(" + t.test + ")((?:\\/|\\s|:)([0-9|\\.|_]+))?", i); return r && !t.brand && (o = t, a = r[3] || "-1", t.versionAlias ? a = t.versionAlias : t.versionTest && (n = t.versionTest.toLowerCase(), e = $("(" + n + ")((?:\\/|\\s|:)([0-9|\\.|_]+))", i), a = (e ? e[3] : "") || a), a = Z(a), 1) }), { preset: o, version: a } } function J(t, e) { var r = { brand: "", version: "-1" }; return V(t, function (t) { var n = Q(e, t); return n && (r.brand = t.id, r.version = t.versionAlias || n.version, "-1" !== r.version) }), r } function Q(t, e) { return U(t, function (t) { var n = t.brand; return $("" + e.test, n.toLowerCase()) }) } var tt = [{ test: "phantomjs", id: "phantomjs" }, { test: "whale", id: "whale" }, { test: "edgios|edge|edg", id: "edge" }, { test: "msie|trident|windows phone", id: "ie", versionTest: "iemobile|msie|rv" }, { test: "miuibrowser", id: "miui browser" }, { test: "samsungbrowser", id: "samsung internet" }, { test: "samsung", id: "samsung internet", versionTest: "version" }, { test: "chrome|crios", id: "chrome" }, { test: "firefox|fxios", id: "firefox" }, { test: "android", id: "android browser", versionTest: "version" }, { test: "safari|iphone|ipad|ipod", id: "safari", versionTest: "version" }], nt = [{ test: "(?=.*applewebkit/(53[0-7]|5[0-2]|[0-4]))(?=.*\\schrome)", id: "chrome", versionTest: "chrome" }, { test: "chromium", id: "chrome" }, { test: "whale", id: "chrome", versionAlias: "-1", brand: !0 }], et = [{ test: "applewebkit", id: "webkit", versionTest: "applewebkit|safari" }], rt = [{ test: "(?=(iphone|ipad))(?!(.*version))", id: "webview" }, { test: "(?=(android|iphone|ipad))(?=.*(naver|daum|; wv))", id: "webview" }, { test: "webview", id: "webview" }], it = [{ test: "windows phone", id: "windows phone" }, { test: "windows 2000", id: "window", versionAlias: "5.0" }, { test: "windows nt", id: "window" }, { test: "win32|windows", id: "window" }, { test: "iphone|ipad|ipod", id: "ios", versionTest: "iphone os|cpu os" }, { test: "macos|macintel|mac os x", id: "mac" }, { test: "android|linux armv81", id: "android" }, { test: "tizen", id: "tizen" }, { test: "webos|web0s", id: "webos" }]; function ot(t) { var n, e = function (t) { var n = t; if (void 0 === n) { if ("undefined" == typeof navigator || !navigator) return ""; n = navigator.userAgent || "" } return n.toLowerCase() }(t), r = !!/mobi/g.exec(e), i = { name: "unknown", version: "-1", majorVersion: -1, webview: !!K(rt, e).preset, chromium: !1, chromiumVersion: "-1", webkit: !1, webkitVersion: "-1" }, o = { name: "unknown", version: "-1", majorVersion: -1 }, a = K(tt, e), s = a.preset, u = a.version, c = K(it, e), l = c.preset, f = c.version, p = K(nt, e); return i.chromium = !!p.preset, i.chromiumVersion = p.version, i.chromium || (n = K(et, e), i.webkit = !!n.preset, i.webkitVersion = n.version), l && (o.name = l.id, o.version = f, o.majorVersion = parseInt(f, 10)), s && (i.name = s.id, i.version = u, i.webview && "ios" === o.name && "safari" !== i.name && (i.webview = !1)), i.majorVersion = parseInt(i.version, 10), { browser: i, os: o, isMobile: r, isHints: !1 } } var at = "function", st = "object", ut = "string", ct = "undefined", lt = typeof window !== ct, ft = [{ open: "(", close: ")" }, { open: '"', close: '"' }, { open: "'", close: "'" }, { open: '\\"', close: '\\"' }, { open: "\\'", close: "\\'" }], pt = 1e-7, dt = { cm: function (t) { return 96 * t / 2.54 }, mm: function (t) { return 96 * t / 254 }, in: function (t) { return 96 * t }, pt: function (t) { return 96 * t / 72 }, pc: function (t) { return 96 * t / 6 }, "%": function (t, n) { return t * n / 100 }, vw: function (t, n) { return void 0 === n && (n = window.innerWidth), t / 100 * n }, vh: function (t, n) { return void 0 === n && (n = window.innerHeight), t / 100 * n }, vmax: function (t, n) { return void 0 === n && (n = Math.max(window.innerWidth, window.innerHeight)), t / 100 * n }, vmin: function (t, n) { return void 0 === n && (n = Math.min(window.innerWidth, window.innerHeight)), t / 100 * n } }; function ht(t) { return typeof t === ct } function vt(t) { return t && typeof t === st } function gt(t) { return Array.isArray(t) } function mt(t) { return typeof t === ut } function bt(t) { return typeof t === at } function xt(t, n, e, r, i) { return Et(t, n, e) ? e : function (i, o, t, a, s) { for (var u, n = t; n < a; ++n) { var e = function (t) { var n = o[t].trim(); if (n === i.close && !Et(i, o, t)) return { value: t }; var e = t, r = Ot(s, function (t) { return t.open === n }); if (r && (e = xt(r, o, t, a, s)), -1 === e) return u = t, "break"; u = t = e }(n); if (n = u, "object" == typeof e) return e.value; if ("break" === e) break } return -1 }(t, n, e + 1, r, i) } function Et(t, n, e) { if (!t.ignore) return null; var r = n.slice(Math.max(e - 3, 0), e + 3).join(""); return new RegExp(t.ignore).exec(r) } function yt(t, n) { var e = mt(n) ? { separator: n } : n, r = e.separator, s = void 0 === r ? "," : r, u = e.isSeparateFirst, c = e.isSeparateOnlyOpenClose, i = e.isSeparateOpenClose, l = void 0 === i ? c : i, o = e.openCloseCharacters, f = void 0 === o ? ft : o, a = f.map(function (t) { var n = t.open, e = t.close; return n === e ? n : n + "|" + e }).join("|"), p = new RegExp("(\\s*" + s + "\\s*|" + a + "|\\s+)", "g"), d = t.split(p).filter(Boolean), h = d.length, v = [], g = []; function m() { return g.length && (v.push(g.join("")), g = []) } for (var b, x = 0; x < h; ++x) { var E = function (t) { var n, e, r = d[t].trim(), i = t, o = Ot(f, function (t) { return t.open === r }), a = Ot(f, function (t) { return t.close === r }); if (o) { if (-1 !== (i = xt(o, d, t, h, f)) && l) return m() && u ? (b = t, "break") : (v.push(d.slice(t, i + 1).join("")), t = i, u ? (b = t, "break") : (b = t, "continue")) } else { if (a && !Et(a, d, t)) throw new Error("invalid format: " + a.close); if (n = r, !(("" !== (e = s) && " " != e || "" !== n && " " != n) && n !== e || c)) return m(), u ? (b = t, "break") : (b = t, "continue") } -1 === i && (i = h - 1), g.push(d.slice(t, i + 1).join("")), b = t = i }(x), x = b; if ("break" === E) break } return g.length && v.push(g.join("")), v } function St(t) { return yt(t, "") } function Mt(t) { return yt(t, ",") } function wt(t) { var n = /([^(]*)\(([\s\S]*)\)([\s\S]*)/g.exec(t); return !n || n.length < 4 ? {} : { prefix: n[1], value: n[2], suffix: n[3] } } function Dt(t) { var n = /^([^\d|e|\-|\+]*)((?:\d|\.|-|e-|e\+)+)(\S*)$/g.exec(t); if (!n) return { prefix: "", unit: "", value: NaN }; var e = n[1], r = n[2]; return { prefix: e, unit: n[3], value: parseFloat(r) } } function Ct() { return Date.now ? Date.now() : (new Date).getTime() } function Rt(t, n, e) { void 0 === e && (e = -1); for (var r = t.length, i = 0; i < r; ++i)if (n(t[i], i, t)) return i; return e } function Ot(t, n, e) { var r = Rt(t, n); return -1 < r ? t[r] : e } var Pt = function () { var e = Ct(), t = lt && (window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame); return t ? t.bind(window) : function (t) { var n = Ct(); return window.setTimeout(function () { t(n - e) }, 1e3 / 60) } }(), _t = function () { var t = lt && (window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.msCancelAnimationFrame); return t ? t.bind(window) : function (t) { clearTimeout(t) } }(); function Bt(t) { if (Object.keys) return Object.keys(t); var n = []; for (var e in n) n.push(e); return n } function zt(t, n) { var e = Dt(t), r = e.value, i = e.unit; if (vt(n)) { var o = n[i]; if (o) { if (bt(o)) return o(r); if (dt[i]) return dt[i](r, o) } } else if ("%" === i) return r * n / 100; return dt[i] ? dt[i](r) : r } function Gt(t, e, r) { return [[Nt(e[0], pt), Nt(e[0] * t[1] / t[0], pt)], [Nt(e[1] * t[0] / t[1], pt), Nt(e[1], pt)]].filter(function (t) { return t.every(function (t, n) { return r ? t <= e[n] : t >= e[n] }) })[0] || t } function Tt(t, o, a, n) { if (!n) return t.map(function (t, n) { return e = t, r = o[n], i = a[n], Math.max(r, Math.min(e, i)); var e, r, i }); var e = t[0], r = t[1], i = Gt(t, o, !1), s = i[0], u = i[1], c = Gt(t, a, !0), l = c[0], f = c[1]; return e < s || r < u ? (e = s, r = u) : (l < e || f < r) && (e = l, r = f), [e, r] } function kt(t) { for (var n = t.length, e = 0, r = n - 1; 0 <= r; --r)e += t[r]; return n ? e / n : 0 } function At(t, n) { var e = n[0] - t[0], r = n[1] - t[1], i = Math.atan2(r, e); return 0 <= i ? i : i + 2 * Math.PI } function Ft(t) { var e, n = (e = t, [0, 1].map(function (n) { return kt(e.map(function (t) { return t[n] })) })), r = At(n, t[0]), i = At(n, t[1]); return r < i && i - r < Math.PI || i < r && i - r < -Math.PI ? 1 : -1 } function It(t, n) { return Math.sqrt(Math.pow((n ? n[0] : 0) - t[0], 2) + Math.pow((n ? n[1] : 0) - t[1], 2)) } function Nt(t, n) { return n ? Math.round(t / n) * n : t } function jt(e, r) { return e.forEach(function (t, n) { e[n] = Nt(e[n], r) }), e } function Yt(t, n) { return t.classList ? t.classList.contains(n) : !!t.className.match(new RegExp("(\\s|^)" + n + "(\\s|$)")) } function Xt(t, n, e, r) { t.removeEventListener(n, e, r) } var Wt = 1e-7; function qt(t, n) { return n ? Math.round(t / n) * n : t } function Lt(t, n, e) { void 0 === e && (e = Math.sqrt(t.length)); for (var r = t.slice(), i = 0; i < e; ++i)r[i * e + n - 1] = 0, r[(n - 1) * e + i] = 0; return r[(n - 1) * (e + 1)] = 1, r } function Ht(t, n) { void 0 === n && (n = Math.sqrt(t.length)); for (var e = t.slice(), r = ln(n), i = 0; i < n; ++i) { var o = n * i + i; if (!qt(e[o], Wt)) for (var a = i + 1; a < n; ++a)if (e[n * i + a]) { !function (t, n, e, r, i) { for (var o = 0; o < i; ++o) { var a = e + o * i, s = r + o * i, u = t[a], c = n[a]; t[a] = t[s], t[s] = u, n[a] = n[s], n[s] = c } }(e, r, i, a, n); break } if (!qt(e[o], Wt)) return []; !function (t, n, e, r, i) { for (var o = 0; o < r; ++o) { var a = e + o * r; t[a] /= i, n[a] /= i } }(e, r, i, n, e[o]); for (a = 0; a < n; ++a) { var s = a, u = e[a + i * n]; qt(u, Wt) && i !== a && function (t, n, e, r, i, o) { for (var a = 0; a < i; ++a) { var s = e + a * i, u = r + a * i; t[s] += t[u] * o, n[s] += n[u] * o } }(e, r, s, i, n, -u) } } return r } function Vt(t, n) { for (var e = t.slice(), r = t.length; r < n - 1; ++r)e[r] = 0; return e[n - 1] = 1, e } function Ut(t, n, e) { if (void 0 === n && (n = Math.sqrt(t.length)), n === e) return t; for (var r = ln(e), i = Math.min(n, e), o = 0; o < i - 1; ++o) { for (var a = 0; a < i - 1; ++a)r[o * e + a] = t[o * n + a]; r[(o + 1) * e - 1] = t[(o + 1) * n - 1], r[(e - 1) * e + o] = t[(n - 1) * n + o] } return r[e * e - 1] = t[n * n - 1], r } function $t(n) { for (var t = [], e = 1; e < arguments.length; e++)t[e - 1] = arguments[e]; var r = ln(n); return t.forEach(function (t) { r = Zt(r, t, n) }), r } function Zt(t, n, e) { void 0 === e && (e = Math.sqrt(t.length)); var r = [], i = t.length / e, o = n.length / i; if (!i) return n; if (!o) return t; for (var a = 0; a < e; ++a)for (var s = 0; s < o; ++s)for (var u = r[s * e + a] = 0; u < i; ++u)r[s * e + a] += t[u * e + a] * n[s * i + u]; return r } function Kt(t, n) { for (var e = Math.min(t.length, n.length), r = t.slice(), i = 0; i < e; ++i)r[i] = r[i] + n[i]; return r } function Jt(t, n) { for (var e = Math.min(t.length, n.length), r = t.slice(), i = 0; i < e; ++i)r[i] = r[i] - n[i]; return r } function Qt(t, n) { return void 0 === n && (n = 9 === t.length), n ? [t[0], t[1], t[3], t[4], t[6], t[7]] : t } function tn(t, n, e) { void 0 === e && (e = n.length); var r = Zt(t, n, e), i = r[e - 1]; return r.map(function (t) { return t / i }) } function nn(t, n) { return Zt(t, [1, 0, 0, 0, 0, Math.cos(n), Math.sin(n), 0, 0, -Math.sin(n), Math.cos(n), 0, 0, 0, 0, 1], 4) } function en(t, n) { return Zt(t, [Math.cos(n), 0, -Math.sin(n), 0, 0, 1, 0, 0, Math.sin(n), 0, Math.cos(n), 0, 0, 0, 0, 1], 4) } function rn(t, n) { return Zt(t, cn(n, 4)) } function on(t, n) { var e = n[0], r = void 0 === e ? 1 : e, i = n[1], o = void 0 === i ? 1 : i, a = n[2]; return Zt(t, [r, 0, 0, 0, 0, o, 0, 0, 0, 0, void 0 === a ? 1 : a, 0, 0, 0, 0, 1], 4) } function an(t, n) { return tn(cn(n, 3), Vt(t, 3)) } function sn(t, n) { var e = n[0], r = void 0 === e ? 0 : e, i = n[1], o = void 0 === i ? 0 : i, a = n[2]; return Zt(t, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, r, o, void 0 === a ? 0 : a, 1], 4) } function un(t, n) { return Zt(t, n, 4) } function cn(t, n) { var e = Math.cos(t), r = Math.sin(t), i = ln(n); return i[0] = e, i[1] = r, i[n] = -r, i[n + 1] = e, i } function ln(t) { for (var n = t * t, e = [], r = 0; r < n; ++r)e[r] = r % (t + 1) ? 0 : 1; return e } function fn(t, n) { for (var e = ln(n), r = Math.min(t.length, n - 1), i = 0; i < r; ++i)e[(n + 1) * i] = t[i]; return e } function pn(t, n) { for (var e = ln(n), r = Math.min(t.length, n - 1), i = 0; i < r; ++i)e[n * (n - 1) + i] = t[i]; return e } function dn(t, n, e, r, i, o, a, s) { var u = t[0], c = t[1], l = n[0], f = n[1], p = e[0], d = e[1], h = r[0], v = r[1], g = i[0], m = i[1], b = o[0], x = o[1], E = a[0], y = a[1], S = s[0], M = s[1], w = Ht([u, 0, l, 0, p, 0, h, 0, c, 0, f, 0, d, 0, v, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, u, 0, l, 0, p, 0, h, 0, c, 0, f, 0, d, 0, v, 0, 1, 0, 1, 0, 1, 0, 1, -g * u, -m * u, -b * l, -x * l, -E * p, -y * p, -S * h, -M * h, -g * c, -m * c, -b * f, -x * f, -E * d, -y * d, -S * v, -M * v], 8); if (!w.length) return []; var D = Zt(w, [g, m, b, x, E, y, S, M], 8); return D[8] = 1, Ut(function (t, n) { void 0 === n && (n = Math.sqrt(t.length)); for (var e = [], r = 0; r < n; ++r)for (var i = 0; i < n; ++i)e[i * n + r] = t[n * r + i]; return e }(D), 3, 4) } var hn = "string", vn = [{ open: "(", close: ")" }, { open: '"', close: '"' }, { open: "'", close: "'" }, { open: '\\"', close: '\\"' }, { open: "\\'", close: "\\'" }]; function gn(t, n, e, r, i) { return mn(t, n, e) ? e : function (i, o, t, a, s) { for (var u, n = t; n < a; ++n) { var e = function (t) { var n = o[t].trim(); if (n === i.close && !mn(i, o, t)) return { value: t }; var e = t, r = En(s, function (t) { return t.open === n }); if (r && (e = gn(r, o, t, a, s)), -1 === e) return u = t, "break"; u = t = e }(n); if (n = u, "object" == typeof e) return e.value; if ("break" === e) break } return -1 }(t, n, e + 1, r, i) } function mn(t, n, e) { if (!t.ignore) return null; var r = n.slice(Math.max(e - 3, 0), e + 3).join(""); return new RegExp(t.ignore).exec(r) } function bn(t, n) { var e = typeof n === hn ? { separator: n } : n, r = e.separator, s = void 0 === r ? "," : r, u = e.isSeparateFirst, c = e.isSeparateOnlyOpenClose, i = e.isSeparateOpenClose, l = void 0 === i ? c : i, o = e.openCloseCharacters, f = void 0 === o ? vn : o, a = f.map(function (t) { var n = t.open, e = t.close; return n === e ? n : n + "|" + e }).join("|"), p = new RegExp("(\\s*" + s + "\\s*|" + a + "|\\s+)", "g"), d = t.split(p).filter(Boolean), h = d.length, v = [], g = []; function m() { return g.length && (v.push(g.join("")), g = []) } for (var b, x = 0; x < h; ++x) { var E = function (t) { var n, e, r = d[t].trim(), i = t, o = En(f, function (t) { return t.open === r }), a = En(f, function (t) { return t.close === r }); if (o) { if (-1 !== (i = gn(o, d, t, h, f)) && l) return m() && u ? (b = t, "break") : (v.push(d.slice(t, i + 1).join("")), t = i, u ? (b = t, "break") : (b = t, "continue")) } else { if (a && !mn(a, d, t)) throw new Error("invalid format: " + a.close); if (n = r, !(("" !== (e = s) && " " != e || "" !== n && " " != n) && n !== e || c)) return m(), u ? (b = t, "break") : (b = t, "continue") } -1 === i && (i = h - 1), g.push(d.slice(t, i + 1).join("")), b = t = i }(x), x = b; if ("break" === E) break } return g.length && v.push(g.join("")), v } function xn(t) { return bn(t, ",") } function En(t, n, e) { var r = function (t, n, e) { void 0 === e && (e = -1); for (var r = t.length, i = 0; i < r; ++i)if (n(t[i], i, t)) return i; return e }(t, n); return -1 < r ? t[r] : e } function yn(t) { var r = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]; return t.forEach(function (t) { var n = t.matrixFunction, e = t.functionValue; n && (r = n(r, e)) }), r } function Sn(t) { var n; return (n = t, Array.isArray(n) ? t : bn(t, "")).map(function (t) { var n, e, r, i, o, a, s, u, c, l, f, p, d = !(n = /([^(]*)\(([\s\S]*)\)([\s\S]*)/g.exec(t)) || n.length < 4 ? {} : { prefix: n[1], value: n[2], suffix: n[3] }, h = d.prefix, v = d.value, g = null, m = h, b = ""; return "translate" === h || "translateX" === h || "translate3d" === h ? (g = sn, b = [(e = xn(v).map(function (t) { return parseFloat(t) }))[0], void 0 === (r = e[1]) ? 0 : r, void 0 === (i = e[2]) ? 0 : i]) : "translateY" === h ? (g = sn, b = [0, parseFloat(v), 0]) : "translateZ" === h ? (g = sn, b = [0, 0, parseFloat(v)]) : "scale" === h || "scale3d" === h ? (g = on, b = [u = (o = xn(v).map(function (t) { return parseFloat(t) }))[0], void 0 === (a = o[1]) ? u : a, void 0 === (s = o[2]) ? 1 : s]) : "scaleX" === h ? (g = on, b = [u = parseFloat(v), 1, 1]) : "scaleY" === h ? (g = on, b = [1, parseFloat(v), 1]) : "scaleZ" === h ? (g = on, b = [1, 1, parseFloat(v)]) : "rotate" === h || "rotateZ" === h || "rotateX" === h || "rotateY" === h ? (l = (c = function (t) { var n = /^([^\d|e|\-|\+]*)((?:\d|\.|-|e-|e\+)+)(\S*)$/g.exec(t); if (!n) return { prefix: "", unit: "", value: NaN }; var e = n[1], r = n[2]; return { prefix: e, unit: n[3], value: parseFloat(r) } }(v)).unit, f = c.value, "rotate" === h || "rotateZ" === h ? (m = "rotateZ", g = rn) : "rotateX" === h ? g = nn : "rotateY" === h && (g = en), b = "rad" === l ? f : f * Math.PI / 180) : "matrix3d" === h ? (g = un, b = xn(v).map(function (t) { return parseFloat(t) })) : "matrix" === h ? (g = un, b = [(p = xn(v).map(function (t) { return parseFloat(t) }))[0], p[1], 0, 0, p[2], p[3], 0, 0, 0, 0, 1, 0, p[4], p[5], 0, 1]) : m = "", { name: h, functionName: m, value: v, matrixFunction: g, functionValue: b } }) } var Mn = function (t, n) { return (Mn = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, n) { t.__proto__ = n } || function (t, n) { for (var e in n) n.hasOwnProperty(e) && (t[e] = n[e]) })(t, n) }; var wn, Dn = "function" == typeof Map ? void 0 : (wn = 0, function (t) { return t.__DIFF_KEY__ || (t.__DIFF_KEY__ = ++wn) }), Cn = function (n) { function t() { this.constructor = e } var e, r; function i(t) { return void 0 === t && (t = []), n.call(this, t, Dn) || this } return Mn(e = i, r = n), e.prototype = null === r ? Object.create(r) : (t.prototype = r.prototype, new t), i }(t); function Rn(t, n, e) { void 0 === e && (e = -1); for (var r = t.length, i = 0; i < r; ++i)if (n(t[i], i, t)) return i; return e } function On(t, n) { var e = n[0] - t[0], r = n[1] - t[1], i = Math.atan2(r, e); return 0 <= i ? i : i + 2 * Math.PI } function Pn(t) { return [0, 1].map(function (n) { return function (t) { for (var n = t.length, e = 0, r = n - 1; 0 <= r; --r)e += t[r]; return n ? e / n : 0 }(t.map(function (t) { return t[n] })) }) } function _n(t) { var n = Pn(t), e = On(n, t[0]), r = On(n, t[1]); return e < r && r - e < Math.PI || r < e && r - e < -Math.PI ? 1 : -1 } function Bn(t, n) { return Math.sqrt(Math.pow((n ? n[0] : 0) - t[0], 2) + Math.pow((n ? n[1] : 0) - t[1], 2)) } function zn(r) { return r.length < 3 ? 0 : Math.abs(function (t) { for (var n = 0, e = t.length - 1; 0 <= e; --e)n += t[e]; return n }(r.map(function (t, n) { var e = r[n + 1] || r[0]; return t[0] * e[1] - e[0] * t[1] }))) / 2 } function Gn(t, n) { var e = n.width, r = n.height, i = n.left, o = n.top, a = Tn(t), s = a.minX, u = a.minY, c = a.maxX, l = a.maxY, f = e / (c - s), p = r / (l - u); return t.map(function (t) { return [i + (t[0] - s) * f, o + (t[1] - u) * p] }) } function Tn(t) { var n = t.map(function (t) { return t[0] }), e = t.map(function (t) { return t[1] }); return { minX: Math.min.apply(Math, n), minY: Math.min.apply(Math, e), maxX: Math.max.apply(Math, n), maxY: Math.max.apply(Math, e) } } function kn(t, n, e) { var i = t[0], o = t[1], r = Tn(n), a = r.minX, s = r.minY, u = r.maxX, c = r.maxY, l = [[a, o], [u, o]], f = [[i, s], [i, c]], p = An(l[0], l[1]), d = An(f[0], f[1]), h = Nn(n), v = [], g = []; return h.forEach(function (t) { var n = An(t[0], t[1]), e = In(Fn(p, n), [l, t]), r = In(Fn(d, n), [f, t]); 1 === e.length && t[0][1] === o || v.push.apply(v, e), 1 === r.length && t[0][0] === i || g.push.apply(g, r), n[0] || v.push.apply(v, e), n[1] || g.push.apply(g, r) }), !e && (-1 < Rn(v, function (t) { return t[0] === i }) || -1 < Rn(g, function (t) { return t[1] === o })) || !!(v.filter(function (t) { return t[0] > i }).length % 2 && g.filter(function (t) { return t[1] > o }).length % 2) } function An(t, n) { var e = t[0], r = t[1], i = n[0], o = n[1]; if (e === i && r === o) return [0, 0, 0]; if (e === i) return [1, 0, -e]; if (r === o) return [0, 1, -r]; var a = (i - e) / (r - o); return [1, a, -e - a * r] } function Fn(t, n) { var e, r, i = t[0], o = t[1], a = t[2], s = n[0], u = n[1], c = n[2], l = 0 === i && 0 === s, f = 0 === o && 0 === u; if (l && f) return []; if (l) { var p = -a / o; return p != -c / u ? [] : [[-1 / 0, p], [1 / 0, p]] } if (f) { var d = -a / i; return d != -c / s ? [] : [[d, -1 / 0], [d, 1 / 0]] } return 0 !== i ? 0 !== s ? 0 !== o ? 0 !== u ? [[e = (o * c - u * a) / (u * i - o * s), r = -(i * e + a) / o]] : [[e = -c / s, r = -(i * e + a) / o]] : [[e = -a / i, r = -(s * e + c) / u]] : [[e = -(o * (r = -c / u) + a) / i, r]] : [[e = -(u * (r = -a / o) + c) / s, r]] } function In(t, n) { var e = n.map(function (n) { return [0, 1].map(function (t) { return [Math.min(n[0][t], n[1][t]), Math.max(n[0][t], n[1][t])] }) }); if (2 === t.length) { var r = t[0], i = r[0], o = r[1]; if (i === t[1][0]) { var a = Math.max.apply(Math, e.map(function (t) { return t[1][0] })), s = Math.min.apply(Math, e.map(function (t) { return t[1][1] })); return s < a ? [] : [[i, a], [i, s]] } if (o === t[1][1]) { var u = Math.max.apply(Math, e.map(function (t) { return t[0][0] })), c = Math.min.apply(Math, e.map(function (t) { return t[0][1] })); return c < u ? [] : [[u, o], [c, o]] } } return t.filter(function (n) { return e.every(function (t) { return t[0][0] <= n[0] && n[0] <= t[0][1] && t[1][0] <= n[1] && n[1] <= t[1][1] }) }) } function Nn(e) { return function () { for (var t = 0, n = 0, e = arguments.length; n < e; n++)t += arguments[n].length; for (var r = Array(t), i = 0, n = 0; n < e; n++)for (var o = arguments[n], a = 0, s = o.length; a < s; a++, i++)r[i] = o[a]; return r }(e.slice(1), [e[0]]).map(function (t, n) { return [e[n], t] }) } function jn(t, n) { return zn(function (t, n) { var e = t.slice(), s = n.slice(); -1 === _n(e) && e.reverse(), -1 === _n(s) && s.reverse(); var u = Nn(e), c = Nn(s), r = u.map(function (t) { return An(t[0], t[1]) }), l = c.map(function (t) { return An(t[0], t[1]) }), f = []; r.forEach(function (r, i) { var o = u[i], a = []; l.forEach(function (t, n) { var e = In(Fn(r, t), [o, c[n]]); a.push.apply(a, e.map(function (t) { return { index1: i, index2: n, pos: t } })) }), a.sort(function (t, n) { return Bn(o[0], t.pos) - Bn(o[0], n.pos) }), f.push.apply(f, a), kn(o[1], s) && f.push({ index1: i, index2: -1, pos: o[1] }) }), c.forEach(function (t, r) { var i, n; kn(t[1], e) && (i = !1, -1 === (n = Rn(f, function (t) { return t.index2 !== r ? !!i : void (i = !0) })) && (i = !1, n = Rn(f, function (t) { var n = t.index1, e = t.index2; if (-1 !== n || e + 1 !== r) return !!i; i = !0 })), -1 === n ? f.push({ index1: -1, index2: r, pos: t[1] }) : f.splice(n, 0, { index1: -1, index2: r, pos: t[1] })) }); var i = f.map(function (t) { return t.pos }), o = {}; return i.filter(function (t) { var n = t[0] + "x" + t[1]; return !o[n] && (o[n] = !0) }) }(t, n)) } function Yn(t) { return t && "object" == typeof t } var Xn = function () { return (Xn = Object.assign || function (t) { for (var n, e = 1, r = arguments.length; e < r; e++)for (var i in n = arguments[e]) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]); return t }).apply(this, arguments) }; var Wn = function () { function t() { this._events = {} } var n = t.prototype; return n.on = function (t, n) { if (Yn(t)) for (var e in t) this.on(e, t[e]); else this._addEvent(t, n, {}); return this }, n.off = function (t, n) { if (t) if (Yn(t)) for (var e in t) this.off(e); else { var r, i; n ? !(r = this._events[t]) || -1 < (i = function (t, n, e) { void 0 === e && (e = -1); for (var r = t.length, i = 0; i < r; ++i)if (n(t[i], i, t)) return i; return e }(r, function (t) { return t.listener === n })) && r.splice(i, 1) : this._events[t] = [] } else this._events = {}; return this }, n.once = function (n, t) { var e = this; return t && this._addEvent(n, t, { once: !0 }), new Promise(function (t) { e._addEvent(n, t, { once: !0 }) }) }, n.emit = function (n, e) { var r = this; void 0 === e && (e = {}); var t = this._events[n]; if (!n || !t) return !0; var i = !1; return e.eventType = n, e.stop = function () { i = !0 }, e.currentTarget = this, function () { for (var t = 0, n = 0, e = arguments.length; n < e; n++)t += arguments[n].length; for (var r = Array(t), i = 0, n = 0; n < e; n++)for (var o = arguments[n], a = 0, s = o.length; a < s; a++, i++)r[i] = o[a]; return r }(t).forEach(function (t) { t.listener(e), t.once && r.off(n, t.listener) }), !i }, n.trigger = function (t, n) { return void 0 === n && (n = {}), this.emit(t, n) }, n._addEvent = function (t, n, e) { var r = this._events; r[t] = r[t] || [], r[t].push(Xn({ listener: n }, e)) }, t }(); var qn = function (t, n) { return (qn = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, n) { t.__proto__ = n } || function (t, n) { for (var e in n) n.hasOwnProperty(e) && (t[e] = n[e]) })(t, n) }; var Ln = function () { return (Ln = Object.assign || function (t) { for (var n, e = 1, r = arguments.length; e < r; e++)for (var i in n = arguments[e]) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]); return t }).apply(this, arguments) }; function Hn(t) { var n = t.container; return n === document.body ? [n.scrollLeft || document.documentElement.scrollLeft, n.scrollTop || document.documentElement.scrollTop] : [n.scrollLeft, n.scrollTop] } var Vn = function (n) { function t() { this.constructor = e } var e, r; function i() { var t = null !== n && n.apply(this, arguments) || this; return t._startRect = null, t._startPos = [], t._prevTime = 0, t._timer = 0, t._prevScrollPos = [0, 0], t._isWait = !1, t } qn(e = i, r = n), e.prototype = null === r ? Object.create(r) : (t.prototype = r.prototype, new t); var o = i.prototype; return o.dragStart = function (t, n) { var e, r = n.container, i = 0, o = 0, a = 0, s = 0; s = r === document.body ? (a = window.innerWidth, window.innerHeight) : (i = (e = r.getBoundingClientRect()).top, o = e.left, a = e.width, e.height), this._startPos = [t.clientX, t.clientY], this._startRect = { top: i, left: o, width: a, height: s }, this._prevScrollPos = this._getScrollPosition([0, 0], n) }, o.drag = function (t, n) { var e = t.clientX, r = t.clientY, i = n.threshold, o = void 0 === i ? 0 : i, a = this._startRect, s = this._startPos, u = [0, 0]; return a.top > r - o ? (s[1] > a.top || r < s[1]) && (u[1] = -1) : a.top + a.height < r + o && (s[1] < a.top + a.height || r > s[1]) && (u[1] = 1), a.left > e - o ? (s[0] > a.left || e < s[0]) && (u[0] = -1) : a.left + a.width < e + o && (s[0] < a.left + a.width || e > s[0]) && (u[0] = 1), clearTimeout(this._timer), !(!u[0] && !u[1]) && this._continueDrag(Ln(Ln({}, n), { direction: u, inputEvent: t, isDrag: !0 })) }, o.checkScroll = function (t) { var n = this; if (this._isWait) return !1; var e = t.prevScrollPos, r = void 0 === e ? this._prevScrollPos : e, i = t.direction, o = t.throttleTime, a = void 0 === o ? 0 : o, s = t.inputEvent, u = t.isDrag, c = this._getScrollPosition(i || [0, 0], t), l = c[0] - r[0], f = c[1] - r[1], p = i || [l ? Math.abs(l) / l : 0, f ? Math.abs(f) / f : 0]; return this._prevScrollPos = c, !(!l && !f) && (this.trigger("move", { offsetX: p[0] ? l : 0, offsetY: p[1] ? f : 0, inputEvent: s }), a && u && (this._timer = window.setTimeout(function () { n._continueDrag(t) }, a)), !0) }, o.dragEnd = function () { clearTimeout(this._timer) }, o._getScrollPosition = function (t, n) { var e = n.container, r = n.getScrollPosition; return (void 0 === r ? Hn : r)({ container: e, direction: t }) }, o._continueDrag = function (t) { var n = this, e = t.container, r = t.direction, i = t.throttleTime, o = t.useScroll, a = t.isDrag, s = t.inputEvent; if (!a || !this._isWait) { var u = Date.now ? Date.now() : (new Date).getTime(), c = Math.max(i + this._prevTime - u, 0); if (0 < c) return this._timer = window.setTimeout(function () { n._continueDrag(t) }, c), !1; this._prevTime = u; var l = this._getScrollPosition(r, t); return this._prevScrollPos = l, a && (this._isWait = !0), this.trigger("scroll", { container: e, direction: r, inputEvent: s }), this._isWait = !1, o || this.checkScroll(Ln(Ln({}, t), { prevScrollPos: l, direction: r, inputEvent: s })) } }, i }(Wn); function Un() { return Date.now ? Date.now() : (new Date).getTime() } function $n(t, n, e, r) { t.addEventListener(n, e, r) } function Zn(t, n, e, r) { t.removeEventListener(n, e, r) } var Kn = function (t, n) { return (Kn = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, n) { t.__proto__ = n } || function (t, n) { for (var e in n) n.hasOwnProperty(e) && (t[e] = n[e]) })(t, n) }; var Jn = function () { return (Jn = Object.assign || function (t) { for (var n, e = 1, r = arguments.length; e < r; e++)for (var i in n = arguments[e]) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]); return t }).apply(this, arguments) }; function Qn(t) { return 180 * (n = [t[0].clientX, t[0].clientY], e = [t[1].clientX, t[1].clientY], r = e[0] - n[0], i = e[1] - n[1], (0 <= (o = Math.atan2(i, r)) ? o : o + 2 * Math.PI) / Math.PI); var n, e, r, i, o } function te(t) { return t.touches ? function (t) { for (var n = Math.min(t.length, 2), e = [], r = 0; r < n; ++r)e.push(re(t[r])); return e }(t.touches) : [re(t)] } function ne(t, n, e) { var r = e.length, i = ie(t, r), o = i.clientX, a = i.clientY, s = i.originalClientX, u = i.originalClientY, c = ie(n, r), l = c.clientX, f = c.clientY, p = ie(e, r); return { clientX: s, clientY: u, deltaX: o - l, deltaY: a - f, distX: o - p.clientX, distY: a - p.clientY } } function ee(t) { return Math.sqrt(Math.pow(t[0].clientX - t[1].clientX, 2) + Math.pow(t[0].clientY - t[1].clientY, 2)) } function re(t) { return { clientX: t.clientX, clientY: t.clientY } } function ie(t, n) { void 0 === n && (n = t.length); for (var e = { clientX: 0, clientY: 0, originalClientX: 0, originalClientY: 0 }, r = 0; r < n; ++r) { var i = t[r]; e.originalClientX += "originalClientX" in i ? i.originalClientX : i.clientX, e.originalClientY += "originalClientY" in i ? i.originalClientY : i.clientY, e.clientX += i.clientX, e.clientY += i.clientY } return n ? { clientX: e.clientX / n, clientY: e.clientY / n, originalClientX: e.originalClientX / n, originalClientY: e.originalClientY / n } : e } var oe = function () { function t(t) { this.prevClients = [], this.startClients = [], this.movement = 0, this.length = 0, this.startClients = t, this.prevClients = t, this.length = t.length } var n = t.prototype; return n.getAngle = function (t) { return void 0 === t && (t = this.prevClients), Qn(t) }, n.getRotation = function (t) { return void 0 === t && (t = this.prevClients), Qn(t) - Qn(this.startClients) }, n.getPosition = function (t, n) { void 0 === t && (t = this.prevClients); var e = ne(t || this.prevClients, this.prevClients, this.startClients), r = e.deltaX, i = e.deltaY; return this.movement += Math.sqrt(r * r + i * i), this.prevClients = t, e }, n.getPositions = function (e) { void 0 === e && (e = this.prevClients); var r = this.prevClients; return this.startClients.map(function (t, n) { return ne([e[n]], [r[n]], [t]) }) }, n.getMovement = function (t) { var n = this.movement; if (!t) return n; var e = ie(t, this.length), r = ie(this.prevClients, this.length), i = e.clientX - r.clientX, o = e.clientY - r.clientY; return Math.sqrt(i * i + o * o) + n }, n.getDistance = function (t) { return void 0 === t && (t = this.prevClients), ee(t) }, n.getScale = function (t) { return void 0 === t && (t = this.prevClients), ee(t) / ee(this.startClients) }, n.move = function (n, e) { this.startClients.forEach(function (t) { t.clientX -= n, t.clientY -= e }) }, t }(), ae = ["textarea", "input"], se = function (u) { function t() { this.constructor = n } var n, e; function r(t, n) { void 0 === n && (n = {}); var b = u.call(this) || this; b.options = {}, b.flag = !1, b.pinchFlag = !1, b.datas = {}, b.isDrag = !1, b.isPinch = !1, b.isMouse = !1, b.isTouch = !1, b.clientStores = [], b.targets = [], b.prevTime = 0, b.doubleFlag = !1, b._dragFlag = !1, b.onDragStart = function (t, n) { if (void 0 === n && (n = !0), b.flag || !1 !== t.cancelable) { var e = b.options, r = e.container, i = e.pinchOutside, o = e.preventRightClick, a = e.preventDefault, s = e.checkInput, u = b.isTouch, c = !b.flag; if (c) { var l, f = document.activeElement, p = t.target, d = p.tagName.toLowerCase(), h = -1 < ae.indexOf(d), v = p.isContentEditable; if (h || v) { if (s || f === p) return !1; if (f && v && f.isContentEditable && f.contains(p)) return !1 } else { (a || "touchstart" === t.type) && f && (l = f.tagName, (f.isContentEditable || -1 < ae.indexOf(l)) && f.blur()) } if (b.clientStores = [new oe(te(t))], b.flag = !0, b.isDrag = !1, b._dragFlag = !0, b.datas = {}, o && (3 === t.which || 2 === t.button)) return b.initDrag(), !1; b.doubleFlag = Un() - b.prevTime < 200, !1 === b.emit("dragStart", Jn({ datas: b.datas, inputEvent: t, isTrusted: n, isDouble: b.doubleFlag }, b.getCurrentStore().getPosition(), { preventDefault: function () { t.preventDefault() }, preventDrag: function () { b._dragFlag = !1 } })) && b.initDrag(), b.flag && a && t.preventDefault() } if (!b.flag) return !1; var g, m = 0; if (c && u && i && (m = setTimeout(function () { $n(r, "touchstart", b.onDragStart, { passive: !1 }) })), !c && u && i && Zn(r, "touchstart", b.onDragStart), b.flag && ((g = t).touches && 2 <= g.touches.length)) { if (clearTimeout(m), c && t.touches.length !== t.changedTouches.length) return; b.pinchFlag || b.onPinchStart(t) } } }, b.onDrag = function (t, n) { if (b.flag) { var e = te(t), r = b.moveClients(e, t, !1); if (b._dragFlag) { if (b.pinchFlag || r.deltaX || r.deltaY) if (!1 === b.emit("drag", Jn({}, r, { isScroll: !!n, inputEvent: t }))) return void b.stop(); b.pinchFlag && b.onPinch(t, e) } b.getCurrentStore().getPosition(e, !0) } }, b.onDragEnd = function (t) { var n, e, r, i, o, a; b.flag && (e = (n = b.options).pinchOutside, r = n.container, b.isTouch && e && Zn(r, "touchstart", b.onDragStart), b.flag = !1, i = b._getPosition(), o = Un(), a = !b.isDrag && b.doubleFlag, b.prevTime = b.isDrag || a ? 0 : o, b.emit("dragEnd", Jn({ datas: b.datas, isDouble: a, isDrag: b.isDrag, isClick: !b.isDrag, inputEvent: t }, i)), b.pinchFlag && b.onPinchEnd(t), b.clientStores = []) }, b.onBlur = function () { b.onDragEnd() }; var e = [].concat(t); b.options = Jn({ checkInput: !1, container: 1 < e.length ? window : e[0], preventRightClick: !0, preventDefault: !0, checkWindowBlur: !1, pinchThreshold: 0, events: ["touch", "mouse"] }, n); var r, i = b.options, o = i.container, a = i.events, s = i.checkWindowBlur; return b.isTouch = -1 < a.indexOf("touch"), b.isMouse = -1 < a.indexOf("mouse"), b.targets = e, b.isMouse && (e.forEach(function (t) { $n(t, "mousedown", b.onDragStart) }), $n(o, "mousemove", b.onDrag), $n(o, "mouseup", b.onDragEnd), $n(o, "contextmenu", b.onDragEnd)), s && $n(window, "blur", b.onBlur), b.isTouch && (r = { passive: !1 }, e.forEach(function (t) { $n(t, "touchstart", b.onDragStart, r) }), $n(o, "touchmove", b.onDrag, r), $n(o, "touchend", b.onDragEnd, r), $n(o, "touchcancel", b.onDragEnd, r)), b } Kn(n = r, e = u), n.prototype = null === e ? Object.create(e) : (t.prototype = e.prototype, new t); var i = r.prototype; return i.stop = function () { this.isDrag = !1, this.flag = !1, this.clientStores = [], this.datas = {} }, i.getMovement = function (t) { return this.getCurrentStore().getMovement(t) + this.clientStores.slice(1).reduce(function (t, n) { return t + n.movement }, 0) }, i.isDragging = function () { return this.isDrag }, i.isFlag = function () { return this.flag }, i.isPinchFlag = function () { return this.pinchFlag }, i.isDoubleFlag = function () { return this.doubleFlag }, i.isPinching = function () { return this.isPinch }, i.scrollBy = function (t, n, e, r) { void 0 === r && (r = !0), this.flag && (this.clientStores[0].move(t, n), r && this.onDrag(e, !0)) }, i.move = function (t, n) { var r = t[0], i = t[1], e = this.getCurrentStore().prevClients; return this.moveClients(e.map(function (t) { var n = t.clientX, e = t.clientY; return { clientX: n + r, clientY: e + i, originalClientX: n, originalClientY: e } }), n, !0) }, i.triggerDragStart = function (t) { this.onDragStart(t, !1) }, i.setEventDatas = function (t) { var n = this.datas; for (var e in t) n[e] = t[e]; return this }, i.getCurrentEvent = function (t) { return Jn({ datas: this.datas }, this._getPosition(), { movement: this.getMovement(), isDrag: this.isDrag, isPinch: this.isPinch, isScroll: !1, inputEvent: t }) }, i.getEventDatas = function () { return this.datas }, i.unset = function () { var n = this, t = this.targets, e = this.options.container; this.off(), Zn(window, "blur", this.onBlur), this.isMouse && (t.forEach(function (t) { Zn(t, "mousedown", n.onDragStart) }), Zn(e, "mousemove", this.onDrag), Zn(e, "mouseup", this.onDragEnd), Zn(e, "contextmenu", this.onDragEnd)), this.isTouch && (t.forEach(function (t) { Zn(t, "touchstart", n.onDragStart) }), Zn(e, "touchstart", this.onDragStart), Zn(e, "touchmove", this.onDrag), Zn(e, "touchend", this.onDragEnd), Zn(e, "touchcancel", this.onDragEnd)) }, i.onPinchStart = function (t) { var n, e = this.options.pinchThreshold; this.isDrag && this.getMovement() > e || (n = new oe(te(t)), this.pinchFlag = !0, this.clientStores.splice(0, 0, n), !1 === this.emit("pinchStart", Jn({ datas: this.datas, angle: n.getAngle(), touches: this.getCurrentStore().getPositions() }, n.getPosition(), { inputEvent: t })) && (this.pinchFlag = !1)) }, i.onPinch = function (t, n) { var e; !this.flag || !this.pinchFlag || n.length < 2 || (e = this.getCurrentStore(), this.isPinch = !0, this.emit("pinch", Jn({ datas: this.datas, movement: this.getMovement(n), angle: e.getAngle(n), rotation: e.getRotation(n), touches: e.getPositions(n), scale: e.getScale(n), distance: e.getDistance(n) }, e.getPosition(n), { inputEvent: t }))) }, i.onPinchEnd = function (t) { var n, e; this.pinchFlag && (n = this.isPinch, this.isPinch = !1, this.pinchFlag = !1, e = this.getCurrentStore(), this.emit("pinchEnd", Jn({ datas: this.datas, isPinch: n, touches: e.getPositions() }, e.getPosition(), { inputEvent: t })), this.isPinch = !1, this.pinchFlag = !1) }, i.initDrag = function () { this.clientStores = [], this.pinchFlag = !1, this.doubleFlag = !1, this.prevTime = 0, this.flag = !1 }, i.getCurrentStore = function () { return this.clientStores[0] }, i.moveClients = function (t, n, e) { var r = this._getPosition(t, e); return (r.deltaX || r.deltaY) && (this.isDrag = !0), Jn({ datas: this.datas }, r, { movement: this.getMovement(t), isDrag: this.isDrag, isPinch: this.isPinch, isScroll: !1, inputEvent: n }) }, i._getPosition = function (t, n) { var e = this.getCurrentStore().getPosition(t, n), r = this.clientStores.slice(1).reduce(function (t, n) { var e = n.getPosition(); return t.distX += e.distX, t.distY += e.distY, t }, e), i = r.distX, o = r.distY; return Jn({}, e, { distX: i, distY: o }) }, r }(Wn), ue = "string", ce = [{ open: "(", close: ")" }, { open: '"', close: '"' }, { open: "'", close: "'" }, { open: '\\"', close: '\\"' }, { open: "\\'", close: "\\'" }]; function le(t, n, e, r, i) { return fe(t, n, e) ? e : function (i, o, t, a, s) { for (var u, n = t; n < a; ++n) { var e = function (t) { var n = o[t].trim(); if (n === i.close && !fe(i, o, t)) return { value: t }; var e = t, r = de(s, function (t) { return t.open === n }); if (r && (e = le(r, o, t, a, s)), -1 === e) return u = t, "break"; u = t = e }(n); if (n = u, "object" == typeof e) return e.value; if ("break" === e) break } return -1 }(t, n, e + 1, r, i) } function fe(t, n, e) { if (!t.ignore) return null; var r = n.slice(Math.max(e - 3, 0), e + 3).join(""); return new RegExp(t.ignore).exec(r) } function pe(t, n) { var e = typeof n === ue ? { separator: n } : n, r = e.separator, s = void 0 === r ? "," : r, u = e.isSeparateFirst, c = e.isSeparateOnlyOpenClose, i = e.isSeparateOpenClose, l = void 0 === i ? c : i, o = e.openCloseCharacters, f = void 0 === o ? ce : o, a = f.map(function (t) { var n = t.open, e = t.close; return n === e ? n : n + "|" + e }).join("|"), p = new RegExp("(\\s*" + s + "\\s*|" + a + "|\\s+)", "g"), d = t.split(p).filter(Boolean), h = d.length, v = [], g = []; function m() { return g.length && (v.push(g.join("")), g = []) } for (var b, x = 0; x < h; ++x) { var E = function (t) { var n, e, r = d[t].trim(), i = t, o = de(f, function (t) { return t.open === r }), a = de(f, function (t) { return t.close === r }); if (o) { if (-1 !== (i = le(o, d, t, h, f)) && l) return m() && u ? (b = t, "break") : (v.push(d.slice(t, i + 1).join("")), t = i, u ? (b = t, "break") : (b = t, "continue")) } else { if (a && !fe(a, d, t)) throw new Error("invalid format: " + a.close); if (n = r, !(("" !== (e = s) && " " != e || "" !== n && " " != n) && n !== e || c)) return m(), u ? (b = t, "break") : (b = t, "continue") } -1 === i && (i = h - 1), g.push(d.slice(t, i + 1).join("")), b = t = i }(x), x = b; if ("break" === E) break } return g.length && v.push(g.join("")), v } function de(t, n, e) { var r = function (t, n, e) { void 0 === e && (e = -1); for (var r = t.length, i = 0; i < r; ++i)if (n(t[i], i, t)) return i; return e }(t, n); return -1 < r ? t[r] : e } var he = function (t) { for (var n = 5381, e = t.length; e;)n = 33 * n ^ t.charCodeAt(--e); return n >>> 0 }; function ve(r, t, n) { return n.original ? t : t.replace(/([^};{\s}][^};{]*|^\s*){/gm, function (t, n) { var e = n.trim(); return (e ? pe(e, ",") : [""]).map(function (t) { var n = t.trim(); return 0 === n.indexOf("@") ? n : -1 < n.indexOf(":global") ? n.replace(/\:global/g, "") : -1 < n.indexOf(":host") ? "" + n.replace(/\:host/g, "." + r) : n ? "." + r + " " + n : "." + r }).join(", ") + " {" }) } function ge(l) { var f, p = "rCS" + he(l).toString(36), d = 0; return { className: p, inject: function (t, n) { void 0 === n && (n = {}); var e, r, i, o, a, s, u = function (t) { if (t && t.getRootNode) { var n = t.getRootNode(); if (11 === n.nodeType) return n } }(t), c = 0 === d; return (u || c) && (r = p, i = l, o = n, a = u, (s = document.createElement("style")).setAttribute("type", "text/css"), s.setAttribute("data-styled-id", r), o.nonce && s.setAttribute("nonce", o.nonce), s.innerHTML = ve(r, i, o), (a || document.head || document.body).appendChild(s), e = s), c && (f = e), u || ++d, { destroy: function () { u ? (t.removeChild(e), e = null) : (0 < d && --d, 0 === d && f && (f.parentNode.removeChild(f), f = null)) } } } } } var me = function (t, n) { return (me = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, n) { t.__proto__ = n } || function (t, n) { for (var e in n) n.hasOwnProperty(e) && (t[e] = n[e]) })(t, n) }; function be(t, n) { function e() { this.constructor = t } me(t, n), t.prototype = null === n ? Object.create(n) : (e.prototype = n.prototype, new e) } var xe = function () { return (xe = Object.assign || function (t) { for (var n, e = 1, r = arguments.length; e < r; e++)for (var i in n = arguments[e]) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]); return t }).apply(this, arguments) }; var Ee = function (n) { function t() { var t = null !== n && n.apply(this, arguments) || this; return t.injectResult = null, t.tag = "div", t } be(t, n); var e = t.prototype; return e.render = function () { var t = this.props, n = t.className, e = void 0 === n ? "" : n, r = (t.cspNonce, t.portalContainer), i = function (t, n) { var e = {}; for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && n.indexOf(r) < 0 && (e[r] = t[r]); if (null != t && "function" == typeof Object.getOwnPropertySymbols) for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)n.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (e[r[i]] = t[r[i]]); return e }(t, ["className", "cspNonce", "portalContainer"]), o = this.injector.className, a = this.tag, s = {}; return -1 < "simple-1.1.0".indexOf("simple") && r && (s = { portalContainer: r }), _(a, xe({ ref: y(this, "element"), "data-styled-id": o, className: e + " " + o }, s, i)) }, e.componentDidMount = function () { this.injectResult = this.injector.inject(this.element, { nonce: this.props.cspNonce }) }, e.componentWillUnmount = function () { this.injectResult.destroy(), this.injectResult = null }, e.getElement = function () { return this.element }, t }(j); function ye(e, t) { var r = ge(t); return function (n) { function t() { var t = null !== n && n.apply(this, arguments) || this; return t.injector = r, t.tag = e, t } return be(t, n), t }(Ee) } var Se = function () { return (Se = Object.assign || function (t) { for (var n, e = 1, r = arguments.length; e < r; e++)for (var i in n = arguments[e]) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]); return t }).apply(this, arguments) }; var Me = function () { function t() { this._events = {} } var n = t.prototype; return n.on = function (t, n) { if (vt(t)) for (var e in t) this.on(e, t[e]); else this._addEvent(t, n, {}); return this }, n.off = function (t, n) { if (t) if (vt(t)) for (var e in t) this.off(e); else { var r, i; n ? !(r = this._events[t]) || -1 < (i = Rt(r, function (t) { return t.listener === n })) && r.splice(i, 1) : this._events[t] = [] } else this._events = {}; return this }, n.once = function (n, t) { var e = this; return t && this._addEvent(n, t, { once: !0 }), new Promise(function (t) { e._addEvent(n, t, { once: !0 }) }) }, n.emit = function (n, e) { var r = this; void 0 === e && (e = {}); var t = this._events[n]; if (!n || !t) return !0; var i = !1; return e.eventType = n, e.stop = function () { i = !0 }, e.currentTarget = this, function () { for (var t = 0, n = 0, e = arguments.length; n < e; n++)t += arguments[n].length; for (var r = Array(t), i = 0, n = 0; n < e; n++)for (var o = arguments[n], a = 0, s = o.length; a < s; a++, i++)r[i] = o[a]; return r }(t).forEach(function (t) { t.listener(e), t.once && r.off(n, t.listener) }), !i }, n.trigger = function (t, n) { return void 0 === n && (n = {}), this.emit(t, n) }, n._addEvent = function (t, n, e) { var r = this._events; r[t] = r[t] || [], r[t].push(Se({ listener: n }, e)) }, t }(), we = function (t, n) { return (we = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, n) { t.__proto__ = n } || function (t, n) { for (var e in n) Object.prototype.hasOwnProperty.call(n, e) && (t[e] = n[e]) })(t, n) }; function De(t, n) { if ("function" != typeof n && null !== n) throw new TypeError("Class extends value " + String(n) + " is not a constructor or null"); function e() { this.constructor = t } we(t, n), t.prototype = null === n ? Object.create(n) : (e.prototype = n.prototype, new e) } var Ce = function () { return (Ce = Object.assign || function (t) { for (var n, e = 1, r = arguments.length; e < r; e++)for (var i in n = arguments[e]) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]); return t }).apply(this, arguments) }; function Re(t, n, e) { if (e || 2 === arguments.length) for (var r, i = 0, o = n.length; i < o; i++)!r && i in n || ((r = r || Array.prototype.slice.call(n, 0, i))[i] = n[i]); return t.concat(r || Array.prototype.slice.call(n)) } function Oe(t, n) { var e; return Ce({ events: {}, props: ((e = {})[t] = Boolean, e), name: t }, n) } var Pe, _e, Be, ze = (void 0 === Pe && function () { if ("undefined" != typeof navigator && navigator && navigator.userAgentData) { var t = navigator.userAgentData, n = t.brands || t.uaList; return n && n.length } }() ? function (t) { var n = navigator.userAgentData, e = (n.uaList || n.brands).slice(), r = n.mobile || !1, i = e[0], o = (t && t.platform || n.platform || navigator.platform).toLowerCase(), a = { name: i.brand, version: i.version, majorVersion: -1, webkit: !1, webkitVersion: "-1", chromium: !1, chromiumVersion: "-1", webview: !!J(rt, e).brand }, s = { name: "unknown", version: "-1", majorVersion: -1 }; a.webkit = !a.chromium && V(et, function (t) { return Q(e, t) }); var u, c = J(nt, e); a.chromium = !!c.brand, a.chromiumVersion = c.version, a.chromium || (u = J(et, e), a.webkit = !!u.brand, a.webkitVersion = u.version); var l = U(it, function (t) { return new RegExp("" + t.test, "g").exec(o) }); s.name = l ? l.id : "", t && (s.version = t.platformVersion); var f = J(tt, e); return f.brand && (a.name = f.brand, a.version = t ? t.uaFullVersion : f.version), a.webkit && (s.name = r ? "ios" : "mac"), "ios" === s.name && a.webview && (a.version = "-1"), s.version = Z(s.version), a.version = Z(a.version), s.majorVersion = parseInt(s.version, 10), a.majorVersion = parseInt(a.version, 10), { browser: a, os: s, isMobile: r, isHints: !0 } }() : ot(Pe)).browser.webkit, Ge = ze && (_e = "undefined" == typeof window ? { userAgent: "" } : window.navigator, !!(Be = /applewebkit\/([^\s]+)/g.exec(_e.userAgent.toLowerCase())) && parseFloat(Be[1]) < 605), Te = "moveable-", ke = "\n{\n\tposition: absolute;\n\twidth: 1px;\n\theight: 1px;\n\tleft: 0;\n\ttop: 0;\n    z-index: 3000;\n    --moveable-color: #4af;\n    --zoom: 1;\n    --zoompx: 1px;\n    will-change: transform;\n}\n.control-box {\n    z-index: 0;\n}\n.line, .control {\n    position: absolute;\n\tleft: 0;\n    top: 0;\n    will-change: transform;\n}\n.control {\n\twidth: 14px;\n\theight: 14px;\n\tborder-radius: 50%;\n\tborder: 2px solid #fff;\n\tbox-sizing: border-box;\n    background: #4af;\n    background: var(--moveable-color);\n\tmargin-top: -7px;\n    margin-left: -7px;\n    border: 2px solid #fff;\n    z-index: 10;\n}\n.padding {\n    position: absolute;\n    top: 0px;\n    left: 0px;\n    width: 100px;\n    height: 100px;\n    transform-origin: 0 0;\n}\n.line {\n\twidth: 1px;\n    height: 1px;\n    background: #4af;\n    background: var(--moveable-color);\n\ttransform-origin: 0px 50%;\n}\n.line.dashed {\n    box-sizing: border-box;\n    background: transparent;\n}\n.line.dashed.horizontal {\n    border-top: 1px dashed #4af;\n    border-top-color: #4af;\n    border-top-color: var(--moveable-color);\n}\n.line.dashed.vertical {\n    border-left: 1px dashed #4af;\n    border-left-color: #4af;\n    border-left-color: var(--moveable-color);\n}\n.line.vertical {\n    transform: translateX(-50%);\n}\n.line.horizontal {\n    transform: translateY(-50%);\n}\n.line.vertical.bold {\n    width: 2px;\n}\n.line.horizontal.bold {\n    height: 2px;\n}\n\n.control.origin {\n\tborder-color: #f55;\n\tbackground: #fff;\n\twidth: 12px;\n\theight: 12px;\n\tmargin-top: -6px;\n    margin-left: -6px;\n\tpointer-events: none;\n}\n" + [0, 15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165].map(function (t) { return '\n.direction[data-rotation="' + t + '"] {\n\t' + (r = 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="' + 32 * (e = 1) + 'px" height="' + 32 * e + 'px" viewBox="0 0 32 32" ><path d="M 16,5 L 12,10 L 14.5,10 L 14.5,22 L 12,22 L 16,27 L 20,22 L 17.5,22 L 17.5,10 L 20, 10 L 16,5 Z" stroke-linejoin="round" stroke-width="1.2" fill="black" stroke="white" style="transform:rotate(' + (n = t) + 'deg);transform-origin: 16px 16px"></path></svg>', i = 45 * Math.round(n / 45) % 180, o = "ns-resize", 135 == i ? o = "nwse-resize" : 45 == i ? o = "nesw-resize" : 90 == i && (o = "ew-resize"), "cursor:" + o + ";cursor: url('" + r + "') 16 16, " + o + ";") + "\n}\n"; var n, e, r, i, o }).join("\n") + "\n.group {\n    z-index: -1;\n}\n.area {\n    position: absolute;\n}\n.area-pieces {\n    position: absolute;\n    top: 0;\n    left: 0;\n    display: none;\n}\n.area.avoid, .area.pass {\n    pointer-events: none;\n}\n.area.avoid+.area-pieces {\n    display: block;\n}\n.area-piece {\n    position: absolute;\n}\n\n" + (Ge ? ':global svg *:before {\n\tcontent:"";\n\ttransform-origin: inherit;\n}' : "") + "\n", Ae = [[0, 1, 2], [1, 0, 3], [2, 0, 3], [3, 1, 2]], Fe = 1e-4, Ie = 1e-7, Ne = Math.pow(10, 10), je = -Ne, Ye = ["n", "w", "s", "e", "nw", "ne", "sw", "se"], Xe = { n: [0, 1], s: [2, 3], w: [2, 0], e: [1, 3], nw: [0], ne: [1], sw: [2], se: [3] }, We = { n: 0, s: 180, w: 270, e: 90, nw: 315, ne: 45, sw: 225, se: 135 }, qe = ["isMoveableElement", "updateRect", "updateTarget", "destroy", "dragStart", "isInside", "hitTest", "setState", "getRect", "request", "isDragging", "getManager", "forceUpdate"]; function Le(t, n, e, r, i) { var o = n.gesto.move(e, t.inputEvent), a = o.originalDatas || o.datas, s = a.draggable || (a.draggable = {}); return Ce(Ce({}, i ? po(n, o) : o), { isDrag: !0, isPinch: !!r, parentEvent: !0, datas: s, originalDatas: t.originalDatas }) } var He = function () { function t() { this.prevX = 0, this.prevY = 0, this.startX = 0, this.startY = 0, this.isDrag = !1, this.isFlag = !1, this.datas = { draggable: {} } } var n = t.prototype; return n.dragStart = function (t, n) { this.isDrag = !1, this.isFlag = !1; var e = n.originalDatas; return (this.datas = e).draggable || (e.draggable = {}), Ce(Ce({}, this.move(t, n.inputEvent)), { type: "dragstart" }) }, n.drag = function (t, n) { return this.move([t[0] - this.prevX, t[1] - this.prevY], n) }, n.move = function (t, n) { var e, r; return this.isFlag ? (e = this.prevX + t[0], r = this.prevY + t[1], this.isDrag = !0) : (this.prevX = t[0], this.prevY = t[1], this.startX = t[0], this.startY = t[1], e = t[0], r = t[1], this.isFlag = !0), { type: "drag", clientX: this.prevX = e, clientY: this.prevY = r, inputEvent: n, isDrag: this.isDrag, distX: e - this.startX, distY: r - this.startY, deltaX: t[0], deltaY: t[1], datas: this.datas.draggable, originalDatas: this.datas, parentEvent: !0, parentGesto: this } }, t }(); function Ve(t, e, r) { var n = r.originalDatas; n.groupable = n.groupable || {}; var i = n.groupable; i.childDatas = i.childDatas || []; var o = i.childDatas; return t.moveables.map(function (t, n) { return o[n] = o[n] || {}, o[n][e] = o[n][e] || {}, Ce(Ce({}, r), { datas: o[n][e], originalDatas: o[n] }) }) } function Ue(t, o, a, s, n, u) { var c = !!a.match(/Start$/g), l = !!a.match(/End$/g), f = n.isPinch, p = n.datas, e = Ve(t, o.name, n), d = t.moveables, r = e.map(function (t, n) { var e = d[n], r = t, r = c ? (new He).dragStart(s, t) : (e.state.gesto || (e.state.gesto = p.childGestos[n]), Le(t, e.state, s, f, u)), i = o[a](e, Ce(Ce({}, r), { parentFlag: !0 })); return l && (e.state.gesto = null), i }); return c && (p.childGestos = d.map(function (t) { return t.state.gesto })), r } function $e(t, o, a, n, s, u) { void 0 === s && (s = function (t, n) { return n }); var c = !!a.match(/End$/g), e = Ve(t, o.name, n), l = t.moveables; return e.map(function (t, n) { var e = l[n], r = s(e, t), i = o[a](e, Ce(Ce({}, r), { parentFlag: !0 })); return i && u && u(e, t, i, n), c && (e.state.gesto = null), i }) } function Ze(t, n, r, i) { void 0 === i && (i = ""); var e = t.state, o = e.renderPoses, a = e.rotation, s = e.direction, u = t.props, c = u.renderDirections, l = void 0 === c ? n : c, f = u.zoom, p = {}; if (!l) return []; var d = 0 < s ? 1 : -1, h = !0 === l ? Ye : l, v = a / Math.PI * 180; return h.forEach(function (t) { p[t] = !0 }), h.map(function (t) { var n = Xe[t]; if (!n || !p[t]) return null; var e = (Nt(v, 15) + d * We[t] + 720) % 180; return r.createElement("div", { className: Ri("control", "direction", t, i), "data-rotation": e, "data-direction": t, key: "direction-" + t, style: Vi.apply(void 0, Re([a, f], n.map(function (t) { return o[t] }))) }) }) } function Ke(t, n, e, r, i, o) { for (var a = [], s = 6; s < arguments.length; s++)a[s - 6] = arguments[s]; var u = At(e, r), c = n ? Nt(u / Math.PI * 180, 15) % 180 : -1; return t.createElement("div", { key: "line" + o, className: Ri.apply(void 0, Re(["line", "direction", n], a)), "data-rotation": c, "data-line-index": o, "data-direction": n, style: Hi(e, r, i, u) }) } function Je(t, n) { return Ze(t, Ye, n) } function Qe(t, n) { return Ze(t, ["nw", "ne", "sw", "se"], n) } function tr(t, n, e, r, i, o) { var a = t.state.is3d ? 4 : 3, s = Ni(t.state.rootMatrix, i, a), u = Kt([o.left, o.top], s); n.startAbsoluteOrigin = u, n.prevDeg = At(u, [e, r]) / Math.PI * 180, n.defaultDeg = n.prevDeg, n.prevSnapDeg = 0, n.loop = 0 } function nr(t, n, e) { var r = e.defaultDeg, i = e.prevDeg, o = i % 360, a = Math.floor(i / 360); o < 0 && (o += 360), t < o && 270 < o && t < 90 ? ++a : o < t && o < 90 && 270 < t && --a; var s = n * (360 * a + t - r); return e.prevDeg = r + s, s } function er(t, n, e, r) { return nr(At(r.startAbsoluteOrigin, [t, n]) / Math.PI * 180, e, r) } function rr(t, n, e, r, i, o) { var a = t.props.throttleRotate, s = void 0 === a ? 0 : a, u = r, c = e.prevSnapDeg; o && (u = function (t, n, e, r) { if (!lr(t, "rotatable")) return r; var i = n.pos1, o = n.pos2, a = n.pos3, s = n.pos4, u = r * Math.PI / 180, c = [i, o, a, s].map(function (t) { return Jt(t, e) }), l = c.map(function (t) { return an(t, u) }), f = Re(Re([], function (t, c, n, e, r) { if (!t.props.bounds) return []; var l = r * Math.PI / 180, i = Tr(t), o = i.left, a = i.top, s = i.right, u = i.bottom, f = o - e[0], p = s - e[0], d = a - e[1], h = u - e[1], v = { left: f, top: d, right: p, bottom: h }; if (!Ar(n, v, 0)) return []; var g = []; return [[f, 0], [p, 0], [d, 1], [h, 1]].forEach(function (t) { var s = t[0], u = t[1]; n.forEach(function (t) { var e, n, r, i, o, a = At([0, 0], t); g.push.apply(g, (n = s, r = u, i = qi(e = t), [o = Math.sqrt(i * i - n * n) || 0, -o].sort(function (t, n) { return Math.abs(t - e[r ? 0 : 1]) - Math.abs(n - e[r ? 0 : 1]) }).map(function (t) { return At([0, 0], r ? [t, n] : [n, t]) }).map(function (t) { return l + t - a }).filter(function (t) { return !Ar(c, v, t) }).map(function (t) { return Nt(180 * t / Math.PI, Ie) }))) }) }), g }(t, c, l, e, r)), function (t, n, e, r, i) { var o = t.props.innerBounds, a = i * Math.PI / 180; if (!o) return []; var s = o.left, u = o.top, c = o.width, l = o.height, f = s - r[0], p = s + c - r[0], d = u - r[1], h = u + l - r[1], v = [[f, d], [p, d], [f, h], [p, h]], g = di(e, [0, 0]); if (!zr(e, v, g, 0)) return []; var m = [], b = v.map(function (t) { return [qi(t), At([0, 0], t)] }); return [[e[0], e[1]], [e[1], e[3]], [e[3], e[2]], [e[2], e[0]]].forEach(function (t) { var i = At([0, 0], function (t) { var n = t[0], e = t[1], r = e[0] - n[0], i = e[1] - n[1]; if (!r) return [n[0], 0]; if (!i) return [0, n[1]]; var o = i / r, a = -o * n[0] + n[1]; return [-a / (o + 1 / o), a / (o * o + 1)] }(t)), o = function (t) { var n = t[0], e = t[1], r = e[0] - n[0], i = e[1] - n[1]; if (!r) return Math.abs(n[0]); if (!i) return Math.abs(n[1]); var o = i / r; return Math.abs((-o * n[0] + n[1]) / Math.sqrt(Math.pow(o, 2) + 1)) }(t); m.push.apply(m, b.filter(function (t) { var n = t[0]; return n && o <= n }).map(function (t) { var n = t[0], e = t[1], r = Math.acos(n ? o / n : 0); return [a + (e + r) - i, a + (e - r) - i] }).reduce(function (t, n) { return t.push.apply(t, n), t }, []).filter(function (t) { return !zr(n, v, g, t) }).map(function (t) { return Nt(180 * t / Math.PI, Ie) })) }), m }(t, c, l, e, r)); return f.sort(function (t, n) { return Math.abs(t - r) - Math.abs(n - r) }), f.length ? f[0] : r }(t, n, e.origin, u)); var l = Nt(i + u, s), f = l - i; return [(e.prevSnapDeg = f) - c, u, l] } function ir(t, n) { if (n.isRequest) return "rotatable" === n.requestAble; var e = n.inputEvent.target; if (Yt(e, Ri("rotation-control"))) return !0; var r = t.props.rotationTarget; return !!r && Eo(r, !0).some(function (t) { return !!t && (e === t || e.contains(t)) }) } var or = { name: "rotatable", canPinch: !0, props: { rotatable: Boolean, rotationPosition: String, throttleRotate: Number, renderDirections: Object, rotationTarget: Object }, events: { onRotateStart: "rotateStart", onBeforeRotate: "beforeRotate", onRotate: "rotate", onRotateEnd: "rotateEnd", onRotateGroupStart: "rotateGroupStart", onBeforeRotateGroup: "beforeRotateGroup", onRotateGroup: "rotateGroup", onRotateGroupEnd: "rotateGroupEnd" }, css: [".rotation {\n            position: absolute;\n            height: 40px;\n            width: 1px;\n            transform-origin: 50% 100%;\n            height: calc(40px * var(--zoom));\n            top: auto;\n            left: 0;\n            bottom: 100%;\n            will-change: transform;\n        }\n        .rotation .rotation-line {\n            display: block;\n            width: 100%;\n            height: 100%;\n            transform-origin: 50% 50%;\n        }\n        .rotation .rotation-control {\n            border-color: #4af;\n            border-color: var(--moveable-color);\n            background:#fff;\n            cursor: alias;\n        }"], render: function (t, n) { var e = t.props, r = e.rotatable, i = e.rotationPosition, o = e.zoom, a = e.renderDirections, s = t.state, u = s.renderPoses, c = s.direction; if (!r) return null; var l, f, p = function (t, n, e) { var r = n[0], i = n[1], o = n[2], a = n[3]; if ("none" !== t) { var s = (t || "top").split("-"), u = s[0], c = s[1], l = [r, i]; "left" === u ? l = [o, r] : "right" === u ? l = [i, a] : "bottom" === u && (l = [a, o]); var f, p, d = [(l[0][0] + l[1][0]) / 2, (l[0][1] + l[1][1]) / 2], h = $i(l, e); return c && (p = "bottom" === u || "left" === u, d = l[(f = "top" === c || "left" === c) && !p || !f && p ? 0 : 1]), [d, h] } }(i, u, c), d = []; return p && (l = p[0], f = p[1], d.push(n.createElement("div", { key: "rotation", className: Ri("rotation"), style: { transform: "translate(-50%) translate(" + l[0] + "px, " + l[1] + "px) rotate(" + f + "rad)" } }, n.createElement("div", { className: Ri("line rotation-line"), style: { transform: "scaleX(" + o + ")" } }), n.createElement("div", { className: Ri("control rotation-control"), style: { transform: "translate(0.5px) scale(" + o + ")" } })))), a && d.push.apply(d, Ze(t, [], n)), d }, dragControlCondition: ir, dragControlStart: function (t, n) { var e = n.datas, r = n.clientX, i = n.clientY, o = n.parentRotate, a = n.parentFlag, s = n.isPinch, u = n.isRequest, c = t.state, l = c.target, f = c.left, p = c.top, d = c.origin, h = c.beforeOrigin, v = c.direction, g = c.beforeDirection, m = c.targetTransform, b = c.moveableClientRect; if (!u && !l) return !1; var x, E = t.getRect(); e.rect = E, e.transform = m, e.left = f, e.top = p, e.fixedPosition = wi(t, Mi(t)), u || s || a ? (x = o || 0, e.beforeInfo = { origin: E.beforeOrigin, prevDeg: x, defaultDeg: x, prevSnapDeg: 0 }, e.afterInfo = Ce(Ce({}, e.beforeInfo), { origin: E.origin }), e.absoluteInfo = Ce(Ce({}, e.beforeInfo), { origin: E.origin, startValue: x })) : (e.beforeInfo = { origin: E.beforeOrigin }, e.afterInfo = { origin: E.origin }, e.absoluteInfo = { origin: E.origin, startValue: E.rotation }, tr(t, e.beforeInfo, r, i, h, b), tr(t, e.afterInfo, r, i, d, b), tr(t, e.absoluteInfo, r, i, d, b)), e.direction = v, e.beforeDirection = g, e.startValue = 0, e.datas = {}, mi(n, "rotate"); var y = ro(t, n, Ce(Ce({ set: function (t) { e.startValue = t * Math.PI / 180 } }, gi(n)), { dragStart: ri.dragStart(t, (new He).dragStart([0, 0], n)) })), S = ao(t, "onRotateStart", y); return e.isRotate = !1 !== S, t.state.snapRenderInfo = { request: n.isRequest }, !!e.isRotate && y }, dragControl: function (t, n) { var e, r, i, o = n.datas, a = n.clientX, s = n.clientY, u = n.parentRotate, c = n.parentFlag, l = n.isPinch, f = n.groupDelta, p = o.beforeDirection, d = o.beforeInfo, h = o.afterInfo, v = o.absoluteInfo, g = o.isRotate, m = o.startValue, b = o.rect; if (g) { ai(n, "rotate"); var x, E, y, S, M, w, D, C, R, O, P = p * Wi(n.datas.beforeTransform, [50, 50], 100, 100).direction, _ = t.props.parentMoveable, B = 180 / Math.PI * m, z = v.startValue, G = !1; if (!c && "parentDist" in n ? (D = n.parentDist, O = R = C = D) : l || c ? (C = nr(u, p, d), R = nr(u, P, h), O = nr(u, P, v)) : (C = er(a, s, p, d), R = er(a, s, P, h), O = er(a, s, P, v), G = !0), ao(t, "onBeforeRotate", ro(t, n, { beforeRotation: B + C, rotation: B + R, absoluteRotation: z + O, setRotation: function (t) { O = C = R = t - B } })), x = (e = rr(t, b, d, C, B, G))[0], C = e[1], E = e[2], y = (r = rr(t, b, h, R, B, G))[0], R = r[1], S = r[2], M = (i = rr(t, b, v, O, z, G))[0], O = i[1], w = i[2], M || y || x || _) { var T, k, A, F, I, N = si(o, "rotate(" + S + "deg)", "rotate(" + R + "deg)"), j = (T = t, k = R, A = o.fixedPosition, F = o, I = Mi(T), Si(T, "rotate(" + k + "deg)", I, A, F)), Y = Jt(Kt(f || [0, 0], j), o.prevInverseDist || [0, 0]); o.prevInverseDist = j, o.requestValue = null; var X = ro(t, n, Ce({ delta: y, dist: R, rotate: S, rotation: S, beforeDist: C, beforeDelta: x, beforeRotate: E, beforeRotation: E, absoluteDist: O, absoluteDelta: M, absoluteRotate: w, absoluteRotation: w, isPinch: !!l }, yi(t, N, Y, l, n))); return ao(t, "onRotate", X), X } } }, dragControlAfter: function (t, n) { n.datas.requestValue }, dragControlEnd: function (t, n) { var e = n.datas; if (e.isRotate) { e.isRotate = !1; var r = io(t, n, {}); return ao(t, "onRotateEnd", r), r } }, dragGroupControlCondition: ir, dragGroupControlStart: function (t, n) { var e = n.datas, r = t.state, s = r.left, u = r.top, c = r.beforeOrigin, i = this.dragControlStart(t, n); if (!i) return !1; i.set(e.beforeDirection * t.rotation); var o = $e(t, this, "dragControlStart", n, function (t, n) { var e = t.state, r = e.left, i = e.top, o = e.beforeOrigin, a = Kt(Jt([r, i], [s, u]), Jt(o, c)); return n.datas.groupClient = a, Ce(Ce({}, n), { parentRotate: 0 }) }), a = ao(t, "onRotateGroupStart", Ce(Ce({}, i), { targets: t.props.targets, events: o })); return e.isRotate = !1 !== a, !!e.isRotate && i }, dragGroupControl: function (n, e) { var t = e.datas; if (t.isRotate) { oo(n, "onBeforeRotate", function (t) { ao(n, "onBeforeRotateGroup", ro(n, e, Ce(Ce({}, t), { targets: n.props.targets }))) }); var r = this.dragControl(n, e); if (r) { var c = t.beforeDirection, l = r.beforeDist, f = r.beforeDelta / 180 * Math.PI, i = $e(n, this, "dragControl", e, function (t, n) { var e = n.datas.groupClient, r = e[0], i = e[1], o = an([r, i], f * c), a = o[0], s = o[1], u = [a - r, s - i]; return n.datas.groupClient = [a, s], Ce(Ce({}, n), { parentRotate: l, groupDelta: u }) }); n.rotation = c * r.beforeRotation; var o = Ce({ targets: n.props.targets, events: i, set: function (t) { n.rotation = t }, setGroupRotation: function (t) { n.rotation = t } }, r); return ao(n, "onRotateGroup", o), o } } }, dragGroupControlEnd: function (t, n) { var e = n.isDrag; if (n.datas.isRotate) { this.dragControlEnd(t, n); var r = $e(t, this, "dragControlEnd", n); return ao(t, "onRotateGroupEnd", io(t, n, { targets: t.props.targets, events: r })), e } }, request: function (t) { var n = {}, e = 0, r = t.getRotation(); return { isControl: !0, requestStart: function () { return { datas: n } }, request: function (t) { return "deltaRotate" in t ? e += t.deltaRotate : "rotate" in t && (e = t.rotate - r), { datas: n, parentDist: e } }, requestEnd: function () { return { datas: n, isDrag: !0 } } } } }, ar = ["left", "right", "center"], sr = ["top", "bottom", "middle"], ur = { start: "left", end: "right", center: "center" }, cr = { start: "top", end: "bottom", center: "middle" }; function lr(t, n) { var e = t.props, r = e.snappable, i = e.bounds, o = e.innerBounds, a = e.verticalGuidelines, s = e.horizontalGuidelines, u = e.snapGridWidth, c = e.snapGridHeight, l = t.state, f = l.guidelines, p = l.enableSnap; return r && p && !(n && !0 !== r && r.indexOf(n) < 0) && !!(u || c || i || o || f && f.length || a && a.length || s && s.length) } function fr(t) { return !1 === t ? {} : !0 !== t && t ? t : { left: !0, right: !0, top: !0, bottom: !0 } } function pr(t, n) { var e = function (t, n) { var e = fr(t), r = {}; for (var i in e) i in n && e[i] && (r[i] = n[i]); return r }(t, n), r = sr.filter(function (t) { return t in e }), i = ar.filter(function (t) { return t in e }); return { horizontal: r.map(function (t) { return e[t] }), vertical: i.map(function (t) { return e[t] }) } } function dr(t, n, e, r, i, o, a) { void 0 === i && (i = 0), void 0 === o && (o = 0), void 0 === a && (a = { left: 0, top: 0, right: 0, bottom: 0 }); var s = [], u = a.left, c = a.top, l = a.bottom, f = e + a.right - u, p = r + l - c; return t && t.forEach(function (t) { s.push({ type: "horizontal", pos: [u, Nt(t - o + c, .1)], size: f }) }), n && n.forEach(function (t) { s.push({ type: "vertical", pos: [Nt(t - i + u, .1), c], size: p }) }), s } function hr(t, n) { if (!n.length) return []; var e, r, i, o = t.state, a = o.containerClientRect, s = o.targetClientRect, u = s.top, c = s.left, p = o.rootMatrix, d = o.is3d ? 4 : 3, l = (r = d, i = Ni(p, [(e = a).clientLeft, e.clientTop], r), [e.left + i[0], e.top + i[1]]), h = l[0], v = l[1], f = Tn(no(o)), g = Jt([f.minX, f.minY], fo(p, [c - h, u - v], d)).map(function (t) { return n = t, Math.round(n % 1 == -.5 ? n - 1 : n); var n }), m = g[0], b = g[1]; return n.map(function (t) { var n = t.element.getBoundingClientRect(), e = n.left - h, r = n.top - v, i = r + n.height, o = e + n.width, a = fo(p, [e, r], d), s = a[0], u = a[1], c = fo(p, [o, i], d), l = c[0], f = c[1]; return Ce(Ce({}, t), { rect: { left: s + m, right: l + m, top: u + b, bottom: f + b, center: (s + l) / 2 + m, middle: (u + f) / 2 + b } }) }) } function vr(t) { var n = t.state, e = t.props.elementGuidelines, r = void 0 === e ? [] : e; if (!r.length) return n.elementRects = [], []; var i, o, a = (n.elementRects || []).filter(function (t) { return !t.refresh }), s = r.map(function (t) { return vt(t) && "element" in t ? t : { element: xo(t, !0) } }).filter(function (t) { return t.element }), u = (i = a.map(function (t) { return t.element }), o = s.map(function (t) { return t.element }), p(i, o, Dn)), c = u.maintained, l = u.added, f = []; c.forEach(function (t) { var n = t[0], e = t[1]; f[e] = a[n] }), hr(t, l.map(function (t) { return s[t] })).map(function (t, n) { f[l[n]] = t }), n.elementRects = f; var w = fr(t.props.elementSnapDirections), D = []; return f.forEach(function (n) { var e = n.element, t = n.top, r = void 0 === t ? w.top : t, i = n.left, o = void 0 === i ? w.left : i, a = n.right, s = void 0 === a ? w.right : a, u = n.bottom, c = void 0 === u ? w.bottom : u, l = n.center, f = void 0 === l ? w.center : l, p = n.middle, d = void 0 === p ? w.middle : p, h = n.className, v = n.rect, g = pr({ top: r, right: s, left: o, bottom: c, center: f, middle: d }, v), m = g.horizontal, b = g.vertical, x = v.top, E = v.left, y = v.right - E, S = v.bottom - x, M = [y, S]; b.forEach(function (t) { D.push({ type: "vertical", element: e, pos: [Nt(t, .1), x], size: S, sizes: M, className: h, elementRect: n }) }), m.forEach(function (t) { D.push({ type: "horizontal", element: e, pos: [E, Nt(t, .1)], size: y, sizes: M, className: h, elementRect: n }) }) }), D } function gr(t) { var n, e, r, i, o, a, x, c, E, s = t.state, u = s.snapOffset, l = s.containerClientRect, f = l.overflow, p = l.scrollHeight, d = l.scrollWidth, h = l.clientHeight, v = l.clientWidth, g = l.clientLeft, m = l.clientTop, b = t.props, y = b.snapGap, S = void 0 === y || y, M = b.verticalGuidelines, w = b.horizontalGuidelines, D = b.snapThreshold, C = void 0 === D ? 5 : D, R = b.snapGridWidth, O = void 0 === R ? 0 : R, P = b.snapGridHeight, _ = void 0 === P ? 0 : P, B = Re([], vr(t)); return S && (e = (n = Yi(no(t.state))).top, r = n.left, i = n.bottom, o = n.right, B.push.apply(B, (a = { top: e, left: r, bottom: i, right: o, center: (r + o) / 2, middle: (e + i) / 2 }, x = C, c = t.state.elementRects, E = [], [["vertical", ur, cr], ["horizontal", cr, ur]].forEach(function (t) { var h = t[0], v = t[1], s = t[2], g = a[v.start], m = a[v.end], b = a[v.center], e = a[s.start], r = a[s.end]; function i(t) { var n = t.rect; return n[v.end] < g + x ? g - n[v.end] : m - x < n[v.start] ? n[v.start] - m : -1 } var n = c.filter(function (t) { var n = t.rect; return !(n[s.start] > r || n[s.end] < e) && 0 < i(t) }).sort(function (t, n) { return i(t) - i(n) }), u = []; n.forEach(function (a) { n.forEach(function (t) { var n, e, r, i, o; a !== t && (n = a.rect, e = t.rect, r = n[s.start], i = n[s.end], o = e[s.start], e[s.end] < r || i < o || u.push([a, t])) }) }), u.forEach(function (t) { var n = t[0], e = t[1], r = n.rect, i = e.rect, o = r[v.start], a = r[v.end], s = i[v.start], u = i[v.end], c = 0, l = 0, f = !1, p = !1, d = !1; if (a <= g && m <= s) { if (p = !0, l = a + (c = (s - a - (m - g)) / 2) + (m - g) / 2, Math.abs(l - b) > x) return } else if (a < s && u < g + x) { if (f = !0, l = u + (c = s - a), Math.abs(l - g) > x) return } else { if (!(a < s && m - x < o)) return; if (d = !0, l = o - (c = s - a), Math.abs(l - m) > x) return } c && E.push({ type: h, pos: "vertical" === h ? [l, 0] : [0, l], element: e.element, size: 0, className: e.className, isStart: f, isCenter: p, isEnd: d, gap: c, hide: !0, gapRects: [n, e] }) }) }), E))), B.push.apply(B, function (t, n, e, r, i, o) { void 0 === i && (i = 0); void 0 === o && (o = 0); var a = []; if (n) for (var s = 0; s <= r; s += n)a.push({ type: "horizontal", pos: [0, Nt(s - o, .1)], size: e, hide: !0 }); if (t) for (s = 0; s <= e; s += t)a.push({ type: "vertical", pos: [Nt(s - i, .1), 0], size: r, hide: !0 }); return a }(O, _, f ? d : v, f ? p : h, g, m)), B.push.apply(B, dr(w || !1, M || !1, f ? d : v, f ? p : h, g, m, u)), B } function mr(t, n, e, r) { var i = function () { for (var t = [], n = 0; n < arguments.length; n++)t[n] = arguments[n]; for (var e = t.length - 1, r = 0; r < e; ++r) { var i = t[r]; if (!ht(i)) return i } return t[e] }(r, t.props.snapThreshold, 5); return br(t.state.guidelines, n, e, i) } function br(t, n, e, r) { return { vertical: yr(t, "vertical", n, r), horizontal: yr(t, "horizontal", e, r) } } function xr(t, n, e) { var r = pr(t.props.snapDirections, n); return mr(t, r.vertical, r.horizontal, e) } function Er(t) { var n = t.isSnap; if (!n) return { isSnap: !1, offset: 0, dist: -1, pos: 0, guideline: null }; var e = t.posInfos[0], r = e.guidelineInfos[0], i = r.offset, o = r.dist, a = r.guideline; return { isSnap: n, offset: i, dist: o, pos: e.pos, guideline: a } } function yr(e, i, t, o) { if (!e || !e.length) return { isSnap: !1, index: -1, posInfos: [] }; var a = "vertical" === i ? 0 : 1, n = t.map(function (r, t) { var n = e.map(function (t) { var n = t.pos, e = r - n[a]; return { offset: e, dist: Math.abs(e), guideline: t } }).filter(function (t) { var n = t.guideline, e = t.dist; return !(n.type !== i || o < e) }).sort(function (t, n) { return t.dist - n.dist }); return { pos: r, index: t, guidelineInfos: n } }).filter(function (t) { return 0 < t.guidelineInfos.length }).sort(function (t, n) { return t.guidelineInfos[0].dist - n.guidelineInfos[0].dist }), r = 0 < n.length; return { isSnap: r, index: r ? n[0].index : -1, posInfos: n } } function Sr(t, n) { var e = Math.abs(t.offset), r = Math.abs(n.offset); return t.isBound && n.isBound ? r - e : t.isBound ? -1 : n.isBound ? 1 : t.isSnap && n.isSnap ? r - e : t.isSnap ? -1 : n.isSnap || e < Ie ? 1 : r < Ie ? -1 : e - r } function Mr(t, a) { return t.slice().sort(function (t, n) { var e = t.sign[a], r = n.sign[a], i = t.offset[a], o = n.offset[a]; return e ? r ? Sr({ isBound: t.isBound, isSnap: t.isSnap, offset: i }, { isBound: n.isBound, isSnap: n.isSnap, offset: o }) : -1 : 1 })[0] } function wr(t, n) { var e = kt([n[0][0], n[1][0]]), r = kt([n[0][1], n[1][1]]); return { vertical: e <= t[0], horizontal: r <= t[1] } } function Dr(t, n) { var e, r, i = n[0], o = n[1], a = o[0] - i[0], s = o[1] - i[1]; return Math.abs(a) < Ie && (a = 0), Math.abs(s) < Ie && (s = 0), r = a ? (e = s ? s / a * (t[0] - i[0]) + i[1] : i[1], t[1]) : (e = i[0], t[0]), e - r } function Cr(t, e, r) { void 0 === r && (r = Ie); var i = Dr(t[0], e) <= 0; return t.slice(1).every(function (t) { var n = Dr(t, e); return n <= 0 == i || Math.abs(n) <= r }) } function Rr(t, n, e, r, i) { return void 0 === i && (i = 0), r && n - i <= t || !r && t <= e + i ? { isBound: !0, offset: r ? n - t : e - t } : { isBound: !1, offset: 0 } } function Or(t, n, e, r, i) { var o = t[0], a = t[1], s = n[0], u = n[1], c = go(a[1] - o[1]), l = go(a[0] - o[0]), f = go(u[1] - s[1]); if (!go(u[0] - s[0])) { if (i && !c) return { isBound: !1, offset: 0 }; if (l) return Rr(c / l * (s[0] - o[0]) + o[1], s[1], u[1], e, r); var p = s[0] - o[0]; return { isBound: d = Math.abs(p) <= (r || 0), offset: d ? p : 0 } } if (f) return { isBound: !1, offset: 0 }; if (i && !l) return { isBound: !1, offset: 0 }; if (c) return Rr((s[1] - o[1]) / (c / l) + o[0], s[0], u[0], e, r); var d, p = s[1] - o[1]; return { isBound: d = Math.abs(p) <= (r || 0), offset: d ? p : 0 } } function Pr(l, t, f, p) { return t.map(function (t) { var e = t[0], n = t[1], r = t[2], i = function (t, n, e) { var r = t.props.innerBounds; if (!r) return { isAllBound: !1, isBound: !1, isVerticalBound: !1, isHorizontalBound: !1, offset: [0, 0] }; var i = r.left, o = r.top, a = r.width, s = r.height, u = [[i, o], [i, o + s]], c = [[i, o], [i + a, o]], l = [[i + a, o], [i + a, o + s]], f = [[i, o + s], [i + a, o + s]], p = wr(e, n), d = p.horizontal, h = p.vertical; if (Cr([e, [i, o], [i + a, o], [i, o + s], [i + a, o + s]], n)) return { isAllBound: !1, isBound: !1, isVerticalBound: !1, isHorizontalBound: !1, offset: [0, 0] }; var v = Or(n, c, h), g = Or(n, f, h), m = Or(n, u, d), b = Or(n, l, d), x = v.isBound && g.isBound, E = v.isBound || g.isBound, y = m.isBound && b.isBound, S = m.isBound || b.isBound, M = lo(v.offset, g.offset), w = lo(m.offset, b.offset), D = [0, 0], C = !1; return { isAllBound: Math.abs(w) < Math.abs(M) ? (D = [M, 0], C = E, x) : (D = [0, w], C = S, y), isVerticalBound: E, isHorizontalBound: S, isBound: C, offset: D } }(l, [n, r], f), o = i.isBound, a = i.offset, s = i.isVerticalBound, u = i.isHorizontalBound, c = li({ datas: p, distX: a[0], distY: a[1] }).map(function (t, n) { return t * (e[n] ? 2 / e[n] : 0) }); return { sign: e, isBound: o, isVerticalBound: s, isHorizontalBound: u, isSnap: !1, offset: c } }) } function _r(t, n, e) { var r, i, o, a, s, u, c, l, f, p, d, h, v, g = Pr(t, Br(n, [0, 0], !1).map(function (t) { var n = t[0], e = t[1], r = t[2]; return [n.map(function (t) { return 2 * Math.abs(t) }), e, r] }), di(n, [0, 0]), e), m = Mr(g, 0), b = Mr(g, 1), x = 0, E = 0, y = m.isVerticalBound || b.isVerticalBound, S = m.isHorizontalBound || b.isHorizontalBound; return (y || S) && (i = { datas: e, distX: -m.offset[0], distY: -b.offset[1] }, a = i.datas, s = i.distX, u = i.distY, c = a.beforeMatrix, l = a.matrix, f = a.is3d, p = a.startDragBeforeDist, d = a.startDragDist, h = a.absoluteOrigin, v = f ? 4 : 3, x = (r = Jt(tn(o ? c : l, Kt(o ? p : d, [s, u]), v), h))[0], E = r[1]), { vertical: { isBound: y, offset: x }, horizontal: { isBound: S, offset: E } } } function Br(i, t, n) { return r = n, o = [], a = (e = t)[0], s = e[1], a && s ? o.push([[0, 2 * s], e, [-a, s]], [[2 * a, 0], e, [a, -s]]) : a ? (o.push([[2 * a, 0], [a, 1], [a, -1]]), r && o.push([[0, -1], [a, -1], [-a, -1]], [[0, 1], [a, 1], [-a, 1]])) : s ? (o.push([[0, 2 * s], [1, s], [-1, s]]), r && o.push([[-1, 0], [-1, s], [-1, -s]], [[1, 0], [1, s], [1, -s]])) : o.push([[-1, 0], [-1, -1], [-1, 1]], [[1, 0], [1, -1], [1, 1]], [[0, -1], [-1, -1], [1, -1]], [[0, 1], [-1, 1], [1, 1]]), o.map(function (t) { var n = t[0], e = t[1], r = t[2]; return [n, di(i, e), di(i, r)] }); var e, r, o, a, s } function zr(t, n, e, r) { var i = r ? t.map(function (t) { return an(t, r) }) : t, o = Re([e], n); return [[i[0], i[1]], [i[1], i[3]], [i[3], i[2]], [i[2], i[0]]].some(function (t) { return !Cr(o, t) }) } function Gr(t, n, e) { var r = t || {}, i = r.position, o = r.left, a = r.top, s = r.right, u = r.bottom, c = { position: void 0 === i ? "client" : i, left: void 0 === o ? -1 / 0 : o, top: void 0 === a ? -1 / 0 : a, right: void 0 === s ? 1 / 0 : s, bottom: void 0 === u ? 1 / 0 : u }; return { vertical: kr(c, n, !0), horizontal: kr(c, e, !1) } } function Tr(t, n) { var e = t.state, r = e.containerClientRect, i = r.clientHeight, o = r.clientWidth, a = r.clientLeft, s = r.clientTop, u = e.snapOffset, c = u.left, l = u.top, f = u.right, p = u.bottom, d = n || t.props.bounds || {}, h = "css" === (d.position || "client"), v = d.left, g = d.top, m = d.right, b = void 0 === m ? h ? -1 / 0 : 1 / 0 : m, x = d.bottom, E = void 0 === x ? h ? -1 / 0 : 1 / 0 : x; return h && (b = o + f - c - b, E = i + p - l - E), { left: (void 0 === v ? -1 / 0 : v) + c - a, right: b + c - a, top: (void 0 === g ? -1 / 0 : g) + l - s, bottom: E + l - s } } function kr(t, n, e) { var r = t[e ? "left" : "top"], i = t[e ? "right" : "bottom"], o = Math.min.apply(Math, n), a = Math.max.apply(Math, n), s = []; return o < r + 1 && s.push({ isBound: !0, offset: o - r, pos: r }), i - 1 < a && s.push({ isBound: !0, offset: a - i, pos: i }), s.length || s.push({ isBound: !1, offset: 0, pos: 0 }), s.sort(function (t, n) { return Math.abs(n.offset) - Math.abs(t.offset) }) } function Ar(t, n, e) { return (e ? t.map(function (t) { return an(t, e) }) : t).some(function (t) { return t[0] < n.left && .1 < Math.abs(t[0] - n.left) || t[0] > n.right && .1 < Math.abs(t[0] - n.right) || t[1] < n.top && .1 < Math.abs(t[1] - n.top) || t[1] > n.bottom && .1 < Math.abs(t[1] - n.bottom) }) } function Fr(t, n) { return e = Ce(Ce({}, t), { classNames: Re([Ri("line", "guideline", t.direction)], t.classNames).filter(function (t) { return t }), size: t.size || t.sizeValue + "px", pos: t.pos || t.posValue.map(function (t) { return Nt(t, .1) + "px" }) }), r = n, o = e.direction, a = e.classNames, s = e.size, u = e.pos, c = e.zoom, l = e.key, p = (f = "horizontal" === o) ? "Y" : "X", r.createElement("div", { key: l, className: a.join(" "), style: ((i = {})[f ? "width" : "height"] = "" + s, i.transform = "translate(" + u[0] + ", " + u[1] + ") translate" + p + "(-50%) scale" + p + "(" + c + ")", i) }); var e, r, i, o, a, s, u, c, l, f, p } function Ir(t, o, n, a, s, u, c, l) { var f = t.props.zoom; return n.map(function (t, n) { var e = t.type, r = t.pos, i = [0, 0]; return i[c] = a, i[c ? 0 : 1] = -s + r, Fr({ key: o + "TargetGuideline" + n, classNames: [Ri("target", "bold", e)], posValue: i, sizeValue: u, zoom: f, direction: o }, l) }) } function Nr(t, a, n, s, e, u) { var r = t.props, c = r.zoom, i = r.isDisplayInnerSnapDigit, o = "horizontal" === a ? ur : cr, l = e[o.start], f = e[o.end]; return n.filter(function (t) { var n = t.hide, e = t.elementRect; if (n) return !1; if (i && e) { var r = e.rect; if (r[o.start] <= l && f <= r[o.end]) return !1 } return !0 }).map(function (t, n) { var e = t.pos, r = t.size, i = t.element, o = [-s[0] + e[0], -s[1] + e[1]]; return Fr({ key: a + "-default-guideline-" + n, classNames: i ? [Ri("bold")] : [], direction: a, posValue: o, sizeValue: r, zoom: c }, u) }) } function jr(t, n, e, r, i, o, a, s) { var u, c = t.props, l = c.snapDigit, f = void 0 === l ? 0 : l, p = c.isDisplaySnapDigit, d = void 0 === p || p, h = c.snapDistFormat, v = void 0 === h ? function (t) { return t } : h, g = c.zoom, m = "horizontal" === n ? "X" : "Y", b = "vertical" === n ? "height" : "width", x = Math.abs(i), E = d ? parseFloat(x.toFixed(f)) : 0; return s.createElement("div", { key: n + "-" + e + "-guideline-" + r, className: Ri("guideline-group", n), style: ((u = { left: o[0] + "px", top: o[1] + "px" })[b] = x + "px", u) }, Fr({ direction: n, classNames: [Ri(e), a], size: "100%", posValue: [0, 0], sizeValue: x, zoom: g }, s), s.createElement("div", { className: Ri("size-value", "gap"), style: { transform: "translate" + m + "(-50%) scale(" + g + ")" } }, 0 < E ? v(E) : "")) } function Yr(M, i, w, D, C) { var R = M.props.isDisplayInnerSnapDigit, O = []; return ["vertical", "horizontal"].forEach(function (s) { var p, t, n, d, o, a, u, c, h, v, g, m, b, e = i.filter(function (t) { return t.type === s }), l = "vertical" === s ? 1 : 0, f = l ? 0 : 1, r = (t = e, d = R, v = "vertical" === (p = s) ? 1 : 0, m = (n = D)[(g = (h = "vertical" === p ? 0 : 1) ? ur : cr).start], b = n[g.end], a = function (t) { return t.pos[h] }, u = [], c = [], (o = t).forEach(function (t, n) { var e = a(t, n, o), r = c.indexOf(e), i = u[r] || []; -1 === r && (c.push(e), u.push(i)), i.push(t) }), u.map(function (t) { var l = [], f = []; return t.forEach(function (t) { var n, e, r, i, o, a, s, u = t.element, c = t.elementRect.rect; c[g.end] < m ? l.push(t) : b < c[g.start] ? f.push(t) : c[g.start] <= m && b <= c[g.end] && d && (r = t.pos, i = { element: u, rect: Ce(Ce({}, c), ((n = {})[g.end] = c[g.start], n)) }, o = { element: u, rect: Ce(Ce({}, c), ((e = {})[g.start] = c[g.end], e)) }, s = [0, 0], (a = [0, 0])[h] = r[h], a[v] = r[v], s[h] = r[h], s[v] = r[v] + t.size, l.push({ type: p, pos: a, size: 0, elementRect: i }), f.push({ type: p, pos: s, size: 0, elementRect: o })) }), l.sort(function (t, n) { return n.pos[v] - t.pos[v] }), f.sort(function (t, n) { return t.pos[v] - n.pos[v] }), { total: t, start: l, end: f, inner: [] } })), x = l ? cr : ur, E = l ? ur : cr, y = D[x.start], S = D[x.end]; r.forEach(function (t) { var n = t.total, e = t.start, r = t.end, i = t.inner, a = w[f] + n[0].pos[f] - D[E.start], o = D; e.forEach(function (t) { var n, e = t.elementRect.rect, r = o[x.start] - e[x.end]; 0 < r && ((n = [0, 0])[l] = w[l] + o[x.start] - y - r, n[f] = a, O.push(jr(M, s, "dashed", O.length, r, n, t.className, C))), o = e }), o = D, r.forEach(function (t) { var n, e = t.elementRect.rect, r = e[x.start] - o[x.end]; 0 < r && ((n = [0, 0])[l] = w[l] + o[x.end] - y, n[f] = a, O.push(jr(M, s, "dashed", O.length, r, n, t.className, C))), o = e }), i.forEach(function (t) { var n = t.elementRect.rect, e = y - n[x.start], r = n[x.end] - S, i = [0, 0], o = [0, 0]; i[l] = w[l] - e, i[f] = a, o[l] = w[l] + S - y, o[f] = a, O.push(jr(M, s, "dashed", O.length, e, i, t.className, C)), O.push(jr(M, s, "dashed", O.length, r, o, t.className, C)) }) }) }), O } function Xr(t, n, e, r, i) { var o = function (t, n, e, r) { var i = n[0] - t[0], o = n[1] - t[1]; if (Math.abs(i) < pt && (i = 0), Math.abs(o) < pt && (o = 0), !i) return r ? [0, 0] : [0, e]; if (!o) return r ? [e, 0] : [0, 0]; var a = o / i, s = t[1] - a * t[0]; return r ? [e, a * (n[0] + e) + s - n[1]] : [(n[1] + e - s) / a - n[0], e] }(t, n, e, r); if (!o) return { isOutside: !1, offset: [0, 0] }; var a = It(t, n), s = It(o, t), u = It(o, n), c = a < s || a < u, l = li({ datas: i, distX: o[0], distY: o[1] }); return { offset: [l[0], l[1]], isOutside: c } } function Wr(t, n) { return t.isBound ? t.offset : n.isSnap ? Er(n).offset : 0 } function qr(t, n, e, r, i, o) { if (!lr(t, "draggable")) return [{ isSnap: !1, isBound: !1, offset: 0 }, { isSnap: !1, isBound: !1, offset: 0 }]; var a, s, u, c, l, f, p, d, h, v, g, m, b, x, E, y, S, M, w, D = to(o.absolutePoses, [n, e]), C = Yi(D), R = C.left, O = C.right, P = C.top, _ = C.bottom, B = { horizontal: D.map(function (t) { return t[1] }), vertical: D.map(function (t) { return t[0] }) }, z = Lr(t, i, pr(fr(t.props.snapDirections), { left: R, right: O, top: P, bottom: _, center: (R + O) / 2, middle: (P + _) / 2 }), B), G = z.vertical, T = z.horizontal, k = _r(t, D, o), A = k.vertical, F = k.horizontal, I = G.isSnap, N = T.isSnap, j = G.isBound || A.isBound, Y = T.isBound || F.isBound, X = lo(G.offset, A.offset), W = lo(T.offset, F.offset), q = (a = r, u = [j, Y], c = [I, N], l = [X, W], v = (s = [n, e])[0], g = s[1], m = u[0], b = u[1], x = c[0], E = c[1], y = l[0], S = l[1], M = -y, w = -S, a && v && g ? (w = M = 0, f = [], m && b ? f.push([0, S], [y, 0]) : m ? f.push([y, 0]) : b ? f.push([0, S]) : x && E ? f.push([0, S], [y, 0]) : x ? f.push([y, 0]) : E && f.push([0, S]), f.length && (f.sort(function (t, n) { return qi(Jt([v, g], t)) - qi(Jt([v, g], n)) }), (p = f[0])[0] && Math.abs(v) > pt ? (M = -p[0], w = g * Math.abs(v + M) / Math.abs(v) - g) : p[1] && Math.abs(g) > pt && (d = g, w = -p[1], M = v * Math.abs(g + w) / Math.abs(d) - v), a && b && m && (Math.abs(M) > pt && Math.abs(M) < Math.abs(y) ? (M *= h = Math.abs(y) / Math.abs(M), w *= h) : Math.abs(w) > pt && Math.abs(w) < Math.abs(S) ? (M *= h = Math.abs(S) / Math.abs(w), w *= h) : (M = lo(-y, M), w = lo(-S, w))))) : (M = v || m ? -y : 0, w = g || b ? -S : 0), [M, w]); return [{ isBound: j, isSnap: I, offset: q[0] }, { isBound: Y, isSnap: N, offset: q[1] }] } function Lr(t, n, e, r) { void 0 === r && (r = e); var i = Gr(Tr(t), r.vertical, r.horizontal), o = i.horizontal, a = i.vertical, s = n ? { horizontal: { isSnap: !1, index: -1 }, vertical: { isSnap: !1, index: -1 } } : mr(t, e.vertical, e.horizontal), u = s.horizontal, c = s.vertical, l = Wr(o[0], u), f = Wr(a[0], c), p = Math.abs(l), d = Math.abs(f); return { horizontal: { isBound: o[0].isBound, isSnap: u.isSnap, snapIndex: u.index, offset: l, dist: p, bounds: o, snap: u }, vertical: { isBound: a[0].isBound, isSnap: c.isSnap, snapIndex: c.index, offset: f, dist: d, bounds: a, snap: c } } } function Hr(t, n, e, r, i) { var o = Gr(n, e, r), a = o.horizontal, s = o.vertical, u = br(t, e, r, i), c = u.horizontal, l = u.vertical, f = Wr(a[0], c), p = Wr(s[0], l), d = Math.abs(f), h = Math.abs(p); return { horizontal: { isBound: a[0].isBound, isSnap: c.isSnap, snapIndex: c.index, offset: f, dist: d, bounds: a, snap: c }, vertical: { isBound: s[0].isBound, isSnap: l.isSnap, snapIndex: l.index, offset: p, dist: h, bounds: s, snap: l } } } function Vr(L, H, t, V, U, $) { return t.map(function (t) { var n, e, r, i, o, a, s, u, c, l, f, p, d, h, v = t[0], g = t[1], m = di(H, v), b = di(H, g), x = V ? (i = U, o = function (t, n, e) { var r = Tr(t), i = r.left, o = r.top, a = r.right, s = r.bottom, u = e[0], c = e[1], l = Jt(e, n), f = l[0], p = l[1]; Math.abs(f) < Ie && (f = 0), Math.abs(p) < Ie && (p = 0); var d, h, v, g, m, b = 0 < p, x = 0 < f, E = { isBound: !1, offset: 0, pos: 0 }, y = { isBound: !1, offset: 0, pos: 0 }; return 0 === f && 0 === p || (0 === f ? b ? s < c && (y.pos = s, y.offset = c - s) : c < o && (y.pos = o, y.offset = c - o) : 0 === p ? x ? a < u && (E.pos = a, E.offset = u - a) : u < i && (E.pos = i, E.offset = u - i) : (d = p / f, h = e[1] - d * u, g = v = 0, m = !1, x && a <= u ? (v = d * a + h, g = a, m = !0) : !x && u <= i && (v = d * i + h, g = i, m = !0), m && (v < o || s < v) && (m = !1), m || (b && s <= c ? (g = ((v = s) - h) / d, m = !0) : !b && c <= o && (g = ((v = o) - h) / d, m = !0)), m && (E.isBound = !0, E.pos = g, E.offset = u - g, y.isBound = !0, y.pos = v, y.offset = c - v))), { vertical: E, horizontal: y } }(n = L, e = m, r = b), a = o.horizontal, s = o.vertical, u = i ? { horizontal: { isSnap: !1 }, vertical: { isSnap: !1 } } : function (t, n, e) { var r = e[0], i = e[1], o = n[0], a = n[1], s = Jt(e, n), u = s[0], c = 0 < (f = s[1]), l = 0 < u, u = go(u), f = go(f), p = { isSnap: !1, offset: 0, pos: 0 }, d = { isSnap: !1, offset: 0, pos: 0 }; if (0 === u && 0 === f) return { vertical: p, horizontal: d }; var h = mr(t, u ? [r] : [], f ? [i] : []), v = h.vertical, g = h.horizontal; v.posInfos.filter(function (t) { var n = t.pos; return l ? o <= n : n <= o }), g.posInfos.filter(function (t) { var n = t.pos; return c ? a <= n : n <= a }), v.isSnap = 0 < v.posInfos.length, g.isSnap = 0 < g.posInfos.length; var m, b, x, E, y, S = Er(v), M = S.isSnap, w = S.guideline, D = Er(g), C = D.isSnap, R = D.guideline, O = C ? R.pos[1] : 0, P = M ? w.pos[0] : 0; return 0 === u ? C && (d.isSnap = !0, d.pos = R.pos[1], d.offset = i - d.pos) : 0 === f ? M && (p.isSnap = !0, p.pos = P, p.offset = r - P) : (m = f / u, b = e[1] - m * r, E = x = 0, y = !1, M ? (x = m * (E = P) + b, y = !0) : C && (E = ((x = O) - b) / m, y = !0), y && (p.isSnap = !0, p.pos = E, p.offset = r - E, d.isSnap = !0, d.pos = x, d.offset = i - x)), { vertical: p, horizontal: d } }(n, e, r), c = u.horizontal, l = u.vertical, f = Ur(a, c), p = Ur(s, l), d = Math.abs(f), h = Math.abs(p), { horizontal: { isBound: a.isBound, isSnap: c.isSnap, offset: f, dist: d }, vertical: { isBound: s.isBound, isSnap: l.isSnap, offset: p, dist: h } }) : Lr(L, U, { vertical: [b[0]], horizontal: [b[1]] }), E = x.horizontal, y = E.offset, S = E.isBound, M = E.isSnap, w = x.vertical, D = w.offset, C = w.isBound, R = w.isSnap, O = Jt(g, v); if (!D && !y) return { isBound: C || S, isSnap: R || M, sign: O, offset: [0, 0] }; var P, _, B, z, G, T, k, A, F, I, N, j, Y, X = (P = x, _ = V, B = At(m, b) / Math.PI * 180, z = P.vertical, G = z.isBound, T = z.isSnap, k = z.dist, A = P.horizontal, F = A.isBound, I = A.isSnap, j = (N = B % 180) < 3 || 177 < N, Y = 87 < N && N < 93, A.dist < k && (G || T && !Y && (!_ || !j)) ? "vertical" : !F && (!I || j || _ && Y) ? "" : "horizontal"); if (!X) return { sign: O, isBound: !1, isSnap: !1, offset: [0, 0] }; var W = "vertical" == X, q = Xr(m, b, -(W ? D : y), W, $).offset.map(function (t, n) { return t * (O[n] ? 2 / O[n] : 0) }); return { sign: O, isBound: W ? C : S, isSnap: W ? R : M, offset: q } }) } function Ur(t, n) { return t.isBound ? t.offset : n.isSnap ? n.offset : 0 } function $r(t) { var n, e, r, i, o, a, s, u, c = t.state; c.guidelines && c.guidelines.length || (n = t.state.container, e = t.props.snapContainer || n, r = c.containerClientRect, i = { left: 0, top: 0, bottom: 0, right: 0 }, n === e || (o = xo(e, !0)) && (s = yo(c, [(a = Ji(o)).left - r.left, a.top - r.top]), u = yo(c, [a.right - r.right, a.bottom - r.bottom]), i.left = Nt(s[0], .1), i.top = Nt(s[1], .1), i.right = Nt(u[0], .1), i.bottom = Nt(u[1], .1)), c.snapOffset = i, c.guidelines = gr(t), c.enableSnap = !0) } function Zr(t, n, e, r, i, o) { var a = ji(t, n, e, o ? 4 : 3); return to(a, Jt(i, di(a, r))) } function Kr(t, n, e, r, i, o) { var a, s, u, c = o.fixedDirection, l = (a = e, s = c, u = [], r ? (1 !== Math.abs(s[0]) || 1 !== Math.abs(s[1]) ? u.push([s, [-1, -1]], [s, [-1, 1]], [s, [1, -1]], [s, [1, 1]]) : u.push([s, [a[0], -a[1]]], [s, [-a[0], a[1]]], [s, a]), u.push([s, a])) : a[0] && a[1] ? u.push([s, [a[0], -a[1]]], [s, [-a[0], a[1]]]) : a[0] ? (1 === Math.abs(s[0]) ? [1] : [1, -1]).forEach(function (t) { u.push([[s[0], -1], [t * a[0], -1]], [[s[0], 0], [t * a[0], 0]], [[s[0], 1], [t * a[0], 1]]) }) : a[1] ? (1 === Math.abs(s[1]) ? [1] : [1, -1]).forEach(function (t) { u.push([[-1, s[1]], [-1, t * a[1]]], [[0, s[1]], [0, t * a[1]]], [[1, s[1]], [1, t * a[1]]]) }) : u.push([s, [1, 0]], [s, [-1, 0]], [s, [0, -1]], [s, [0, 1]], [[1, 0], [1, -1]], [[1, 0], [1, 1]], [[0, 1], [1, 1]], [[0, 1], [-1, 1]], [[-1, 0], [-1, -1]], [[-1, 0], [-1, 1]], [[0, -1], [1, -1]], [[0, -1], [-1, -1]]), u), f = Br(n, e, r), p = Re(Re([], Vr(t, n, l, r, i, o)), Pr(t, f, di(n, [0, 0]), o)), d = Mr(p, 0), h = Mr(p, 1); return { width: { isBound: d.isBound, offset: d.offset[0] }, height: { isBound: h.isBound, offset: h.offset[1] } } } function Jr(t, n, e, r, i, o, a, s) { for (var u, c, l, f, p, d, h, v, g, m, b, x, E, y, S, M, w, D, C, R, O, P, _, B, z, G = no(t.state), T = t.props.keepRatio, k = 0, A = 0, F = 0; F < 2; ++F) { var I, N, j = Kr(t, n(k, A), i, T, a, s), Y = j.width, X = j.height, W = Y.isBound, q = X.isBound, L = Y.offset, H = X.offset; if (1 === F && (W || (L = 0), q || (H = 0)), 0 === F && a && !W && !q) return [0, 0]; T && (I = Math.abs(L) * (e ? 1 / e : 1), N = Math.abs(H) * (r ? 1 / r : 1), (W && q ? I < N : q || !W && I < N) ? L = e * H / r : H = r * L / e), k += L, A += H } return i[0] && i[1] && (p = t, d = G, v = o, g = s, C = [-(h = i)[0], -h[1]], R = p.state, O = R.width, P = R.height, _ = p.props.bounds, z = B = 1 / 0, _ && (m = [[h[0], -h[1]], [-h[0], h[1]]], b = _.left, x = void 0 === b ? -1 / 0 : b, E = _.top, y = void 0 === E ? -1 / 0 : E, S = _.right, M = void 0 === S ? 1 / 0 : S, w = _.bottom, D = void 0 === w ? 1 / 0 : w, m.forEach(function (t) { var n, e, r, i, o, a, s, u = t[0] !== C[0], c = t[1] !== C[1], l = di(d, t), f = 360 * At(v, l) / Math.PI; c && (i = l.slice(), (Math.abs(f - 360) < 2 || Math.abs(f - 180) < 2) && (i[1] = v[1]), e = (n = Xr(v, i, (v[1] < l[1] ? D : y) - l[1], !1, g)).offset[1], r = n.isOutside, isNaN(e) || (z = P + (r ? 1 : -1) * Math.abs(e))), u && (i = l.slice(), (Math.abs(f - 90) < 2 || Math.abs(f - 270) < 2) && (i[0] = v[0]), a = (o = Xr(v, i, (v[0] < l[0] ? M : x) - l[0], !0, g)).offset[0], s = o.isOutside, isNaN(a) || (B = O + (s ? 1 : -1) * Math.abs(a))) })), c = (u = { maxWidth: B, maxHeight: z }).maxWidth, l = u.maxHeight, k += L = (f = function (t, n, e, r, i, o, a, s, u) { var c = di(n, a), l = Lr(t, s, { vertical: [c[0]], horizontal: [c[1]] }), f = l.horizontal.offset, p = l.vertical.offset; if (p || f) { var d = li({ datas: u, distX: -p, distY: -f }), h = d[0], v = d[1]; return [Math.min(i || 1 / 0, e + a[0] * h) - e, Math.min(o || 1 / 0, r + a[1] * v) - r] } return [0, 0] }(t, n(k, A).map(function (t) { return t.map(function (t) { return Nt(t, Fe) }) }), e + k, r + A, c, l, i, a, s))[0], A += H = f[1]), [k, A] } function Qr(t, c, n, e, l) { if (!lr(t, "scalable")) return [0, 0]; var f = l.startOffsetWidth, p = l.startOffsetHeight, d = l.fixedPosition, h = l.fixedDirection, v = l.is3d, r = Jr(t, function (t, n) { return Zr((e = l, r = Kt(c, [t / f, n / p]), i = e.transformOrigin, o = e.offsetMatrix, a = e.is3d, s = e.targetMatrix, hi(o, Zt(s, fn(r, u = a ? 4 : 3), u), i, u)), f, p, h, d, v); var e, r, i, o, a, s, u }, f, p, n, d, e, l); return [r[0] / f, r[1] / p] } function ti(t) { var e = []; return t.forEach(function (t) { t.guidelineInfos.forEach(function (t) { var n = t.guideline; -1 < e.indexOf(n) || e.push(n) }) }), e } function ni(t, n, e, i, o, r) { var a = Gr(Tr(t, r), n, e), s = a.vertical, u = a.horizontal; s.forEach(function (t) { t.isBound && i.push({ type: "bounds", pos: t.pos }) }), u.forEach(function (t) { t.isBound && o.push({ type: "bounds", pos: t.pos }) }); var c = function (t) { var n = t.props.innerBounds; if (!n) return { vertical: [], horizontal: [] }; var e = t.getRect(), r = e.pos1, i = e.pos2, o = e.pos3, a = e.pos4, u = di([r, i, o, a], [0, 0]), c = n.left, l = n.top, f = n.width, p = n.height, d = [[c, l], [c, l + p]], h = [[c, l], [c + f, l]], v = [[c + f, l], [c + f, l + p]], g = [[c, l + p], [c + f, l + p]], m = [], b = [], x = { top: !1, bottom: !1, left: !1, right: !1 }; return [[r, i], [i, a], [a, o], [o, r]].forEach(function (t) { var n = wr(u, t), e = n.horizontal, r = n.vertical, i = Or(t, h, r, 1, !0), o = Or(t, g, r, 1, !0), a = Or(t, d, e, 1, !0), s = Or(t, v, e, 1, !0); i.isBound && !x.top && (m.push(l), x.top = !0), o.isBound && !x.bottom && (m.push(l + p), x.bottom = !0), a.isBound && !x.left && (b.push(c), x.left = !0), s.isBound && !x.right && (b.push(c + f), x.right = !0) }), { horizontal: m, vertical: b } }(t), l = c.vertical, f = c.horizontal; l.forEach(function (r) { 0 <= Rt(i, function (t) { var n = t.type, e = t.pos; return "bounds" === n && e === r }) || i.push({ type: "bounds", pos: r }) }), f.forEach(function (r) { 0 <= Rt(o, function (t) { var n = t.type, e = t.pos; return "bounds" === n && e === r }) || o.push({ type: "bounds", pos: r }) }) } var ei = { name: "snappable", dragRelation: "strong", props: { snappable: [Boolean, Array], snapContainer: Object, snapDirections: [Boolean, Object], elementSnapDirections: [Boolean, Object], snapGap: Boolean, snapGridWidth: Number, snapGridHeight: Number, isDisplaySnapDigit: Boolean, isDisplayInnerSnapDigit: Boolean, snapDigit: Number, snapThreshold: Number, horizontalGuidelines: Array, verticalGuidelines: Array, elementGuidelines: Array, bounds: Object, innerBounds: Object, snapDistFormat: Function }, events: { onSnap: "snap" }, css: [":host {\n    --bounds-color: #d66;\n}\n.guideline {\n    pointer-events: none;\n    z-index: 2;\n}\n.guideline.bounds {\n    background: #d66;\n    background: var(--bounds-color);\n}\n.guideline-group {\n    position: absolute;\n    top: 0;\n    left: 0;\n}\n.guideline-group .size-value {\n    position: absolute;\n    color: #f55;\n    font-size: 12px;\n    font-weight: bold;\n}\n.guideline-group.horizontal .size-value {\n    transform-origin: 50% 100%;\n    transform: translateX(-50%);\n    left: 50%;\n    bottom: 5px;\n}\n.guideline-group.vertical .size-value {\n    transform-origin: 0% 50%;\n    top: 50%;\n    transform: translateY(-50%);\n    left: 5px;\n}\n.guideline.gap {\n    background: #f55;\n}\n.size-value.gap {\n    color: #f55;\n}\n"], render: function (t, n) { var e = t.state, r = e.top, i = e.left, o = e.pos1, a = e.pos2, s = e.pos3, u = e.pos4, c = e.snapRenderInfo; if (!c || !lr(t, "")) return []; e.guidelines = gr(t); var l, f = Math.min(o[0], a[0], s[0], u[0]), p = Math.min(o[1], a[1], s[1], u[1]), d = c.externalPoses || [], h = no(t.state), v = [], g = [], m = [], b = [], x = [], E = Yi(h), y = E.width, S = E.height, M = E.top, w = E.left, D = E.bottom, C = E.right, R = { left: w, right: C, top: M, bottom: D, center: (w + C) / 2, middle: (M + D) / 2 }, O = 0 < d.length, P = O ? Yi(d) : {}; c.request || (c.direction && x.push(function (t, n, e) { var r = []; if (e[0] && e[1]) r = [e, [-e[0], e[1]], [e[0], -e[1]]].map(function (t) { return di(n, t) }); else if (e[0] || e[1]) t.props.keepRatio ? r = [[-1, -1], [-1, 1], [1, -1], [1, 1], e].map(function (t) { return di(n, t) }) : 1 < (r = pi(n, e)).length && r.push([(r[0][0] + r[1][0]) / 2, (r[0][1] + r[1][1]) / 2]); else for (var i = [n[0], n[1], n[3], n[2], n[0]], o = 0; o < 4; ++o)r.push(i[o]), r.push([(i[o][0] + i[o + 1][0]) / 2, (i[o][1] + i[o + 1][1]) / 2]); return mr(t, r.map(function (t) { return t[0] }), r.map(function (t) { return t[1] }), 1) }(t, h, c.direction)), c.snap && (l = Yi(h), c.center && (l.middle = (l.top + l.bottom) / 2, l.center = (l.left + l.right) / 2), x.push(xr(t, l, 1))), O && (c.center && (P.middle = (P.top + P.bottom) / 2, P.center = (P.left + P.right) / 2), x.push(xr(t, P, 1))), x.forEach(function (t) { var n = t.vertical.posInfos, e = t.horizontal.posInfos; v.push.apply(v, n.filter(function (t) { return t.guidelineInfos.some(function (t) { return !t.guideline.hide }) }).map(function (t) { return { type: "snap", pos: t.pos } })), g.push.apply(g, e.filter(function (t) { return t.guidelineInfos.some(function (t) { return !t.guideline.hide }) }).map(function (t) { return { type: "snap", pos: t.pos } })), m.push.apply(m, ti(n)), b.push.apply(b, ti(e)) })), ni(t, [w, C], [M, D], v, g), O && ni(t, [P.left, P.right], [P.top, P.bottom], v, g, c.externalBounds); var _, B, z, G, T, k, A = Re(Re([], m), b), F = A.filter(function (t) { return t.element && !t.gapRects }), I = A.filter(function (t) { return t.gapRects }); return ao(t, "onSnap", { guidelines: A.filter(function (t) { return !t.element }), elements: F, gaps: I }, !0), Re(Re(Re(Re(Re(Re([], Yr(t, F, [f, p], R, n)), (_ = t, B = I, z = [f, p], G = R, T = n, k = [], ["horizontal", "vertical"].forEach(function (n) { var t = B.filter(function (t) { return t.type === n }), s = "vertical" === n ? 0 : 1, u = s ? 0 : 1, c = s ? cr : ur, l = s ? ur : cr, f = G[c.start], p = G[c.end], d = G[l.start], h = G[l.end]; t.forEach(function (t) { var r = t.gap, n = t.gapRects, i = t.className, e = Math.max.apply(Math, Re([d], n.map(function (t) { return t.rect[l.start] }))), o = Math.min.apply(Math, Re([h], n.map(function (t) { return t.rect[l.end] }))), a = (e + o) / 2; e !== o && a != (d + h) / 2 && n.forEach(function (t) { var n = t.rect, e = [z[0], z[1]]; if (n[c.end] < f) e[s] += n[c.end] - f; else { if (!(p < n[c.start])) return; e[s] += n[c.start] - f - r } e[u] += a - d, k.push(jr(_, s ? "vertical" : "horizontal", "gap", k.length, r, e, i, T)) }) }) }), k)), Nr(t, "horizontal", b, [i, r], R, n)), Nr(t, "vertical", m, [i, r], R, n)), Ir(t, "horizontal", g, f, r, y, 0, n)), Ir(t, "vertical", v, p, i, S, 1, n)) }, dragStart: function (t, n) { t.state.snapRenderInfo = { request: n.isRequest, snap: !0, center: !0 }, $r(t) }, drag: function (t) { t.state.guidelines = gr(t) }, pinchStart: function (t) { this.unset(t) }, dragEnd: function (t) { this.unset(t) }, dragControlCondition: function (t, n) { return !(!mo(0, n) && !ir(t, n)) || (!n.isRequest && n.inputEvent ? Yt(n.inputEvent.target, Ri("snap-control")) : void 0) }, dragControlStart: function (t) { t.state.snapRenderInfo = null, $r(t) }, dragControl: function (t) { this.drag(t) }, dragControlEnd: function (t) { this.unset(t) }, dragGroupStart: function (t, n) { this.dragStart(t, n) }, dragGroup: function (t) { this.drag(t) }, dragGroupEnd: function (t) { this.unset(t) }, dragGroupControlStart: function (t) { t.state.snapRenderInfo = null, $r(t) }, dragGroupControl: function (t) { this.drag(t) }, dragGroupControlEnd: function (t) { this.unset(t) }, unset: function (t) { var n = t.state; n.enableSnap = !1, n.guidelines = [], n.snapRenderInfo = null, n.elementRects = [] } }, ri = { name: "draggable", props: { draggable: Boolean, throttleDrag: Number, throttleDragRotate: Number, startDragRotate: Number, edgeDraggable: Boolean }, events: { onDragStart: "dragStart", onDrag: "drag", onDragEnd: "dragEnd", onDragGroupStart: "dragGroupStart", onDragGroup: "dragGroup", onDragGroupEnd: "dragGroupEnd" }, render: function (t, n) { var e = t.props, r = e.throttleDragRotate, i = e.zoom, o = t.state, a = o.dragInfo, s = o.beforeOrigin; if (!r || !a) return []; var u = a.dist; if (!u[0] && !u[1]) return []; var c = qi(u), l = At(u, [0, 0]); return [n.createElement("div", { className: Ri("line", "horizontal", "dragline", "dashed"), key: "dragRotateGuideline", style: { width: c + "px", transform: "translate(" + s[0] + "px, " + s[1] + "px) rotate(" + l + "rad) scaleY(" + i + ")" } })] }, dragStart: function (t, n) { var e = n.datas, r = n.parentEvent, i = n.parentGesto, o = t.state, a = o.target; if (o.gesto) return !1; o.gesto = i || t.targetGesto; var s, u = so(a); e.datas = {}, e.left = parseFloat(u.left || "") || 0, e.top = parseFloat(u.top || "") || 0, e.bottom = parseFloat(u.bottom || "") || 0, e.right = parseFloat(u.right || "") || 0, e.startValue = [0, 0], oi(t, n), mi(n, "translate"), s = t, e.absolutePoses = no(s.state), e.prevDist = [0, 0], e.prevBeforeDist = [0, 0], e.isDrag = !1, e.deltaOffset = [0, 0], e.distOffset = [0, 0]; var c = ro(t, n, Ce({ set: function (t) { e.startValue = t } }, gi(n))); return !1 !== (r || ao(t, "onDragStart", c)) ? (e.isDrag = !0, t.state.dragInfo = { startRect: t.getRect(), dist: [0, 0] }) : (o.gesto = null, e.isPinch = !1), !!e.isDrag && c }, drag: function (t, n) { if (n) { ai(n, "translate"); var e = n.datas, r = n.parentEvent, i = n.parentFlag, o = n.isPinch, a = n.isRequest, s = n.distX, u = n.distY, c = e.isDrag, l = e.prevDist, f = e.prevBeforeDist, p = e.startValue, d = e.distOffset; if (c) { s += d[0], u += d[1]; var h, v, g, m, b, x, E, y, S, M, w, D, C = t.props, R = C.parentMoveable, O = !r && C.throttleDrag || 0, P = !r && C.throttleDragRotate || 0, _ = !1, B = 0; !r && 0 < P && (s || u) && (v = Nt((h = C.startDragRotate || 0) + 180 * At([0, 0], [s, u]) / Math.PI, P) - h, g = u * Math.abs(Math.cos((v - 90) / 180 * Math.PI)), m = qi([s * Math.abs(Math.cos(v / 180 * Math.PI)), g]), B = v * Math.PI / 180, s = m * Math.cos(B), u = m * Math.sin(B)), o || r || i || P && !s && !u || (x = (b = qr(t, s, u, P, a, e))[0], E = b[1], y = x.isSnap, S = x.isBound, M = x.offset, w = E.isSnap, D = E.isBound, _ = y || w || S || D, s += M, u += E.offset); var z, G, T, k, A, F, I, N = Kt(ci({ datas: e, distX: s, distY: u }), p), j = Kt((G = (z = { datas: e, distX: s, distY: u }).datas, T = z.distX, k = z.distY, A = ci({ datas: G, distX: T, distY: k }), F = A[0], I = A[1], tn(ui(G, function (t, n) { for (var e = ln(n), r = 0; r < n - 1; ++r)e[n * (n - 1) + r] = t[r] || 0; return e }([F, I], 4)), Vt([0, 0, 0], 4), 4)), p); P || _ || (jt(j, O), jt(N, O)); var Y = Jt(N, p), X = Jt(j, p), W = Jt(X, l), q = Jt(Y, f); e.prevDist = X, e.prevBeforeDist = Y, e.passDelta = W, e.passDist = X; var L = e.left + Y[0], H = e.top + Y[1], V = e.right - Y[0], U = e.bottom - Y[1], $ = si(e, "translate(" + j[0] + "px, " + j[1] + "px)", "translate(" + X[0] + "px, " + X[1] + "px)"); if (xi(n, $), t.state.dragInfo.dist = r ? [0, 0] : X, r || R || !W.every(function (t) { return !t }) || !q.some(function (t) { return !t })) { var Z = t.state, K = ro(t, n, { transform: $, dist: X, delta: W, translate: j, beforeDist: Y, beforeDelta: q, beforeTranslate: N, left: L, top: H, right: V, bottom: U, width: Z.width, height: Z.height, isPinch: o }); return r || ao(t, "onDrag", K), K } } } }, dragAfter: function (t, n) { var e = n.datas, r = n.datas, i = r.deltaOffset, o = r.distOffset; return !(!i[0] && !i[1]) && (e.deltaOffset = [0, 0], o[0] = i[0], o[1] = i[1], this.drag(t, n)) }, dragEnd: function (t, n) { var e = n.parentEvent, r = n.datas; if (t.state.gesto = null, t.state.dragInfo = null, r.isDrag) { r.isDrag = !1; var i = io(t, n, {}); return e || ao(t, "onDragEnd", i), i } }, dragGroupStart: function (t, n) { var e = n.datas, r = n.clientX, i = n.clientY, o = this.dragStart(t, n); if (!o) return !1; var a = Ue(t, this, "dragStart", [r || 0, i || 0], n, !1), s = ao(t, "onDragGroupStart", Ce(Ce({}, o), { targets: t.props.targets, events: a })); return e.isDrag = !1 !== s, !!e.isDrag && o }, dragGroup: function (t, n) { if (n.datas.isDrag) { var e = this.drag(t, n), r = Ue(t, this, "drag", n.datas.passDelta, n, !1); if (e) { var i = Ce({ targets: t.props.targets, events: r }, e); return ao(t, "onDragGroup", i), i } } }, dragGroupEnd: function (t, n) { var e = n.isDrag; if (n.datas.isDrag) { this.dragEnd(t, n); var r = Ue(t, this, "dragEnd", [0, 0], n, !1); return ao(t, "onDragGroupEnd", io(t, n, { targets: t.props.targets, events: r })), e } }, request: function (t) { var n = {}, e = t.getRect(), r = 0, i = 0; return { isControl: !1, requestStart: function () { return { datas: n } }, request: function (t) { return "x" in t ? r = t.x - e.left : "deltaX" in t && (r += t.deltaX), "y" in t ? i = t.y - e.top : "deltaY" in t && (i += t.deltaY), { datas: n, distX: r, distY: i } }, requestEnd: function () { return { datas: n, isDrag: !0 } } } }, unset: function (t) { t.state.dragInfo = null } }; function ii(t, n) { var e = n.clientX, r = n.clientY, i = n.datas, o = t.state, a = o.moveableClientRect, s = o.rootMatrix, u = o.is3d, c = o.pos1, l = Jt(fo(s, [e - a.left, r - a.top], u ? 4 : 3), c), f = li({ datas: i, distX: l[0], distY: l[1] }); return [f[0], f[1]] } function oi(t, n) { var e = n.datas, r = t.state, i = r.allMatrix, o = r.beforeMatrix, a = r.is3d, s = r.left, u = r.top, c = r.origin, l = r.offsetMatrix, f = r.targetMatrix, p = r.transformOrigin, d = a ? 4 : 3; e.is3d = a, e.matrix = i, e.targetMatrix = f, e.beforeMatrix = o, e.offsetMatrix = l, e.transformOrigin = p, e.inverseMatrix = Ht(i, d), e.inverseBeforeMatrix = Ht(o, d), e.absoluteOrigin = Vt(Kt([s, u], c), d), e.startDragBeforeDist = tn(e.inverseBeforeMatrix, e.absoluteOrigin, d), e.startDragDist = tn(e.inverseMatrix, e.absoluteOrigin, d) } function ai(t, n) { var e = t.datas, r = t.originalDatas.beforeRenderable, i = e.transformIndex, o = r.nextTransforms, a = r.nextTransformAppendedIndexes, s = 0; -1 === i ? (s = o.length, e.transformIndex = s) : s = i + a.filter(function (t) { return t < i }).length; var u, c, l, f, p, d, h, v, g, m, b, x, E, y, S, M, w, D = (c = s, l = (u = o).slice(0, c < 0 ? void 0 : c), f = u.slice(0, c < 0 ? void 0 : c + 1), p = u[c] || "", d = c < 0 ? [] : u.slice(c), h = c < 0 ? [] : u.slice(c + 1), v = Sn(l), g = Sn(f), m = Sn([p]), b = Sn(d), x = Sn(h), E = yn(v), y = yn(g), S = yn(b), M = yn(x), w = Zt(E, S, 4), { transforms: u, beforeFunctionMatrix: E, beforeFunctionMatrix2: y, targetFunctionMatrix: yn(m), afterFunctionMatrix: S, afterFunctionMatrix2: M, allFunctionMatrix: w, beforeFunctions: v, beforeFunctions2: g, targetFunction: m[0], afterFunctions: b, afterFunctions2: x, beforeFunctionTexts: l, beforeFunctionTexts2: f, targetFunctionText: p, afterFunctionTexts: d, afterFunctionTexts2: h }), C = D.targetFunction, R = "rotate" === n ? "rotateZ" : n; e.beforeFunctionTexts = D.beforeFunctionTexts, e.afterFunctionTexts = D.afterFunctionTexts, e.beforeTransform = D.beforeFunctionMatrix, e.beforeTransform2 = D.beforeFunctionMatrix2, e.targetTansform = D.targetFunctionMatrix, e.afterTransform = D.afterFunctionMatrix, e.afterTransform2 = D.afterFunctionMatrix2, e.targetAllTransform = D.allFunctionMatrix, C.functionName === R ? (e.afterFunctionTexts.splice(0, 1), e.isAppendTransform = !1) : (e.isAppendTransform = !0, r.nextTransformAppendedIndexes = Re(Re([], a), [s])) } function si(t, n, e) { return t.beforeFunctionTexts.join(" ") + " " + (t.isAppendTransform ? e : n) + " " + t.afterFunctionTexts.join(" ") } function ui(t, n, e) { var r = t.beforeTransform, i = t.afterTransform, o = t.beforeTransform2, a = t.afterTransform2, s = t.targetAllTransform, u = e ? Zt(s, n, 4) : Zt(n, s, 4), c = Zt(Ht(e ? o : r, 4), u, 4); return Zt(c, Ht(e ? a : i, 4), 4) } function ci(t) { var n = t.datas, e = t.distX, r = t.distY, i = n.inverseBeforeMatrix, o = n.is3d, a = n.startDragBeforeDist, s = o ? 4 : 3; return Jt(tn(i, Kt(n.absoluteOrigin, [e, r]), s), a) } function li(t, n) { var e = t.datas, r = t.distX, i = t.distY, o = e.inverseBeforeMatrix, a = e.inverseMatrix, s = e.is3d, u = e.startDragBeforeDist, c = e.startDragDist, l = s ? 4 : 3; return Jt(tn(n ? o : a, Kt(e.absoluteOrigin, [r, i]), l), n ? u : c) } function fi(t) { var n = []; return 0 <= t[1] && (0 <= t[0] && n.push(3), t[0] <= 0 && n.push(2)), t[1] <= 0 && (0 <= t[0] && n.push(1), t[0] <= 0 && n.push(0)), n } function pi(n, t) { return fi(t).map(function (t) { return n[t] }) } function di(t, n) { var e = pi(t, n); return [kt(e.map(function (t) { return t[0] })), kt(e.map(function (t) { return t[1] }))] } function hi(t, n, e, r) { return Zt(t, Oi(n, r, e), r) } function vi(t, n, e) { var r = t.transformOrigin, i = t.offsetMatrix, o = t.is3d, a = n.beforeTransform, s = n.afterTransform, u = o ? 4 : 3; return hi(i, Ut(Zt(Zt(a, yn(Sn([e])), 4), s, 4), 4, u), r, u) } function gi(e) { var r = e.originalDatas.beforeRenderable; return { setTransform: function (t, n) { void 0 === n && (n = -1), r.startTransforms = gt(t) ? t : St(t), bi(e, n) }, setTransformIndex: function (t) { bi(e, t) } } } function mi(t, n) { bi(t, Rt(t.originalDatas.beforeRenderable.startTransforms, function (t) { return 0 === t.indexOf(n + "(") })) } function bi(t, n) { var e, r, i = t.originalDatas.beforeRenderable, o = t.datas; -1 === (o.transformIndex = n) || (e = i.startTransforms[n]) && (r = Sn([e]), o.startValue = r[0].functionValue) } function xi(t, n) { t.originalDatas.beforeRenderable.nextTransforms = St(n) } function Ei(t) { return t.originalDatas.beforeRenderable.nextTransforms.join(" ") } function yi(t, n, e, r, i) { return xi(i, n), { transform: n, drag: ri.drag(t, Le(i, t.state, e, r, !1)) } } function Si(t, n, e, r, i) { var o = t.state, a = o.left, s = o.top, u = t.props.groupable, c = u ? a : 0, l = u ? s : 0, f = Jt(r, wi(t, e, vi(t.state, i, n))); return Jt(f, [c, l]) } function Mi(t) { var n = t.state, e = n.width, r = n.height, i = n.transformOrigin; return [i[0] / (e / 2) - 1, i[1] / (r / 2) - 1] } function wi(t, n, e) { void 0 === e && (e = t.state.allMatrix); var r = t.state, i = r.width, o = r.height, a = r.is3d ? 4 : 3; return Ni(e, [i / 2 * (1 + n[0]), o / 2 * (1 + n[1])], a) } function Di(t, n, e, r, i, o) { var a, s, u, c, l, f, p, d, h, v = t.props.groupable, g = t.state, m = g.transformOrigin, b = g.targetMatrix, x = g.offsetMatrix, E = g.is3d, y = g.width, S = g.height, M = g.left, w = g.top, D = E ? 4 : 3, C = v ? M : 0, R = v ? w : 0, O = hi(x, b, (s = n, u = e, void 0 === (c = y) && (c = s), void 0 === (l = S) && (l = u), void 0 === (f = m) && (f = [0, 0]), (a = o) ? a.map(function (t, n) { var e = Dt(t), r = e.value, i = e.unit, o = n ? l : c, a = n ? u : s; return "%" === t || isNaN(r) ? a * (o ? f[n] / o : 0) : "%" !== i ? r : a * r / 100 }) : f), D); return Jt((p = i, d = r, h = di(ji(O, n, e, D), d), [p[0] - h[0], p[1] - h[1]]), [C, R]) } function Ci(t, n) { return di(no(t.state), n) } function Ri() { for (var t = [], n = 0; n < arguments.length; n++)t[n] = arguments[n]; return function (n) { for (var t = [], e = 1; e < arguments.length; e++)t[e - 1] = arguments[e]; return t.map(function (t) { return t.split(" ").map(function (t) { return t ? "" + n + t : "" }).join(" ") }).join(" ") }.apply(void 0, Re([Te], t)) } function Oi(t, n, e) { return $t(n, pn(e, n), t, pn(e.map(function (t) { return -t }), n)) } function Pi(s) { return _i(so(s, ":before")).map(function (t, n) { var e, r, i = Dt(t), o = i.value, a = i.unit; return o * (e = s, r = 0 === n, "%" !== a ? 1 : Ii(e.ownerSVGElement)[r ? "width" : "height"] / 100) }) } function _i(t) { var n = t.transformOrigin; return n ? n.split(" ") : ["0", "0"] } function Bi(t, n, e) { for (var r = document.body, i = !t || e ? t : t.parentElement, o = t === n || i === n, a = "relative"; i && i !== r;) { n === i && (o = !0); var s = so(i), u = s.transform, a = s.position; if ("svg" === i.tagName.toLowerCase() || "static" !== a || u && "none" !== u) break; i = i.parentElement, a = "relative" } return { isStatic: "static" === a, isEnd: o || !i || i === r, offsetParent: i || r } } function zi(t, n, e, r) { var i, o, a = t.tagName.toLowerCase(), s = t.offsetLeft, u = t.offsetTop; r && (s -= (o = (n || document.documentElement).getBoundingClientRect()).left, u -= o.top); var c, l, f = ht(s), p = !f; return p || "svg" === a ? l = (c = _i(e).map(function (t) { return parseFloat(t) })).slice() : (l = (c = Ge ? Pi(t) : _i(e).map(function (t) { return parseFloat(t) })).slice(), p = !0, s = (i = function (t, n) { if (!t.getBBox) return [0, 0]; var e = t.getBBox(), r = Ii(t.ownerSVGElement), i = e.x - r.x, o = e.y - r.y; return [i, o, n[0] - i, n[1] - o] }(t, c))[0], u = i[1], c[0] = i[2], c[1] = i[3]), { tagName: a, isSVG: f, hasOffset: p, offset: [s || 0, u || 0], origin: c, targetOrigin: l } } function Gi(t, n, e) { void 0 === e && (e = so(t)); var r = so(document.body), i = r.position; if (!(n || i && "static" !== i)) return [0, 0]; var o = parseInt(r.marginLeft, 10), a = parseInt(r.marginTop, 10); return "absolute" === e.position && ("auto" === e.top && "auto" === e.bottom || (a = 0), "auto" === e.left && "auto" === e.right || (o = 0)), [o, a] } function Ti(t) { t.forEach(function (t) { var n = t.matrix; n && (t.matrix = Ut(n, 3, 4)) }) } function ki(t, n, e) { for (var r, i, o, a, s, u, c = t, l = [], f = !e && t === n, p = f, d = !1, h = 3, v = Bi(n, n, !0).offsetParent; c && !p;) { p = f; var g = so(c), m = g.position, b = "fixed" === m, x = (u = g.transform, a = u && "none" !== u ? vt(u) ? u : wt(u).value.split(/s*,\s*/g).map(function (t) { return parseFloat(t) }) : [1, 0, 0, 1, 0, 0], (s = void 0) === s && (s = 6 === a.length), s ? [a[0], a[1], 0, a[2], a[3], 0, a[4], a[5], 1] : a), E = x.length; d || 16 !== E || (d = !0, h = 4, Ti(l), o = o && Ut(o, 3, 4)), d && 9 === E && (x = Ut(x, 3, 4)); var y = zi(c, n, g, b), S = y.tagName, M = y.hasOffset, w = y.isSVG, D = y.origin, C = y.targetOrigin, R = y.offset, O = R[0], P = R[1]; "svg" === S && o ? (l.push({ type: "target", target: c, matrix: function (t, n) { var e = Ii(t), r = e.width, i = e.height, o = e.clientWidth, a = e.clientHeight, s = o / r, u = a / i, c = t.preserveAspectRatio.baseVal, l = c.align, f = c.meetOrSlice, p = [0, 0], d = [s, u], h = [0, 0]; { var v, g, m; 1 !== l && (v = (l - 2) % 3, g = Math.floor((l - 2) / 3), p[0] = r * v / 2, p[1] = i * g / 2, m = 2 === f ? Math.max(u, s) : Math.min(s, u), d[0] = m, d[1] = m, h[0] = (o - r) / 2 * v, h[1] = (a - i) / 2 * g) } var b = fn(d, n); return b[n * (n - 1)] = h[0], b[n * (n - 1) + 1] = h[1], Oi(b, n, p) }(c, h) }), l.push({ type: "offset", target: c, matrix: ln(h) })) : "g" === S && t !== c && (P = O = 0); var _ = Bi(c, n), B = _.offsetParent, z = _.isEnd, G = _.isStatic; ze && M && !w && G && ("relative" === m || "static" === m) && (O -= B.offsetLeft, P -= B.offsetTop, f = f || z); var T, k = 0, A = 0; if (M && v !== B && (k = B.clientLeft, A = B.clientTop), M && B === document.body && (O += (T = Gi(c, !1, g))[0], P += T[1]), l.push({ type: "target", target: c, matrix: Oi(x, h, D) }), M ? l.push({ type: "offset", target: c, matrix: pn([O - c.scrollLeft + k, P - c.scrollTop + A], h) }) : l.push({ type: "offset", target: c, origin: D }), o = o || x, r = r || D, i = i || C, p || b) break; c = B, f = z, e && c !== document.body || (p = f) } return { offsetContainer: v, matrixes: l, targetMatrix: o = o || ln(h), transformOrigin: r = r || [0, 0], targetOrigin: i = i || [0, 0], is3d: d } } function Ai(t, n, e, r) { void 0 === e && (e = n); var i, o, a, s, u = 0, c = 0, l = 0, f = {}; t && (u = (i = Ui(t)).offsetWidth, c = i.offsetHeight), t && (a = Wi((o = function (t, n, e, r) { var i; void 0 === e && (e = n); var o = ki(t, n), a = o.matrixes, s = o.is3d, u = o.targetMatrix, c = o.transformOrigin, l = o.targetOrigin, f = ki(o.offsetContainer, e, !0), p = f.matrixes, d = f.is3d, h = r || d || s, v = h ? 4 : 3, g = "svg" !== t.tagName.toLowerCase() && "ownerSVGElement" in t, m = u, b = ln(v), x = ln(v), E = ln(v), y = ln(v), S = a.length; p.reverse(), a.reverse(), !s && h && (m = Ut(m, 3, 4), Ti(a)); !d && h && Ti(p); p.forEach(function (t) { x = Zt(x, t.matrix, v) }); var M = e || document.body, w = (null === (i = p[0]) || void 0 === i ? void 0 : i.target) || Bi(M, M, !0).offsetParent, D = p.slice(1).reduce(function (t, n) { return Zt(t, n.matrix, v) }, ln(v)); a.forEach(function (t, n) { var e; S - 2 === n && (E = b.slice()), S - 1 === n && (y = b.slice()), t.matrix || (e = function (t, n, e, r, i) { var o, a = t.target, s = t.origin, u = n.matrix, c = Ui(a), l = c.offsetWidth, f = c.offsetHeight, p = e.getBoundingClientRect(), d = [0, 0]; e === document.body && (d = Gi(a, !0)); var h = a.getBoundingClientRect(), v = h.left - p.left + e.scrollLeft - (e.clientLeft || 0) + d[0], g = h.top - p.top + e.scrollTop - (e.clientTop || 0) + d[1], m = h.width, b = h.height, x = $t(r, i, u), E = Xi(x, l, f, r), y = E.left, S = E.top, M = E.width, w = E.height, D = Ni(x, s, r), C = Jt(D, [y, S]), R = [v + C[0] * m / M, g + C[1] * b / w], O = [0, 0], P = 0; for (; ++P < 10;) { var _ = Ht(i, r); o = Jt(Ni(_, R, r), Ni(_, D, r)), O[0] = o[0], O[1] = o[1]; var B = Xi($t(r, i, pn(O, r), u), l, f, r), z = B.left, G = B.top, T = z - v, k = G - g; if (Math.abs(T) < 2 && Math.abs(k) < 2) break; R[0] -= T, R[1] -= k } return O.map(function (t) { return Math.round(t) }) }(t, a[n + 1], w, v, Zt(D, b, v)), t.matrix = pn(e, v)), b = Zt(b, t.matrix, v) }); var C = !g && s; m = m || ln(C ? 4 : 3); var R = Fi(g && 16 === m.length ? Ut(m, 4, 3) : m, C); return { rootMatrix: x = Lt(x, v, v), beforeMatrix: E, offsetMatrix: y, allMatrix: b, targetMatrix: m, targetTransform: R, transformOrigin: c, targetOrigin: l, is3d: h } }(t, n, e, r)).allMatrix, o.transformOrigin, u, c), f = Ce(Ce({}, o), a), l = $i([(s = Wi(o.allMatrix, [50, 50], 100, 100)).pos1, s.pos2], s.direction)); var p = r ? 4 : 3; return Ce({ width: u, height: c, rotation: l, rootMatrix: ln(p), beforeMatrix: ln(p), offsetMatrix: ln(p), allMatrix: ln(p), targetMatrix: ln(p), targetTransform: "", transformOrigin: [0, 0], targetOrigin: [0, 0], is3d: !!r, left: 0, top: 0, right: 0, bottom: 0, origin: [0, 0], pos1: [0, 0], pos2: [0, 0], pos3: [0, 0], pos4: [0, 0], direction: 1 }, f) } function Fi(t, n) { return void 0 === n && (n = 9 < t.length), (n ? "matrix3d" : "matrix") + "(" + Qt(t, !n).join(",") + ")" } function Ii(t) { var n = t.clientWidth, e = t.clientHeight; if (!t) return { x: 0, y: 0, width: 0, height: 0, clientWidth: n, clientHeight: e }; var r = t.viewBox, i = r && r.baseVal || { x: 0, y: 0, width: 0, height: 0 }; return { x: i.x, y: i.y, width: i.width || n, height: i.height || e, clientWidth: n, clientHeight: e } } function Ni(t, n, e) { return tn(t, Vt(n, e), e) } function ji(n, t, e, r) { return [[0, 0], [t, 0], [0, e], [t, e]].map(function (t) { return Ni(n, t, r) }) } function Yi(t) { var n = t.map(function (t) { return t[0] }), e = t.map(function (t) { return t[1] }), r = Math.min.apply(Math, n), i = Math.min.apply(Math, e), o = Math.max.apply(Math, n), a = Math.max.apply(Math, e); return { left: r, top: i, right: o, bottom: a, width: o - r, height: a - i } } function Xi(t, n, e, r) { return Yi(ji(t, n, e, r)) } function Wi(t, n, e, r) { var i = 16 === t.length ? 4 : 3, o = ji(t, e, r, i), a = o[0], s = a[0], u = a[1], c = o[1], l = c[0], f = c[1], p = o[2], d = p[0], h = p[1], v = o[3], g = v[0], m = v[1], b = Ni(t, n, i), x = b[0], E = b[1], y = Math.min(s, l, d, g), S = Math.min(u, f, h, m); return { left: y, top: S, right: Math.max(s, l, d, g), bottom: Math.max(u, f, h, m), origin: [x = x - y || 0, E = E - S || 0], pos1: [s = s - y || 0, u = u - S || 0], pos2: [l = l - y || 0, f = f - S || 0], pos3: [d = d - y || 0, h = h - S || 0], pos4: [g = g - y || 0, m = m - S || 0], direction: Ft(o) } } function qi(t) { return Math.sqrt(t[0] * t[0] + t[1] * t[1]) } function Li(t, n) { return qi([n[0] - t[0], n[1] - t[1]]) } function Hi(t, n, e, r) { void 0 === e && (e = 1), void 0 === r && (r = At(t, n)); var i = Li(t, n); return { transform: "translateY(-50%) translate(" + t[0] + "px, " + t[1] + "px) rotate(" + r + "rad) scaleY(" + e + ")", width: i + "px" } } function Vi(t, n) { for (var e = [], r = 2; r < arguments.length; r++)e[r - 2] = arguments[r]; var i = e.length; return { transform: "translateZ(0px) translate(" + e.reduce(function (t, n) { return t + n[0] }, 0) / i + "px, " + e.reduce(function (t, n) { return t + n[1] }, 0) / i + "px) rotate(" + t + "rad) scale(" + n + ")" } } function Ui(t, n) { if (void 0 === n && (n = so(t)), !ht(t.offsetWidth) || "svg" === t.tagName.toLowerCase()) { var e = "border-box" === n.boxSizing, r = parseFloat(n.borderLeftWidth) || 0, i = parseFloat(n.borderRightWidth) || 0, o = parseFloat(n.borderTopWidth) || 0, a = parseFloat(n.borderBottomWidth) || 0, s = parseFloat(n.paddingLeft) || 0, u = parseFloat(n.paddingRight) || 0, c = parseFloat(n.paddingTop) || 0, l = parseFloat(n.paddingBottom) || 0, f = parseFloat(n.width), p = parseFloat(n.height), d = f, h = p, v = s + u, g = c + l, m = v + (r + i), b = g + (o + a); return e ? (f = d - m, p = h - b) : (d = f + m, h = p + b), { svg: !1, offsetWidth: d, offsetHeight: h, clientWidth: f + v, clientHeight: p + g, cssWidth: f, cssHeight: p } } var d, h, x = t.getBBox(); return { svg: !0, offsetWidth: d = x.width, offsetHeight: h = x.height, clientWidth: d, clientHeight: h, cssWidth: d, cssHeight: h } } function $i(t, n) { return At(0 < n ? t[0] : t[1], 0 < n ? t[1] : t[0]) } function Zi(t, n, e, r, i) { var o, a, s = 1, u = [0, 0], c = Ki(), l = Ki(), f = Ki(), p = Ai(n, e, i, !1); return n && (o = p.is3d ? 4 : 3, s = (a = Wi(p.offsetMatrix, Kt(p.transformOrigin, function (t, n) { void 0 === n && (n = Math.sqrt(t.length)); for (var e = [], r = t[n * n - 1], i = 0; i < n - 1; ++i)e[i] = t[n * (n - 1) + i] / r; return e[n - 1] = 0, e }(p.targetMatrix, o)), p.width, p.height)).direction, u = Kt(a.origin, [a.left - p.left, a.top - p.top]), c = Ji(n), l = Ji(Bi(r, r, !0).offsetParent || document.body, !0), t && (f = Ji(t))), Ce({ targetClientRect: c, containerClientRect: l, moveableClientRect: f, beforeDirection: s, beforeOrigin: u, originalBeforeOrigin: u, target: n }, p) } function Ki() { return { left: 0, right: 0, top: 0, bottom: 0, width: 0, height: 0, clientLeft: 0, clientTop: 0, clientWidth: 0, clientHeight: 0, scrollWidth: 0, scrollHeight: 0 } } function Ji(t, n) { var e, r = 0, i = 0, o = 0, a = 0; t === document.body || t === document.documentElement ? (o = window.innerWidth, a = window.innerHeight, r = -(document.documentElement.scrollLeft || document.body.scrollLeft), i = -(document.documentElement.scrollTop || document.body.scrollTop)) : (r = (e = t.getBoundingClientRect()).left, i = e.top, o = e.width, a = e.height); var s = { left: r, right: r + o, top: i, bottom: i + a, width: o, height: a }; return n && (s.clientLeft = t.clientLeft, s.clientTop = t.clientTop, s.clientWidth = t.clientWidth, s.clientHeight = t.clientHeight, s.scrollWidth = t.scrollWidth, s.scrollHeight = t.scrollHeight, s.overflow = "visible" !== so(t).overflow), s } function Qi(t) { if (t) { var n = t.getAttribute("data-direction"); if (n) { var e = [0, 0]; return -1 < n.indexOf("w") && (e[0] = -1), -1 < n.indexOf("e") && (e[0] = 1), -1 < n.indexOf("n") && (e[1] = -1), -1 < n.indexOf("s") && (e[1] = 1), e } } } function to(t, n) { return [Kt(n, t[0]), Kt(n, t[1]), Kt(n, t[2]), Kt(n, t[3])] } function no(t) { var n = t.left, e = t.top; return to([t.pos1, t.pos2, t.pos3, t.pos4], [n, e]) } function eo(t, n) { var e; null !== (e = t[n]) && void 0 !== e && e.unset(), t[n] = null } function ro(t, n, e) { var r = n.datas; r.datas || (r.datas = {}); var i = Ce(Ce({}, e), { target: t.state.target, clientX: n.clientX, clientY: n.clientY, inputEvent: n.inputEvent, currentTarget: t, moveable: t, datas: r.datas }); return r.isStartEvent ? r.lastEvent = i : r.isStartEvent = !0, i } function io(t, n, e) { var r = n.datas, i = "isDrag" in e ? e.isDrag : n.isDrag; return r.datas || (r.datas = {}), Ce(Ce({ isDrag: i }, e), { moveable: t, target: t.state.target, clientX: n.clientX, clientY: n.clientY, inputEvent: n.inputEvent, currentTarget: t, lastEvent: r.lastEvent, isDouble: n.isDouble, datas: r.datas }) } function oo(t, n, e) { t._emitter.on(n, e) } function ao(t, n, e, r) { return t.triggerEvent(n, e, r) } function so(t, n) { return window.getComputedStyle(t, n) } function uo(t, e, r) { var i = {}, o = {}; return t.filter(function (n) { var t = n.name; if (i[t] || !e.some(function (t) { return n[t] })) return !1; if (!r && n.ableGroup) { if (o[n.ableGroup]) return !1; o[n.ableGroup] = !0 } return i[t] = !0 }) } function co(t, n) { return t === n || null == t && null == n } function lo() { for (var t = [], n = 0; n < arguments.length; n++)t[n] = arguments[n]; return t.sort(function (t, n) { return Math.abs(n) - Math.abs(t) }), t[0] } function fo(t, n, e) { return tn(Ht(t, e), Vt(n, e), e) } function po(t, n) { var e = t.is3d ? 4 : 3, r = fo(t.rootMatrix, [n.distX, n.distY], e); return n.distX = r[0], n.distY = r[1], n } function ho(t, n, e, r, i) { return Jt(Ni(t, Kt(e, n), i), r) } function vo(t, n, e) { return e ? t / n * 100 + "%" : t + "px" } function go(t) { return Math.abs(t) <= Ie ? 0 : t } function mo(t, n) { return n.isRequest ? ("resizable" === n.requestAble || "scalable" === n.requestAble) && n.parentDirection : Yt(n.inputEvent.target, Ri("direction")) } function bo(t) { var n = {}; for (var e in t) n[t[e]] = e; return n } function xo(t, n) { return t ? mt(t) ? n ? document.querySelector(t) : t : bt(t) ? t() : "current" in t ? t.current : t : null } function Eo(t, e) { return t ? ((n = t) && vt(n) && !(n instanceof Element) && (gt(n) || "length" in n) ? [].slice.call(t) : [t]).reduce(function (t, n) { return mt(n) && e ? Re(Re([], t), [].slice.call(document.querySelectorAll(n))) : (t.push(xo(n, e)), t) }, []) : []; var n } function yo(t, n) { var e, r, i, o = t.rootMatrix, a = t.is3d, s = Ht(o, a ? 4 : 3); return a || (s = Ut(s, 3, 4)), s[12] = 0, s[13] = 0, s[14] = 0, r = tn(s, [(e = n)[0], e[1] || 0, e[2] || 0, 1], 4), i = r[3] || 1, [r[0] / i, r[1] / i, r[2] / i] } function So(e, t, n, r) { var i, o, a, s, u, c, l, f, p, d = n.ratio, h = n.startOffsetWidth, v = n.startOffsetHeight, g = 0, m = 0, b = r.distX, x = r.distY, E = r.parentDistance, y = r.parentDist, S = r.parentScale, M = r.isPinch, w = n.fixedDirection; return y ? (g = y[0], m = y[1], t && (g ? m = m || g / d : g = m * d)) : S ? (g = (S[0] - 1) * h, m = (S[1] - 1) * v) : M ? E && (m = (g = E) * v / h) : (p = li({ datas: n, distX: b, distY: x }), p = [0, 1].map(function (t) { var n = Math.abs(e[t] - w[t]); return 0 !== n && (n = 2 / n), p[t] * n }), t && h && v ? (i = At([0, 0], p), o = At([0, 0], e), a = qi(p), s = Math.cos(i - o) * a, e[0] ? m = e[1] ? (u = 2 * e[0] * h, c = 2 * e[1] * v, l = qi([u + p[0], c + p[1]]) - qi([u, c]), f = At([0, 0], [d, 1]), g = Math.cos(f) * l, Math.sin(f) * l) : (g = s) / d : g = (m = s) * d) : (g = e[0] * p[0], m = e[1] * p[1])), { distWidth: g, distHeight: m } } var Mo = Oe("pinchable", { events: { onPinchStart: "pinchStart", onPinch: "pinch", onPinchEnd: "pinchEnd", onPinchGroupStart: "pinchGroupStart", onPinchGroup: "pinchGroup", onPinchGroupEnd: "pinchGroupEnd" }, dragStart: function () { return !0 }, pinchStart: function (e, r) { var t = r.datas, n = r.targets, i = r.angle, o = r.originalDatas, a = e.props, s = a.pinchable, u = a.ables; if (!s) return !1; var c = "onPinch" + (n ? "Group" : "") + "Start", l = "drag" + (n ? "Group" : "") + "ControlStart", f = (!0 === s ? e.controlAbles : u.filter(function (t) { return -1 < s.indexOf(t.name) })).filter(function (t) { return t.canPinch && t[l] }), p = ro(e, r, {}); n && (p.targets = n); var d = ao(e, c, p); t.isPinch = !1 !== d, t.ables = f; var h = t.isPinch; return !!h && (f.forEach(function (t) { var n; o[t.name] = o[t.name] || {}, t[l] && (n = Ce(Ce({}, r), { datas: o[t.name], parentRotate: i, isPinch: !0 }), t[l](e, n)) }), e.state.snapRenderInfo = { request: r.isRequest, direction: [0, 0] }, h) }, pinch: function (n, e) { var t = e.datas, r = e.scale, i = e.distance, o = e.originalDatas, a = e.inputEvent, s = e.targets, u = e.angle; if (t.isPinch) { var c = i * (1 - 1 / r), l = ro(n, e, {}); s && (l.targets = s), ao(n, "onPinch" + (s ? "Group" : ""), l); var f = t.ables, p = "drag" + (s ? "Group" : "") + "Control"; return f.forEach(function (t) { t[p] && t[p](n, Ce(Ce({}, e), { datas: o[t.name], inputEvent: a, parentDistance: c, parentRotate: u, isPinch: !0 })) }), l } }, pinchEnd: function (n, e) { var t = e.datas, r = e.isPinch, i = e.inputEvent, o = e.targets, a = e.originalDatas; if (t.isPinch) { var s = "onPinch" + (o ? "Group" : "") + "End", u = io(n, e, { isDrag: r }); o && (u.targets = o), ao(n, s, u); var c = t.ables, l = "drag" + (o ? "Group" : "") + "ControlEnd"; return c.forEach(function (t) { t[l] && t[l](n, Ce(Ce({}, e), { isDrag: r, datas: a[t.name], inputEvent: i, isPinch: !0 })) }), r } }, pinchGroupStart: function (t, n) { return this.pinchStart(t, Ce(Ce({}, n), { targets: t.props.targets })) }, pinchGroup: function (t, n) { return this.pinch(t, Ce(Ce({}, n), { targets: t.props.targets })) }, pinchGroupEnd: function (t, n) { return this.pinchEnd(t, Ce(Ce({}, n), { targets: t.props.targets })) } }), wo = { name: "resizable", ableGroup: "size", canPinch: !0, props: { resizable: Boolean, throttleResize: Number, renderDirections: Array, keepRatio: Boolean, resizeFormat: Function }, events: { onResizeStart: "resizeStart", onBeforeResize: "beforeResize", onResize: "resize", onResizeEnd: "resizeEnd", onResizeGroupStart: "resizeGroupStart", onBeforeResizeGroup: "beforeResizeGroup", onResizeGroup: "resizeGroup", onResizeGroupEnd: "resizeGroupEnd" }, render: function (t, n) { var e = t.props, r = e.resizable, i = e.edge; if (r) return (i ? Qe : Je)(t, n) }, dragControlCondition: mo, dragControlStart: function (t, n) { var e, r, i = n.inputEvent, o = n.isPinch, a = n.parentDirection, s = n.datas, u = n.parentFlag, c = a || (o ? [0, 0] : Qi(i.target)), l = t.state, f = l.target, p = l.width, d = l.height; if (!c || !f) return !1; o || oi(t, n), s.datas = {}, s.direction = c, s.startOffsetWidth = p, s.startOffsetHeight = d, s.prevWidth = 0, s.prevHeight = 0, r = so(f), e = [parseFloat(r.width), parseFloat(r.height)], s.startWidth = e[0], s.startHeight = e[1]; var h, v, g, m, b, x, E, y, S, M, w, D = [Math.max(0, p - s.startWidth), Math.max(0, d - s.startHeight)]; s.minSize = D, s.maxSize = [1 / 0, 1 / 0], u || (v = (h = so(f)).position, g = h.minWidth, m = h.minHeight, b = h.maxWidth, x = h.maxHeight, M = p, w = d, (y = (E = "static" === v || "relative" === v) ? f.parentElement : f.offsetParent) && (M = y.clientWidth, w = y.clientHeight, E && (S = so(y), M -= parseFloat(S.paddingLeft) || 0, w -= parseFloat(S.paddingTop) || 0)), s.minSize = Kt([zt(g, M) || 0, zt(m, w) || 0], D), s.maxSize = Kt([zt(b, M) || 1 / 0, zt(x, w) || 1 / 0], D)); var C = t.props.transformOrigin || "% %"; function R(t) { s.ratio = t && isFinite(t) ? t : 0 } function O(t) { s.fixedDirection = t, s.fixedPosition = di(s.startPositions, t) } s.transformOrigin = C && mt(C) ? C.split(" ") : C, s.isWidth = !c[0] && !c[1] || c[0] || !c[1], s.startPositions = no(t.state), R(p / d), O([-c[0], -c[1]]); var P = ro(t, n, { direction: c, set: function (t) { var n = t[0], e = t[1]; s.startWidth = n, s.startHeight = e }, setMin: function (t) { s.minSize = t }, setMax: function (t) { s.maxSize = [t[0] || 1 / 0, t[1] || 1 / 0] }, setRatio: R, setFixedDirection: s.setFixedDirection = O, setOrigin: function (t) { s.transformOrigin = t }, dragStart: ri.dragStart(t, (new He).dragStart([0, 0], n)) }); return !1 !== ao(t, "onResizeStart", P) && (s.isResize = !0, t.state.snapRenderInfo = { request: n.isRequest, direction: c }), !!s.isResize && P }, dragControl: function (t, r) { var n, i = r.datas, e = r.parentFlag, o = r.isPinch, a = r.parentKeepRatio, s = r.dragClient, u = r.parentDist, c = r.isRequest, l = i.isResize, f = i.transformOrigin, p = i.startWidth, d = i.startHeight, h = i.prevWidth, v = i.prevHeight, g = i.minSize, m = i.maxSize, b = i.ratio, x = i.isWidth, E = i.startOffsetWidth, y = i.startOffsetHeight; if (l) { var S = t.props, M = S.resizeFormat, w = S.throttleResize, D = void 0 === w ? 1 : w, C = S.parentMoveable, R = S.snapThreshold, O = void 0 === R ? 5 : R, P = i.direction, _ = P, B = 0, z = 0; P[0] || P[1] || (_ = [1, 1]); var G = b && (null != a ? a : S.keepRatio) || !1, T = W(), k = T[0], A = T[1]; i.setFixedDirection(i.fixedDirection), ao(t, "onBeforeResize", ro(t, r, { setFixedDirection: function (t) { var n; return i.setFixedDirection(t), n = W(), k = n[0], A = n[1], [k, A] }, boundingWidth: k, boundingHeight: A, setSize: function (t) { k = t[0], A = t[1] } })); var F = s; s || (F = !e && o ? Ci(t, [0, 0]) : i.fixedPosition); var I, N = [0, 0]; o || (N = function (t, e, r, n, i, o, a) { if (!lr(t, "resizable")) return [0, 0]; var s = a.fixedDirection, u = t.state, c = u.allMatrix, l = u.is3d; return Jr(t, function (t, n) { return Zr(c, e + t, r + n, s, i, l) }, e, r, n, i, o, a) }(t, k, A, P, F, c, i)), u && (u[0] || (N[0] = 0), u[1] || (N[1] = 0)), G ? (_[0] && _[1] && N[0] && N[1] && (Math.abs(N[0]) > Math.abs(N[1]) ? N[1] = 0 : N[0] = 0), (I = !N[0] && !N[1]) && q(), _[0] && !_[1] || N[0] && !N[1] || I && x ? (k += N[0], A = k / b) : (!_[0] && _[1] || !N[0] && N[1] || I && !x) && (A += N[1], k = A * b)) : (E + B < -O && (N[0] = 0), E + z < -O && (N[1] = 0), k += N[0], A += N[1]), n = Tt([k, A], g, m, G), k = n[0], A = n[1], q(); var j = [(B = k - E) - h, (z = A - y) - v]; i.prevWidth = B, i.prevHeight = z; var Y = Di(t, k, A, i.fixedDirection, F, f); if (C || !j.every(function (t) { return !t }) || !Y.every(function (t) { return !t })) { var X = ro(t, r, { width: p + B, height: d + z, offsetWidth: Math.round(k), offsetHeight: Math.round(A), boundingWidth: k, boundingHeight: A, direction: P, dist: [B, z], delta: j, isPinch: !!o, drag: ri.drag(t, Le(r, t.state, Y, !!o, !1)) }); return ao(t, "onResize", X), X } } function W() { var t = So(_, G, i, r); B = t.distWidth, z = t.distHeight; var n = _[0] || G ? Math.max(E + B, Ie) : E, e = _[1] || G ? Math.max(y + z, Ie) : y; return G && E && y && (x ? e = n / b : n = e * b), [n, e] } function q() { var t; M && (t = M([k, A]), k = t[0], A = t[1]), k = Nt(k, D), A = Nt(A, D) } }, dragControlAfter: function (t, n) { var e = n.datas, r = e.isResize, i = e.startOffsetWidth, o = e.startOffsetHeight, a = e.prevWidth, s = e.prevHeight; if (r) { var u = t.state, c = u.width - (i + a), l = u.height - (o + s), f = 3 < Math.abs(c), p = 3 < Math.abs(l); return f && (e.startWidth += c, e.startOffsetWidth += c, e.prevWidth += c), p && (e.startHeight += l, e.startOffsetHeight += l, e.prevHeight += l), f || p ? this.dragControl(t, n) : void 0 } }, dragControlEnd: function (t, n) { var e = n.datas; if (e.isResize) { e.isResize = !1; var r = io(t, n, {}); return ao(t, "onResizeEnd", r), r } }, dragGroupControlCondition: mo, dragGroupControlStart: function (u, t) { var c = t.datas, n = this.dragControlStart(u, t); if (!n) return !1; var r = Ve(u, "resizable", t); function i(t, n) { var e = c.fixedDirection, r = c.fixedPosition, i = di(n.datas.startPositions || no(t.state), e), o = tn(cn(-u.rotation / 180 * Math.PI, 3), [i[0] - r[0], i[1] - r[1], 1], 3), a = o[0], s = o[1]; return n.datas.originalX = a, n.datas.originalY = s, n } function e(e) { n.setFixedDirection(e), o.forEach(function (t, n) { t.setFixedDirection(e), i(t.moveable, r[n]) }) } var o = $e(u, this, "dragControlStart", t, i); c.setFixedDirection = e; var a = Ce(Ce({}, n), { targets: u.props.targets, events: o, setFixedDirection: e }), s = ao(u, "onResizeGroupStart", a); return c.isResize = !1 !== s, !!c.isResize && n }, dragGroupControl: function (o, n) { var t = n.datas; if (t.isResize) { oo(o, "onBeforeResize", function (t) { ao(o, "onBeforeResizeGroup", ro(o, n, Ce(Ce({}, t), { targets: o.props.targets }))) }); var e = this.dragControl(o, n); if (e) { var r = e.boundingWidth, i = e.boundingHeight, a = e.dist, s = o.props.keepRatio, u = [r / (r - a[0]), i / (i - a[1])], c = t.fixedPosition, l = $e(o, this, "dragControl", n, function (t, n) { var e = tn(cn(o.rotation / 180 * Math.PI, 3), [n.datas.originalX * u[0], n.datas.originalY * u[1], 1], 3), r = e[0], i = e[1]; return Ce(Ce({}, n), { parentDist: null, parentScale: u, dragClient: Kt(c, [r, i]), parentKeepRatio: s }) }), f = Ce({ targets: o.props.targets, events: l }, e); return ao(o, "onResizeGroup", f), f } } }, dragGroupControlEnd: function (t, n) { var e = n.isDrag; if (n.datas.isResize) { this.dragControlEnd(t, n); var r = $e(t, this, "dragControlEnd", n); return ao(t, "onResizeGroupEnd", io(t, n, { targets: t.props.targets, events: r })), e } }, request: function (t) { var n = {}, e = 0, r = 0, i = t.getRect(); return { isControl: !0, requestStart: function (t) { return { datas: n, parentDirection: t.direction || [1, 1] } }, request: function (t) { return "offsetWidth" in t ? e = t.offsetWidth - i.offsetWidth : "deltaWidth" in t && (e += t.deltaWidth), "offsetHeight" in t ? r = t.offsetHeight - i.offsetHeight : "deltaHeight" in t && (r += t.deltaHeight), { datas: n, parentDist: [e, r], parentKeepRatio: t.keepRatio } }, requestEnd: function () { return { datas: n, isDrag: !0 } } } } }, Do = { name: "scalable", ableGroup: "size", canPinch: !0, props: { scalable: Boolean, throttleScale: Number, renderDirections: String, keepRatio: Boolean }, events: { onScaleStart: "scaleStart", onBeforeScale: "beforeScale", onScale: "scale", onScaleEnd: "scaleEnd", onScaleGroupStart: "scaleGroupStart", onBeforeScaleGroup: "beforeScaleGroup", onScaleGroup: "scaleGroup", onScaleGroupEnd: "scaleGroupEnd" }, render: function (t, n) { var e = t.props, r = e.resizable, i = e.scalable, o = e.edge; if (!r && i) return (o ? Qe : Je)(t, n) }, dragControlCondition: mo, dragControlStart: function (t, n) { var e = n.datas, r = n.isPinch, i = n.inputEvent, o = n.parentDirection || (r ? [0, 0] : Qi(i.target)), a = t.state, s = a.width, u = a.height, c = a.targetTransform, l = a.target, f = a.pos1, p = a.pos2, d = a.pos4; if (!o || !l) return !1; r || oi(t, n), e.datas = {}, e.transform = c, e.prevDist = [1, 1], e.direction = o, e.startOffsetWidth = s, e.startOffsetHeight = u, e.startValue = [1, 1]; var h = It(f, p), v = It(p, d), g = !o[0] && !o[1] || o[0] || !o[1]; function m(t) { e.ratio = t && isFinite(t) ? t : 0 } function b(t) { e.fixedDirection = t, e.fixedPosition = di(e.startPositions, t) } e.scaleWidth = h, e.scaleHeight = v, e.scaleXRatio = h / s, e.scaleYRatio = v / u, mi(n, "scale"), e.isWidth = g, e.startPositions = no(t.state), e.setFixedDirection = b, m(It(f, p) / It(p, d)), b([-o[0], -o[1]]); var x = ro(t, n, Ce(Ce({ direction: o, set: function (t) { e.startValue = t }, setRatio: m, setFixedDirection: b }, gi(n)), { dragStart: ri.dragStart(t, (new He).dragStart([0, 0], n)) })); return !1 !== ao(t, "onScaleStart", x) && (e.isScale = !0, t.state.snapRenderInfo = { request: n.isRequest, direction: o }), !!e.isScale && x }, dragControl: function (t, o) { ai(o, "scale"); var a = o.datas, n = o.parentKeepRatio, e = o.parentFlag, r = o.isPinch, i = o.dragClient, s = o.isRequest, u = a.prevDist, c = a.direction, l = a.startOffsetWidth, f = a.startOffsetHeight, p = a.isScale, d = a.startValue, h = a.isWidth, v = a.ratio; if (!p) return !1; var g = t.props, m = g.throttleScale, b = g.parentMoveable, x = c; c[0] || c[1] || (x = [1, 1]); var E = v && (null != n ? n : g.keepRatio) || !1, y = t.state; function S() { var t = So(x, E, a, o), n = t.distWidth, e = t.distHeight, r = (l + n) / l, i = (f + e) / f, r = x[0] || E ? r * d[0] : d[0], i = x[1] || E ? i * d[1] : d[1]; return 0 === r && (r = 1e-9 * (0 < u[0] ? 1 : -1)), 0 === i && (i = 1e-9 * (0 < u[1] ? 1 : -1)), [r, i] } var M, w = S(); r || !t.props.groupable || gt(M = (y.snapRenderInfo || {}).direction) && (M[0] || M[1]) && (y.snapRenderInfo = { direction: c, request: o.isRequest }), ao(t, "onBeforeScale", ro(t, o, { scale: w, setFixedDirection: function (t) { return a.setFixedDirection(t), w = S() }, setScale: function (t) { w = t } })); var D, C, R, O = [w[0] / d[0], w[1] / d[1]], P = i, _ = [0, 0]; i || (P = !e && r ? Ci(t, [0, 0]) : a.fixedPosition), r || (_ = Qr(t, O, c, s, a)), E ? (x[0] && x[1] && _[0] && _[1] && (Math.abs(_[0] * l) > Math.abs(_[1] * f) ? _[1] = 0 : _[0] = 0), (D = !_[0] && !_[1]) && (h ? O[0] = Nt(O[0] * d[0], m) / d[0] : O[1] = Nt(O[1] * d[1], m) / d[1]), x[0] && !x[1] || _[0] && !_[1] || D && h ? (O[0] += _[0], C = l * O[0] * d[0] / v, O[1] = C / f / d[1]) : (!x[0] && x[1] || !_[0] && _[1] || D && !h) && (O[1] += _[1], R = f * O[1] * d[1] * v, O[0] = R / l / d[0])) : (O[0] += _[0], O[1] += _[1], _[0] || (O[0] = Nt(O[0] * d[0], m) / d[0]), _[1] || (O[1] = Nt(O[1] * d[1], m) / d[1])), 0 === O[0] && (O[0] = 1e-9 * (0 < u[0] ? 1 : -1)), 0 === O[1] && (O[1] = 1e-9 * (0 < u[1] ? 1 : -1)); var B, z, G = [O[0] / u[0], O[1] / u[1]]; z = d, w = [(B = O)[0] * z[0], B[1] * z[1]]; var T, k, A, F, I, N = (T = t, k = O, A = a.fixedDirection, F = P, I = a, Si(T, "scale(" + k.join(", ") + ")", A, F, I)), j = Jt(N, a.prevInverseDist || [0, 0]); if (a.prevDist = O, a.prevInverseDist = N, w[0] === u[0] && w[1] === u[1] && j.every(function (t) { return !t }) && !b) return !1; var Y = si(a, "scale(" + w.join(", ") + ")", "scale(" + O.join(", ") + ")"), X = ro(t, o, Ce({ offsetWidth: l, offsetHeight: f, direction: c, scale: w, dist: O, delta: G, isPinch: !!r }, yi(t, Y, j, r, o))); return ao(t, "onScale", X), X }, dragControlEnd: function (t, n) { var e = n.datas, r = n.isDrag; return !!e.isScale && (e.isScale = !1, ao(t, "onScaleEnd", io(t, n, {})), r) }, dragGroupControlCondition: mo, dragGroupControlStart: function (u, t) { var c = t.datas, n = this.dragControlStart(u, t); if (!n) return !1; var r = Ve(u, "resizable", t); function i(t, n) { var e = c.fixedDirection, r = c.fixedPosition, i = di(n.datas.startPositions || no(t.state), e), o = tn(cn(-u.rotation / 180 * Math.PI, 3), [i[0] - r[0], i[1] - r[1], 1], 3), a = o[0], s = o[1]; return n.datas.originalX = a, n.datas.originalY = s, n } c.moveableScale = u.scale; function e(e) { n.setFixedDirection(e), o.forEach(function (t, n) { t.setFixedDirection(e), i(t.moveable, r[n]) }) } var o = $e(u, this, "dragControlStart", t, i); c.setFixedDirection = e; var a = Ce(Ce({}, n), { targets: u.props.targets, events: o, setFixedDirection: e }), s = ao(u, "onScaleGroupStart", a); return c.isScale = !1 !== s, !!c.isScale && a }, dragGroupControl: function (o, n) { var t = n.datas; if (t.isScale) { oo(o, "onBeforeScale", function (t) { ao(o, "onBeforeScaleGroup", ro(o, n, Ce(Ce({}, t), { targets: o.props.targets }))) }); var e = this.dragControl(o, n); if (e) { var r = t.moveableScale; o.scale = [e.scale[0] * r[0], e.scale[1] * r[1]]; var a = o.props.keepRatio, s = e.dist, u = e.scale, c = t.fixedPosition, i = $e(o, this, "dragControl", n, function (t, n) { var e = tn(cn(o.rotation / 180 * Math.PI, 3), [n.datas.originalX * s[0], n.datas.originalY * s[1], 1], 3), r = e[0], i = e[1]; return Ce(Ce({}, n), { parentDist: null, parentScale: u, parentKeepRatio: a, dragClient: Kt(c, [r, i]) }) }), l = Ce({ targets: o.props.targets, events: i }, e); return ao(o, "onScaleGroup", l), l } } }, dragGroupControlEnd: function (t, n) { var e = n.isDrag; if (n.datas.isScale) { this.dragControlEnd(t, n); var r = $e(t, this, "dragControlEnd", n); return ao(t, "onScaleGroupEnd", io(t, n, { targets: t.props.targets, events: r })), e } }, request: function () { var n = {}, e = 0, r = 0; return { isControl: !0, requestStart: function (t) { return { datas: n, parentDirection: t.direction || [1, 1] } }, request: function (t) { return e += t.deltaWidth, r += t.deltaHeight, { datas: n, parentDist: [e, r], parentKeepRatio: t.keepRatio } }, requestEnd: function () { return { datas: n, isDrag: !0 } } } } }; function Co(t, a) { return t.map(function (t, n) { return e = t, r = a[n], (e * (o = 2) + r * (i = 1)) / (i + o); var e, r, i, o }) } function Ro(t, n, e) { var r = At(t, n), i = At(t, e) - r; return 0 <= i ? i : i + 2 * Math.PI } var Oo = { name: "warpable", ableGroup: "size", props: { warpable: Boolean, renderDirections: Array }, events: { onWarpStart: "warpStart", onWarp: "warp", onWarpEnd: "warpEnd" }, render: function (t, n) { var e = t.props, r = e.resizable, i = e.scalable, o = e.warpable, a = e.zoom; if (r || i || !o) return []; var s = t.state, u = s.pos1, c = s.pos2, l = s.pos3, f = s.pos4, p = Co(u, c), d = Co(c, u), h = Co(u, l), v = Co(l, u), g = Co(l, f), m = Co(f, l), b = Co(c, f), x = Co(f, c); return Re([n.createElement("div", { className: Ri("line"), key: "middeLine1", style: Hi(p, g, a) }), n.createElement("div", { className: Ri("line"), key: "middeLine2", style: Hi(d, m, a) }), n.createElement("div", { className: Ri("line"), key: "middeLine3", style: Hi(h, b, a) }), n.createElement("div", { className: Ri("line"), key: "middeLine4", style: Hi(v, x, a) })], Je(t, n)) }, dragControlCondition: function (t, n) { return !n.isRequest && Yt(n.inputEvent.target, Ri("direction")) }, dragControlStart: function (t, n) { var r = n.datas, e = n.inputEvent, i = t.props.target, o = Qi(e.target); if (!o || !i) return !1; var a = t.state, s = a.transformOrigin, u = a.is3d, c = a.targetTransform, l = a.targetMatrix, f = a.width, p = a.height, d = a.left, h = a.top; return r.datas = {}, r.targetTransform = c, r.warpTargetMatrix = u ? l : Ut(l, 3, 4), r.targetInverseMatrix = Lt(Ht(r.warpTargetMatrix, 4), 3, 4), r.direction = o, r.left = d, r.top = h, r.poses = [[0, 0], [f, 0], [0, p], [f, p]].map(function (t) { return Jt(t, s) }), r.nextPoses = r.poses.map(function (t) { var n = t[0], e = t[1]; return tn(r.warpTargetMatrix, [n, e, 0, 1], 4) }), r.startValue = ln(4), r.prevMatrix = ln(4), r.absolutePoses = no(a), r.posIndexes = fi(o), oi(t, n), mi(n, "matrix3d"), !(a.snapRenderInfo = { request: n.isRequest, direction: o }) !== ao(t, "onWarpStart", ro(t, n, Ce({ set: function (t) { r.startValue = t } }, gi(n)))) && (r.isWarp = !0), r.isWarp }, dragControl: function (t, n) { var e, r, i, o, a = n.datas, s = n.isRequest, u = n.distX, c = n.distY, l = a.targetInverseMatrix, f = a.prevMatrix, p = a.isWarp, d = a.startValue, h = a.poses, v = a.posIndexes, g = a.absolutePoses; if (!p) return !1; ai(n, "matrix3d"), lr(t, "warpable") && (1 < (e = v.map(function (t) { return g[t] })).length && e.push([(e[0][0] + e[1][0]) / 2, (e[0][1] + e[1][1]) / 2]), i = (r = Lr(t, s, { horizontal: e.map(function (t) { return t[1] + c }), vertical: e.map(function (t) { return t[0] + u }) })).horizontal, o = r.vertical, c -= i.offset, u -= o.offset); var m = li({ datas: a, distX: u, distY: c }, !0), b = a.nextPoses.slice(); if (v.forEach(function (t) { b[t] = Kt(b[t], m) }), !Ae.every(function (t) { return n = t.map(function (t) { return h[t] }), e = t.map(function (t) { return b[t] }), r = Ro(n[0], n[1], n[2]), i = Ro(e[0], e[1], e[2]), !((o = Math.PI) <= r && i <= o || r <= o && o <= i); var n, e, r, i, o })) return !1; var x = dn(h[0], h[2], h[1], h[3], b[0], b[2], b[1], b[3]); if (!x.length) return !1; var E = ui(a, Zt(l, x, 4), !0), y = Zt(Ht(f, 4), E, 4), S = Zt(d, a.prevMatrix = E, 4), M = si(a, "matrix3d(" + S.join(", ") + ")", "matrix3d(" + E.join(", ") + ")"); return xi(n, M), ao(t, "onWarp", ro(t, n, { delta: y, matrix: S, dist: E, multiply: Zt, transform: M })), !0 }, dragControlEnd: function (t, n) { var e = n.datas, r = n.isDrag; return !!e.isWarp && (e.isWarp = !1, ao(t, "onWarpEnd", io(t, n, {})), r) } }, Po = Ri("area-pieces"), _o = Ri("area-piece"), Bo = Ri("avoid"); function zo(t) { var n, e, r, i, o, a, s = t.areaElement; s && (e = (n = t.state).width, r = n.height, o = Bo, (i = s).classList ? i.classList.remove(o) : (a = new RegExp("(\\s|^)" + o + "(\\s|$)"), i.className = i.className.replace(a, " ")), s.style.cssText += "left: 0px; top: 0px; width: " + e + "px; height: " + r + "px") } function Go(t) { return t.createElement("div", { key: "area_pieces", className: Po }, t.createElement("div", { className: _o }), t.createElement("div", { className: _o }), t.createElement("div", { className: _o }), t.createElement("div", { className: _o })) } var To = { name: "dragArea", props: { dragArea: Boolean, passDragArea: Boolean }, events: { onClick: "click", onClickGroup: "clickGroup" }, render: function (t, n) { var e = t.props, r = e.target, i = e.dragArea, o = e.groupable, a = e.passDragArea, s = t.state, u = s.width, c = s.height, l = s.renderPoses, f = a ? Ri("area", "pass") : Ri("area"); if (o) return [n.createElement("div", { key: "area", ref: y(t, "areaElement"), className: f }), Go(n)]; if (!r || !i) return []; var p = dn([0, 0], [u, 0], [0, c], [u, c], l[0], l[1], l[2], l[3]), d = p.length ? Fi(p, !0) : "none"; return [n.createElement("div", { key: "area", ref: y(t, "areaElement"), className: f, style: { top: "0px", left: "0px", width: u + "px", height: c + "px", transformOrigin: "0 0", transform: d } }), Go(n)] }, dragStart: function (t, n) { var e = n.datas, r = n.clientX, i = n.clientY; if (!n.inputEvent) return !1; e.isDragArea = !1; var o, a, s = t.areaElement, u = t.state, c = u.moveableClientRect, l = u.renderPoses, f = u.rootMatrix, p = u.is3d, d = c.left, h = c.top, v = Yi(l), g = v.left, m = v.top, b = v.width, x = v.height, E = fo(f, [r - d, i - h], p ? 4 : 3), y = E[0], S = E[1], M = [{ left: g, top: m, width: b, height: (S -= m) - 10 }, { left: g, top: m, width: (y -= g) - 10, height: x }, { left: g, top: m + S + 10, width: b, height: x - S - 10 }, { left: g + y + 10, top: m, width: b - y - 10, height: x }], w = [].slice.call(s.nextElementSibling.children); M.forEach(function (t, n) { w[n].style.cssText = "left: " + t.left + "px;top: " + t.top + "px; width: " + t.width + "px; height: " + t.height + "px;" }), a = Bo, (o = s).classList ? o.classList.add(a) : o.className += " " + a, u.disableNativeEvent = !0 }, drag: function (t, n) { var e = n.datas, r = n.inputEvent; if (this.enableNativeEvent(t), !r) return !1; e.isDragArea || (e.isDragArea = !0, zo(t)) }, dragEnd: function (t, n) { this.enableNativeEvent(t); var e = n.inputEvent, r = n.datas; if (!e) return !1; r.isDragArea || zo(t) }, dragGroupStart: function (t, n) { return this.dragStart(t, n) }, dragGroup: function (t, n) { return this.drag(t, n) }, dragGroupEnd: function (t, n) { return this.dragEnd(t, n) }, unset: function (t) { zo(t), t.state.disableNativeEvent = !1 }, enableNativeEvent: function (t) { var n = t.state; n.disableNativeEvent && Pt(function () { n.disableNativeEvent = !1 }) } }, ko = Oe("origin", { render: function (t, n) { var e = t.props.zoom, r = t.state, i = r.beforeOrigin, o = r.rotation; return [n.createElement("div", { className: Ri("control", "origin"), style: Vi(o, e, i), key: "beforeOrigin" })] } }); function Ao(t) { var n = t.scrollContainer; return [n.scrollLeft, n.scrollTop] } var Fo = { name: "scrollable", canPinch: !0, props: { scrollable: Boolean, scrollContainer: Object, scrollThreshold: Number, getScrollPosition: Function }, events: { onScroll: "scroll", onScrollGroup: "scrollGroup" }, dragRelation: "strong", dragStart: function (o, a) { var t = o.props.scrollContainer, n = void 0 === t ? o.getContainer() : t, e = new Vn, r = xo(n, !0); a.datas.dragScroll = e; var i = a.isControl ? "controlGesto" : "targetGesto", s = a.targets; e.on("scroll", function (t) { var n = t.container, e = t.direction, r = ro(o, a, { scrollContainer: n, direction: e }), i = s ? "onScrollGroup" : "onScroll"; s && (r.targets = s), ao(o, i, r) }).on("move", function (t) { var n = t.offsetX, e = t.offsetY; o[i].scrollBy(n, e, a.inputEvent, !1) }), e.dragStart(a, { container: r }) }, checkScroll: function (t, n) { var e = n.datas.dragScroll; if (e) { var r = t.props, i = r.scrollContainer, o = void 0 === i ? t.getContainer() : i, a = r.scrollThreshold, s = void 0 === a ? 0 : a, u = r.getScrollPosition, c = void 0 === u ? Ao : u; return e.drag(n, { container: o, threshold: s, getScrollPosition: function (t) { return c({ scrollContainer: t.container, direction: t.direction }) } }), !0 } }, drag: function (t, n) { return this.checkScroll(t, n) }, dragEnd: function (t, n) { n.datas.dragScroll.dragEnd(), n.datas.dragScroll = null }, dragControlStart: function (t, n) { return this.dragStart(t, Ce(Ce({}, n), { isControl: !0 })) }, dragControl: function (t, n) { return this.drag(t, n) }, dragControlEnd: function (t, n) { return this.dragEnd(t, n) }, dragGroupStart: function (t, n) { return this.dragStart(t, Ce(Ce({}, n), { targets: t.props.targets })) }, dragGroup: function (t, n) { return this.drag(t, Ce(Ce({}, n), { targets: t.props.targets })) }, dragGroupEnd: function (t, n) { return this.dragEnd(t, Ce(Ce({}, n), { targets: t.props.targets })) }, dragGroupControlStart: function (t, n) { return this.dragStart(t, Ce(Ce({}, n), { targets: t.props.targets, isControl: !0 })) }, dragGroupContro: function (t, n) { return this.drag(t, Ce(Ce({}, n), { targets: t.props.targets })) }, dragGroupControEnd: function (t, n) { return this.dragEnd(t, Ce(Ce({}, n), { targets: t.props.targets })) } }, Io = { name: "", props: { target: Object, dragTarget: Object, container: Object, portalContainer: Object, rootContainer: Object, useResizeObserver: Boolean, zoom: Number, transformOrigin: Array, edge: Boolean, ables: Array, className: String, pinchThreshold: Number, pinchOutside: Boolean, triggerAblesSimultaneously: Boolean, checkInput: Boolean, cspNonce: String, translateZ: Number, hideDefaultLines: Boolean, props: Object }, events: {} }, No = Oe("padding", { render: function (t, o) { var n = t.props; if (n.dragArea) return []; var e = n.padding || {}, r = e.left, i = void 0 === r ? 0 : r, a = e.top, s = void 0 === a ? 0 : a, u = e.right, c = void 0 === u ? 0 : u, l = e.bottom, f = void 0 === l ? 0 : l, p = t.state, d = p.renderPoses, h = [p.pos1, p.pos2, p.pos3, p.pos4], v = []; return 0 < i && v.push([0, 2]), 0 < s && v.push([0, 1]), 0 < c && v.push([1, 3]), 0 < f && v.push([2, 3]), v.map(function (t, n) { var e = t[0], r = t[1], i = dn([0, 0], [100, 0], [0, 100], [100, 100], h[e], h[r], d[e], d[r]); if (i.length) return o.createElement("div", { key: "padding" + n, className: Ri("padding"), style: { transform: Fi(i, !0) } }) }) } }), jo = ["nw", "ne", "se", "sw"]; function Yo(t, n) { var e = t[0] + t[1], r = n < e ? n / e : 1; return t[0] *= r, t[1] = n - t[1] * r, t } var Xo = [1, 2, 5, 6], Wo = [0, 3, 4, 7], qo = [1, -1, -1, 1], Lo = [1, 1, -1, -1]; function Ho(t, a, s, u, c, l, f, p, d) { void 0 === l && (l = 0), void 0 === f && (f = 0), void 0 === p && (p = u), void 0 === d && (d = c); var h = [], v = !1, n = t.map(function (t, n) { var e = a[n], r = e.horizontal, i = e.vertical; if (i && !v && (v = !0, h.push("/")), v) { var o = Math.max(0, 1 === i ? t[1] - f : d - t[1]); return h.push(vo(o, c, s)), o } o = Math.max(0, 1 === r ? t[0] - l : p - t[0]); return h.push(vo(o, u, s)), o }); return { styles: h, raws: n } } function Vo(t) { for (var n = [0, 0], e = [0, 0], r = t.length, i = 0; i < r; ++i) { var o = t[i]; o.sub && (o.horizontal && (0 === n[1] && (n[0] = i), n[1] = i - n[0] + 1, e[0] = i + 1), o.vertical && (0 === e[1] && (e[0] = i), e[1] = i - e[0] + 1)) } return { horizontalRange: n, verticalRange: e } } function Uo(t, r, i, o, a, n) { var e, s, u; void 0 === n && (n = [0, 0]); var c = t.indexOf("/"), l = (-1 < c ? t.slice(0, c) : t).length, f = t.slice(0, l), p = t.slice(l + 1), d = f[0], h = void 0 === d ? "0px" : d, v = f[1], g = void 0 === v ? h : v, m = f[2], b = void 0 === m ? h : m, x = f[3], E = void 0 === x ? g : x, y = p[0], S = void 0 === y ? h : y, M = p[1], w = void 0 === M ? S : M, D = p[2], C = void 0 === D ? S : D, R = p[3], O = void 0 === R ? w : R, P = [h, g, b, E].map(function (t) { return zt(t, r) }), _ = [S, w, C, O].map(function (t) { return zt(t, i) }), B = P.slice(), z = _.slice(), G = Yo([B[0], B[1]], r); B[0] = G[0], B[1] = G[1], e = Yo([B[3], B[2]], r), B[3] = e[0], B[2] = e[1], s = Yo([z[0], z[3]], i), z[0] = s[0], z[3] = s[1], u = Yo([z[1], z[2]], i), z[1] = u[0], z[2] = u[1]; var T = B.slice(0, Math.max(n[0], f.length)), k = z.slice(0, Math.max(n[1], p.length)); return Re(Re([], T.map(function (t, n) { var e = jo[n]; return { horizontal: qo[n], vertical: 0, pos: [o + t, a + (-1 === Lo[n] ? i : 0)], sub: !0, raw: P[n], direction: e } })), k.map(function (t, n) { var e = jo[n]; return { horizontal: 0, vertical: Lo[n], pos: [o + (-1 === qo[n] ? r : 0), a + t], sub: !0, raw: _[n], direction: e } })) } function $o(t, n, e, r, i) { void 0 === i && (i = n.length); var o = Vo(t.slice(r)), a = o.horizontalRange, s = o.verticalRange, u = e - r, c = 0; if (0 == u) c = i; else if (0 < u && u < a[1]) c = a[1] - u; else { if (!(u >= s[0])) return; c = s[0] + s[1] - u } t.splice(e, c), n.splice(e, c) } function Zo(t, n, e, r, i, o, a, s, u, c, l) { void 0 === c && (c = 0), void 0 === l && (l = 0); var f = Vo(t.slice(e)), p = f.horizontalRange, d = f.verticalRange; if (-1 < r) for (var h = 1 === qo[r] ? o - c : s - o, v = p[1]; v <= r; ++v) { var g = 1 === Lo[v] ? l : u, m = 0; if (r === v ? m = o : 0 === v ? m = c + h : -1 === qo[v] && (m = s - (n[e][0] - c)), t.splice(e + v, 0, { horizontal: qo[v], vertical: 0, pos: [m, g] }), n.splice(e + v, 0, [m, g]), 0 === v) break } else if (-1 < i) { var b, x = 1 === Lo[i] ? a - l : u - a; 0 === p[1] && 0 === d[1] && (b = [c + x, l], t.push({ horizontal: qo[0], vertical: 0, pos: b }), n.push(b)); for (var E = d[0], v = d[1]; v <= i; ++v) { m = 1 === qo[v] ? c : s, g = 0; if (i === v ? g = a : 0 === v ? g = l + x : 1 === Lo[v] ? g = n[e + E][1] : -1 === Lo[v] && (g = u - (n[e + E][1] - l)), t.push({ horizontal: 0, vertical: Lo[v], pos: [m, g] }), n.push([m, g]), 0 === v) break } } } function Ko(t, e) { return void 0 === e && (e = t.map(function (t) { return t.raw })), { horizontals: t.map(function (t, n) { return t.horizontal ? e[n] : null }).filter(function (t) { return null != t }), verticals: t.map(function (t, n) { return t.vertical ? e[n] : null }).filter(function (t) { return null != t }) } } var Jo = [[0, -1, "n"], [1, 0, "e"]], Qo = [[-1, -1, "nw"], [0, -1, "n"], [1, -1, "ne"], [1, 0, "e"], [1, 1, "se"], [0, 1, "s"], [-1, 1, "sw"], [-1, 0, "w"]]; function ta(t, n, e) { var r = t.props.clipRelative, i = t.state, o = i.width, a = i.height, s = n.type, u = n.poses, c = "rect" === s, l = "circle" === s; if ("polygon" === s) return e.map(function (t) { return vo(t[0], o, r) + " " + vo(t[1], a, r) }); if (c || "inset" === s) { var f = e[1][1], p = e[3][0], d = e[7][0], h = e[5][1]; if (c) return [f, p, h, d].map(function (t) { return t + "px" }); var v, g, m, b = [f, o - p, a - h, d].map(function (t, n) { return vo(t, n % 2 ? o : a, r) }); return 8 < e.length && (g = (v = Jt(e[4], e[0]))[0], m = v[1], b.push.apply(b, Re(["round"], Ho(e.slice(8), u.slice(8), r, g, m, d, f, p, h).styles))), b } if (l || "ellipse" === s) { var x = e[0], E = vo(Math.abs(e[1][1] - x[1]), l ? Math.sqrt((o * o + a * a) / 2) : a, r); return (b = l ? [E] : [vo(Math.abs(e[2][0] - x[0]), o, r), E]).push("at", vo(x[0], o, r), vo(x[1], a, r)), b } } function na(t, n, e, r) { var a = [r, (r + n) / 2, n], s = [t, (t + e) / 2, e]; return Qo.map(function (t) { var n = t[0], e = t[1], r = t[2], i = a[n + 1], o = s[e + 1]; return { vertical: Math.abs(e), horizontal: Math.abs(n), direction: r, pos: [i, o] } }) } function ea(t, i, o, n, e) { var r, a, s, u = e; if (u || (u = "none" !== (s = (a = so(t)).clipPath) ? s : a.clip), u && "none" !== u && "auto" !== u || (u = n)) { var c = wt(u), l = c.prefix, f = void 0 === l ? u : l, p = c.value, d = void 0 === p ? "" : p, h = "circle" === f, v = " "; if ("polygon" === f) { v = ","; return { type: f, clipText: u, poses: B = (P = Mt(d || "0% 0%, 100% 0%, 100% 100%, 0% 100%")).map(function (t) { var n = t.split(" "), e = n[0], r = n[1]; return { vertical: 1, horizontal: 1, pos: [zt(e, i), zt(r, o)] } }), splitter: v } } if (h || "ellipse" === f) { var g, m, b, x, E, y, S, M, w, D = "", C = "", R = 0, O = 0, P = St(d); O = h ? (m = "", m = void 0 === (g = P[0]) ? "50%" : g, D = void 0 === (b = P[2]) ? "50%" : b, C = void 0 === (x = P[3]) ? "50%" : x, R = zt(m, Math.sqrt((i * i + o * o) / 2))) : (M = y = "", y = void 0 === (E = P[0]) ? "50%" : E, M = void 0 === (S = P[1]) ? "50%" : S, D = void 0 === (w = P[3]) ? "50%" : w, C = void 0 === (r = P[4]) ? "50%" : r, R = zt(y, i), zt(M, o)); var _ = [zt(D, i), zt(C, o)], B = Re([{ vertical: 1, horizontal: 1, pos: _, direction: "nesw" }], Jo.slice(0, h ? 1 : 2).map(function (t) { return { vertical: Math.abs(t[1]), horizontal: t[0], direction: t[2], sub: !0, pos: [_[0] + t[0] * R, _[1] + t[1] * O] } })); return { type: f, clipText: u, radiusX: R, radiusY: O, left: _[0] - R, top: _[1] - O, poses: B, splitter: v } } if ("inset" === f) { var z = (P = St(d || "0 0 0 0")).indexOf("round"), G = (-1 < z ? P.slice(0, z) : P).length, T = P.slice(G + 1), k = P.slice(0, G), A = k[0], F = k[1], I = void 0 === F ? A : F, N = k[2], j = void 0 === N ? A : N, Y = k[3], X = void 0 === Y ? I : Y, W = [A, j].map(function (t) { return zt(t, o) }), q = W[0], L = W[1], H = [X, I].map(function (t) { return zt(t, i) }), V = H[0], U = H[1], $ = i - U, Z = o - L, K = Uo(T, $ - V, Z - q, V, q); return { type: "inset", clipText: u, poses: B = Re(Re([], na(q, $, Z, V)), K), top: q, left: V, right: $, bottom: Z, radius: T, splitter: v } } if ("rect" === f) { v = ","; var J = (P = Mt(d || "0px, " + i + "px, " + o + "px, 0px")).map(function (t) { return Dt(t).value }); return { type: "rect", clipText: u, poses: B = na(q = J[0], U = J[1], L = J[2], V = J[3]), top: q, right: U, bottom: L, left: V, values: P, splitter: v } } } } var ra = { name: "clippable", props: { clippable: Boolean, defaultClipPath: String, customClipPath: String, clipRelative: Boolean, clipArea: Boolean, dragWithClip: Boolean, clipTargetBounds: Boolean, clipVerticalGuidelines: Array, clipHorizontalGuidelines: Array, clipSnapThreshold: Boolean }, events: { onClipStart: "clipStart", onClip: "clip", onClipEnd: "clipEnd" }, css: [".control.clip-control {\n    background: #6d6;\n    cursor: pointer;\n}\n.control.clip-control.clip-radius {\n    background: #d66;\n}\n.line.clip-line {\n    background: #6e6;\n    cursor: move;\n    z-index: 1;\n}\n.clip-area {\n    position: absolute;\n    top: 0;\n    left: 0;\n}\n.clip-ellipse {\n    position: absolute;\n    cursor: move;\n    border: 1px solid #6d6;\n    border: var(--zoompx) solid #6d6;\n    border-radius: 50%;\n    transform-origin: 0px 0px;\n}", ":host {\n    --bounds-color: #d66;\n}", ".guideline {\n    pointer-events: none;\n    z-index: 2;\n}", ".line.guideline.bounds {\n    background: #d66;\n    background: var(--bounds-color);\n}"], render: function (t, s) { var n = t.props, e = n.customClipPath, r = n.defaultClipPath, i = n.clipArea, u = n.zoom, o = t.state, a = o.target, c = o.width, l = o.height, f = o.allMatrix, p = o.is3d, d = o.left, h = o.top, v = o.pos1, g = o.pos2, m = o.pos3, b = o.pos4, x = o.clipPathState, E = o.snapBoundInfos, y = o.rotation; if (!a) return []; var S = ea(a, c, l, r || "inset", x || e); if (!S) return []; var M, w, D, C, R, O, P = p ? 4 : 3, _ = S.type, B = S.poses.map(function (t) { var n = Ni(f, t.pos, P); return [n[0] - d, n[1] - h] }), z = [], G = [], T = "rect" === _, k = "inset" === _, A = "polygon" === _; if ((T || k || A) && (M = k ? B.slice(0, 8) : B, G = M.map(function (t, n) { var e = 0 === n ? M[M.length - 1] : M[n - 1], r = At(e, t), i = Li(e, t); return s.createElement("div", { key: "clipLine" + n, className: Ri("line", "clip-line", "snap-control"), "data-clip-index": n, style: { width: i + "px", transform: "translate(" + e[0] + "px, " + e[1] + "px) rotate(" + r + "rad) scaleY(" + u + ")" } }) })), z = B.map(function (t, n) { return s.createElement("div", { key: "clipControl" + n, className: Ri("control", "clip-control", "snap-control"), "data-clip-index": n, style: { transform: "translate(" + t[0] + "px, " + t[1] + "px) rotate(" + y + "rad) scale(" + u + ")" } }) }), k && z.push.apply(z, B.slice(8).map(function (t, n) { return s.createElement("div", { key: "clipRadiusControl" + n, className: Ri("control", "clip-control", "clip-radius", "snap-control"), "data-clip-index": 8 + n, style: { transform: "translate(" + t[0] + "px, " + t[1] + "px) rotate(" + y + "rad) scale(" + u + ")" } }) })), "circle" === _ || "ellipse" === _) { var F = S.left, I = S.top, N = S.radiusX, j = S.radiusY, Y = Jt(Ni(f, [F, I], P), Ni(f, [0, 0], P)), X = Y[0], W = Y[1], q = "none"; if (!i) { for (var L = Math.max(10, N / 5, j / 5), H = [], V = 0; V <= L; ++V) { var U = 2 * Math.PI / L * V; H.push([N + (N - u) * Math.cos(U), j + (j - u) * Math.sin(U)]) } H.push([N, -2]), H.push([-2, -2]), H.push([-2, 2 * j + 2]), H.push([2 * N + 2, 2 * j + 2]), H.push([2 * N + 2, -2]), H.push([N, -2]), q = "polygon(" + H.map(function (t) { return t[0] + "px " + t[1] + "px" }).join(", ") + ")" } z.push(s.createElement("div", { key: "clipEllipse", className: Ri("clip-ellipse", "snap-control"), style: { width: 2 * N + "px", height: 2 * j + "px", clipPath: q, transform: "translate(" + (-d + X) + "px, " + (-h + W) + "px) " + Fi(f) } })) } return i && (D = (w = Yi(Re([v, g, m, b], B))).width, C = w.height, R = w.left, O = w.top, (A || T || k) && (H = k ? B.slice(0, 8) : B, z.push(s.createElement("div", { key: "clipArea", className: Ri("clip-area", "snap-control"), style: { width: D + "px", height: C + "px", transform: "translate(" + R + "px, " + O + "px)", clipPath: "polygon(" + H.map(function (t) { return t[0] - R + "px " + (t[1] - O) + "px" }).join(", ") + ")" } })))), E && ["vertical", "horizontal"].forEach(function (o) { var t = E[o], a = "horizontal" === o; t.isSnap && G.push.apply(G, t.snap.posInfos.map(function (t, n) { var e = t.pos, r = Jt(Ni(f, a ? [0, e] : [e, 0], P), [d, h]), i = Jt(Ni(f, a ? [c, e] : [e, l], P), [d, h]); return Ke(s, "", r, i, u, "clip" + o + "snap" + n, "guideline") })), t.isBound && G.push.apply(G, t.bounds.map(function (t, n) { var e = t.pos, r = Jt(Ni(f, a ? [0, e] : [e, 0], P), [d, h]), i = Jt(Ni(f, a ? [c, e] : [e, l], P), [d, h]); return Ke(s, "", r, i, u, "clip" + o + "bounds" + n, "guideline", "bounds", "bold") })) }), Re(Re([], z), G) }, dragControlCondition: function (t, n) { return n.inputEvent && -1 < (n.inputEvent.target.getAttribute("class") || "").indexOf("clip") }, dragStart: function (t, n) { var e = t.props.dragWithClip; return void 0 !== e && !e && this.dragControlStart(t, n) }, drag: function (t, n) { return this.dragControl(t, n) }, dragEnd: function (t, n) { return this.dragControlEnd(t, n) }, dragControlStart: function (t, n) { var e = t.state, r = t.props, i = r.defaultClipPath, o = r.customClipPath, a = e.target, s = e.width, u = e.height, c = n.inputEvent ? n.inputEvent.target : null, l = c && c.getAttribute("class") || "", f = n.datas, p = ea(a, s, u, i || "inset", o); if (!p) return !1; var d = p.clipText; return !1 === ao(t, "onClipStart", ro(t, n, { clipType: p.type, clipStyle: d, poses: p.poses.map(function (t) { return t.pos }) })) ? f.isClipStart = !1 : (f.isControl = l && -1 < l.indexOf("clip-control"), f.isLine = -1 < l.indexOf("clip-line"), f.isArea = -1 < l.indexOf("clip-area") || -1 < l.indexOf("clip-ellipse"), f.index = c ? parseInt(c.getAttribute("data-clip-index"), 10) : -1, f.clipPath = p, f.isClipStart = !0, e.clipPathState = d, oi(t, n), !0) }, dragControl: function (t, n) { var e = n.datas, r = n.originalDatas; if (!e.isClipStart) return !1; var i = e.isControl, o = e.isLine, a = e.isArea, s = e.index, u = e.clipPath; if (!u) return !1; var c = li(n), l = c[0], f = c[1], p = t.props, d = t.state, h = d.width, v = d.height, g = !a && !i && !o, m = u.type, b = u.poses, x = u.splitter, E = b.map(function (t) { return t.pos }); g && (l = -l, f = -f); var y, S, M, w, D, C, R, O, P, _, B, z, G, T, k, A = !i || "nesw" === b[s].direction, F = "inset" === m || "rect" === m, I = b.map(function () { return [0, 0] }); i && !A ? (S = (y = b[s]).horizontal, M = y.vertical, w = [l * Math.abs(S), f * Math.abs(M)], R = w, O = F, B = (D = b)[C = s], z = B.direction, G = B.sub, T = D.map(function () { return [0, 0] }), k = z ? z.split("") : [], O && C < 8 ? (P = k.filter(function (t) { return "w" === t || "e" === t })[0], _ = k.filter(function (t) { return "n" === t || "s" === t })[0], T[C] = R, D.forEach(function (t, n) { var e = t.direction; e && (-1 < e.indexOf(P) && (T[n][0] = R[0]), -1 < e.indexOf(_) && (T[n][1] = R[1])) }), P && (T[1][0] = R[0] / 2, T[5][0] = R[0] / 2), _ && (T[3][1] = R[1] / 2, T[7][1] = R[1] / 2)) : z && !G ? k.forEach(function (o) { var a = "n" === o || "s" === o; D.forEach(function (t, n) { var e = t.direction, r = t.horizontal, i = t.vertical; e && -1 !== e.indexOf(o) && (T[n] = [a || !r ? 0 : R[0], a && i ? R[1] : 0]) }) }) : T[C] = R, I = T) : A && (I = E.map(function () { return [l, f] })); var N = E.map(function (t, n) { return Kt(t, I[n]) }), j = Re([], N); d.snapBoundInfos = null; var Y, X, W, q, L, H, V = "circle" === u.type, U = "ellipse" === u.type; (V || U) && (Y = Yi(N), X = Math.abs(Y.bottom - Y.top), W = Math.abs(U ? Y.right - Y.left : X), q = N[0][1] + X, L = N[0][0] - W, H = N[0][0] + W, V && (j.push([H, Y.bottom]), I.push([1, 0])), j.push([Y.left, q]), I.push([0, 1]), j.push([L, Y.bottom]), I.push([1, 0])); var $, Z = dr((p.clipHorizontalGuidelines || []).map(function (t) { return zt("" + t, v) }), (p.clipVerticalGuidelines || []).map(function (t) { return zt("" + t, h) }), h, v), K = [], J = []; J = V || U ? (K = [j[4][0], j[2][0]], [j[1][1], j[3][1]]) : F ? (nt = [j[0], j[2], j[4], j[6]], $ = [I[0], I[2], I[4], I[6]], K = nt.filter(function (t, n) { return $[n][0] }).map(function (t) { return t[0] }), nt.filter(function (t, n) { return $[n][1] }).map(function (t) { return t[1] })) : (K = j.filter(function (t, n) { return I[n][0] }).map(function (t) { return t[0] }), j.filter(function (t, n) { return I[n][1] }).map(function (t) { return t[1] })); for (var Q = [0, 0], tt = 0; tt < 2; ++tt) { if ("break" === function () { var t = Hr(Z, p.clipTargetBounds && { left: 0, top: 0, right: h, bottom: v }, K, J, 5), n = t.horizontal, e = t.vertical, r = n.offset, i = e.offset; if (n.isBound && (Q[1] += r), e.isBound && (Q[0] += i), !U && !V || 0 !== I[0][0] || 0 !== I[0][1]) return j.forEach(function (t, n) { var e = I[n]; e[0] && (t[0] -= i), e[1] && (t[1] -= r) }), "break"; var o = Yi(N), a = o.bottom - o.top, s = U ? o.right - o.left : a; s -= e.isBound ? Math.abs(i) : 0 === e.snapIndex ? -i : i, a -= n.isBound ? Math.abs(r) : 0 === n.snapIndex ? -r : r, V && (s = a = 0 < Sr(e, n) ? a : s); var u = j[0]; j[1][1] = u[1] - a, j[2][0] = u[0] + s, j[3][1] = u[1] + a, j[4][0] = u[0] - s }()) break } var nt, et, rt, it = ta(t, u, N), ot = m + "(" + it.join(x) + ")"; return d.clipPathState = ot, J = V || U ? (K = [j[4][0], j[2][0]], [j[1][1], j[3][1]]) : F ? (nt = [j[0], j[2], j[4], j[6]], K = nt.map(function (t) { return t[0] }), nt.map(function (t) { return t[1] })) : (K = j.map(function (t) { return t[0] }), j.map(function (t) { return t[1] })), d.snapBoundInfos = Hr(Z, p.clipTargetBounds && { left: 0, top: 0, right: h, bottom: v }, K, J, 1), r.draggable && (et = d.is3d ? 4 : 3, rt = Zt(d.allMatrix, [Q[0], Q[1], 0, 0], et), Q[0] = rt[0], Q[1] = rt[1], r.draggable.deltaOffset = Q), ao(t, "onClip", ro(t, n, { clipEventType: "changed", clipType: m, poses: N, clipStyle: ot, clipStyles: it, distX: l, distY: f })), !0 }, dragControlEnd: function (t, n) { this.unset(t); var e = n.isDrag, r = n.datas, i = n.isDouble, o = r.isLine, a = r.isClipStart, s = r.isControl; return !!a && (ao(t, "onClipEnd", io(t, n, {})), i && (s ? function (t, n) { var e = n.datas, r = e.clipPath, i = e.index, o = r.type, a = r.poses, s = r.splitter, u = a.map(function (t) { return t.pos }), c = u.length; if ("polygon" === o) a.splice(i, 1), u.splice(i, 1); else { if ("inset" !== o) return; if (i < 8) return; if ($o(a, u, i, 8, c), c === a.length) return } var l = ta(t, r, u); ao(t, "onClip", ro(t, n, { clipEventType: "removed", clipType: o, poses: u, clipStyles: l, clipStyle: o + "(" + l.join(s) + ")", distX: 0, distY: 0 })) }(t, n) : o && function (t, n) { var e = ii(t, n), r = e[0], i = e[1], o = n.datas, a = o.clipPath, s = o.index, u = a.type, c = a.poses, l = a.splitter, f = c.map(function (t) { return t.pos }); if ("polygon" === u) f.splice(s, 0, [r, i]); else { if ("inset" !== u) return; var p = Xo.indexOf(s), d = Wo.indexOf(s), h = c.length; if (Zo(c, f, 8, p, d, r, i, f[4][0], f[4][1], f[0][0], f[0][1]), h === c.length) return } var v = ta(t, a, f); ao(t, "onClip", ro(t, n, { clipEventType: "added", clipType: u, poses: f, clipStyles: v, clipStyle: u + "(" + v.join(l) + ")", distX: 0, distY: 0 })) }(t, n)), i || e) }, unset: function (t) { t.state.clipPathState = "", t.state.snapBoundInfos = null } }, ia = { name: "originDraggable", props: { originDraggable: Boolean, originRelative: Boolean }, events: { onDragOriginStart: "dragOriginStart", onDragOrigin: "dragOrigin", onDragOriginEnd: "dragOriginEnd" }, css: [":host[data-able-origindraggable] .control.origin {\n    pointer-events: auto;\n}"], dragControlCondition: function (t, n) { return n.isRequest ? "originDraggable" === n.requestAble : Yt(n.inputEvent.target, Ri("origin")) }, dragControlStart: function (t, n) { var e = n.datas; oi(t, n); var r = ro(t, n, { dragStart: ri.dragStart(t, (new He).dragStart([0, 0], n)) }), i = ao(t, "onDragOriginStart", r); return e.startOrigin = t.state.transformOrigin, e.startTargetOrigin = t.state.targetOrigin, e.prevOrigin = [0, 0], !(e.isDragOrigin = !0) === i ? e.isDragOrigin = !1 : r }, dragControl: function (t, n) { var e = n.datas, r = n.isPinch, i = n.isRequest; if (!e.isDragOrigin) return !1; var o, a = li(n), s = a[0], u = a[1], c = t.state, l = c.width, f = c.height, p = c.offsetMatrix, d = c.targetMatrix, h = c.is3d, v = t.props.originRelative, g = void 0 === v || v, m = h ? 4 : 3, b = [s, u]; !i || ((o = n.distOrigin)[0] || o[1]) && (b = o); var x = Kt(e.startOrigin, b), E = Kt(e.startTargetOrigin, b), y = Jt(b, e.prevOrigin), S = hi(p, d, x, m), M = t.getRect(), w = Yi(ji(S, l, f, m)), D = [M.left - w.left, M.top - w.top], C = ro(t, n, { width: l, height: f, origin: x, dist: e.prevOrigin = b, delta: y, transformOrigin: [vo(E[0], l, g), vo(E[1], f, g)].join(" "), drag: ri.drag(t, Le(n, t.state, D, !!r, !1)) }); return ao(t, "onDragOrigin", C), C }, dragControlEnd: function (t, n) { return !!n.datas.isDragOrigin && (ao(t, "onDragOriginEnd", io(t, n, {})), !0) }, dragGroupControlCondition: function (t, n) { return this.dragControlCondition(t, n) }, dragGroupControlStart: function (t, n) { return !!this.dragControlStart(t, n) }, dragGroupControl: function (t, n) { var e = this.dragControl(t, n); return !!e && (t.transformOrigin = e.transformOrigin, !0) }, request: function (t) { var n = {}, e = t.getRect(), r = 0, i = 0, o = e.transformOrigin, a = [0, 0]; return { isControl: !0, requestStart: function () { return { datas: n } }, request: function (t) { return "deltaOrigin" in t ? (a[0] += t.deltaOrigin[0], a[1] += t.deltaOrigin[1]) : "origin" in t ? (a[0] = t.origin[0] - o[0], a[1] = t.origin[1] - o[1]) : ("x" in t ? r = t.x - e.left : "deltaX" in t && (r += t.deltaX), "y" in t ? i = t.y - e.top : "deltaY" in t && (i += t.deltaY)), { datas: n, distX: r, distY: i, distOrigin: a } }, requestEnd: function () { return { datas: n, isDrag: !0 } } } } }; function oa(t, n, e, r, i) { void 0 === r && (r = [0, 0]); var o, a; return Uo(!(a = i || ((o = so(t)) && o.borderRadius || "")) || !i && "0px" === a ? [] : St(a), n, e, 0, 0, r) } function aa(t, n, e, r, i, o) { var a = t.state, s = a.width, u = a.height, c = Ho(o, i, t.props.roundRelative, s, u), l = c.raws, f = c.styles, p = Ko(i, l), d = p.horizontals, h = p.verticals, v = f.join(" "); ao(t, "onRound", ro(t, n, { horizontals: d, verticals: h, borderRadius: a.borderRadiusState = v, width: s, height: u, delta: r, dist: e })) } var sa = { name: "roundable", props: { roundable: Boolean, roundRelative: Boolean, minRoundControls: Array, maxRoundControls: Array, roundClickable: Boolean }, events: { onRoundStart: "roundStart", onRound: "round", onRoundEnd: "roundEnd" }, css: [".control.border-radius {\n    background: #d66;\n    cursor: pointer;\n}", ":host[data-able-roundable] .line.direction {\n    cursor: pointer;\n}"], render: function (t, i) { var n = t.state, e = n.target, r = n.width, o = n.height, a = n.allMatrix, s = n.is3d, u = n.left, c = n.top, l = n.borderRadiusState, f = t.props, p = f.minRoundControls, d = void 0 === p ? [0, 0] : p, h = f.maxRoundControls, v = void 0 === h ? [4, 4] : h, g = f.zoom; if (!e) return null; var m = s ? 4 : 3, b = oa(e, r, o, d, l); if (!b) return null; var x = 0, E = 0; return b.map(function (t, n) { E += Math.abs(t.horizontal), x += Math.abs(t.vertical); var e = Jt(Ni(a, t.pos, m), [u, c]), r = t.vertical ? x <= v[1] : E <= v[0]; return i.createElement("div", { key: "borderRadiusControl" + n, className: Ri("control", "border-radius"), "data-radius-index": n, style: { display: r ? "block" : "none", transform: "translate(" + e[0] + "px, " + e[1] + "px) scale(" + g + ")" } }) }) }, dragControlCondition: function (t, n) { if (!n.inputEvent || n.isRequest) return !1; var e = n.inputEvent.target.getAttribute("class") || ""; return -1 < e.indexOf("border-radius") || -1 < e.indexOf("moveable-line") && -1 < e.indexOf("moveable-direction") }, dragControlStart: function (t, n) { var e = n.inputEvent, r = n.datas, i = e.target, o = i.getAttribute("class") || "", a = -1 < o.indexOf("border-radius"), s = -1 < o.indexOf("moveable-line") && -1 < o.indexOf("moveable-direction"), u = a ? parseInt(i.getAttribute("data-radius-index"), 10) : -1, c = s ? parseInt(i.getAttribute("data-line-index"), 10) : -1; if (!a && !s) return !1; if (!1 === ao(t, "onRoundStart", ro(t, n, {}))) return !1; r.lineIndex = c, r.controlIndex = u, r.isControl = a, r.isLine = s, oi(t, n); var l = t.props, f = l.roundRelative, p = l.minRoundControls, d = void 0 === p ? [0, 0] : p, h = t.state, v = h.target, g = h.width, m = h.height; r.isRound = !0, r.prevDist = [0, 0]; var b = oa(v, g, m, d) || []; return r.controlPoses = b, h.borderRadiusState = Ho(b.map(function (t) { return t.pos }), b, f, g, m).styles.join(" "), !0 }, dragControl: function (t, n) { var e = n.datas; if (!e.isRound || !e.isControl || !e.controlPoses.length) return !1; var r = e.controlIndex, i = e.controlPoses, o = li(n), a = o[0], s = o[1], u = [a, s], c = Jt(u, e.prevDist), l = t.props.maxRoundControls, f = void 0 === l ? [4, 4] : l, p = t.state, d = p.width, h = p.height, v = i[r], g = v.vertical, m = v.horizontal, b = i.map(function (t) { var n = t.horizontal, e = t.vertical, r = [n * m * u[0], e * g * u[1]]; if (n) { if (1 === f[0]) return r; if (f[0] < 4 && n !== m) return r } else { if (0 === f[1]) return r[1] = e * m * u[0] / d * h, r; if (g) { if (1 === f[1]) return r; if (f[1] < 4 && e !== g) return r } } return [0, 0] }); b[r] = u; var x = i.map(function (t, n) { return Kt(t.pos, b[n]) }); return e.prevDist = [a, s], aa(t, n, u, c, i, x), !0 }, dragControlEnd: function (t, n) { var e = t.state; e.borderRadiusState = ""; var r = n.datas, i = n.isDouble; if (!r.isRound) return !1; var o, a, s, u, c, l, f, p, d, h, v, g, m, b, x, E, y, S = e.width, M = e.height, w = r.isControl, D = r.controlIndex, C = r.isLine, R = r.lineIndex, O = r.controlPoses, P = O.map(function (t) { return t.pos }), _ = P.length, B = t.props.roundClickable; return i && (void 0 === B || B) && (w ? $o(O, P, D, 0) : C && (a = (o = ii(t, n))[0], s = o[1], c = P, l = R, f = a, p = s, d = S, h = M, v = Ko(u = O), g = v.horizontals, m = v.verticals, b = g.length, x = m.length, y = E = -1, 0 === l ? 0 === b ? E = 0 : 1 === b && (E = 1) : 3 === l && (b <= 2 ? E = 2 : b <= 3 && (E = 3)), 2 === l ? 0 === x ? y = 0 : x < 4 && (y = 3) : 1 === l && (x <= 1 ? y = 1 : x <= 2 && (y = 2)), Zo(u, c, 0, E, y, f, p, d, h)), _ !== O.length && aa(t, n, [0, 0], [0, 0], O, P)), ao(t, "onRoundEnd", io(t, n, {})), !(e.borderRadiusState = "") }, unset: function (t) { t.state.borderRadiusState = "" } }; var ua = { isPinch: !0, name: "beforeRenderable", props: {}, events: { onBeforeRenderStart: "beforeRenderStart", onBeforeRender: "beforeRender", onBeforeRenderEnd: "beforeRenderEnd", onBeforeRenderGroupStart: "beforeRenderGroupStart", onBeforeRenderGroup: "beforeRenderGroup", onBeforeRenderGroupEnd: "beforeRenderGroupEnd" }, dragRelation: "weak", setTransform: function (t, n) { var e, r = t.state, i = r.is3d, o = r.target, a = r.targetMatrix, s = null == o ? void 0 : o.style.transform, u = i ? "matrix3d(" + a.join(",") + ")" : "matrix(" + Qt(a, !0) + ")", c = s && "none" !== s ? s : u; n.datas.startTransforms = (e = c) === (i ? "matrix3d(" + ln(4) : "matrix(" + ln(3) + ")") || "matrix(1,0,0,1,0,0)" === e ? [] : St(c) }, resetTransform: function (t) { t.datas.nextTransforms = t.datas.startTransforms, t.datas.nextTransformAppendedIndexes = [] }, fillDragStartParams: function (t, n) { return ro(t, n, { setTransform: function (t) { n.datas.startTransforms = gt(t) ? t : St(t) }, isPinch: !!n.isPinch }) }, fillDragParams: function (t, n) { return ro(t, n, { isPinch: !!n.isPinch }) }, dragStart: function (t, n) { this.setTransform(t, n), ao(t, "onBeforeRenderStart", this.fillDragStartParams(t, n)) }, drag: function (t, n) { this.resetTransform(n), ao(t, "onBeforeRender", ro(t, n, { isPinch: !!n.isPinch })) }, dragEnd: function (t, n) { ao(t, "onBeforeRenderEnd", ro(t, n, { isPinch: !!n.isPinch, isDrag: n.isDrag })) }, dragGroupStart: function (t, n) { var r = this; this.dragStart(t, n); var e = Ve(t, "beforeRenderable", n), i = t.moveables, o = e.map(function (t, n) { var e = i[n]; return r.setTransform(e, t), r.fillDragStartParams(e, t) }); ao(t, "onBeforeRenderGroupStart", ro(t, n, { isPinch: !!n.isPinch, targets: t.props.targets, setTransform: function () { }, events: o })) }, dragGroup: function (t, n) { var r = this; this.drag(t, n); var e = Ve(t, "beforeRenderable", n), i = t.moveables, o = e.map(function (t, n) { var e = i[n]; return r.resetTransform(t), r.fillDragParams(e, t) }); ao(t, "onBeforeRenderGroup", ro(t, n, { isPinch: !!n.isPinch, targets: t.props.targets, events: o })) }, dragGroupEnd: function (t, n) { this.dragEnd(t, n), ao(t, "onBeforeRenderGroupEnd", ro(t, n, { isPinch: !!n.isPinch, isDrag: n.isDrag, targets: t.props.targets })) }, dragControlStart: function (t, n) { return this.dragStart(t, n) }, dragControl: function (t, n) { return this.drag(t, n) }, dragControlEnd: function (t, n) { return this.dragEnd(t, n) }, dragGroupControlStart: function (t, n) { return this.dragGroupStart(t, n) }, dragGroupControl: function (t, n) { return this.dragGroup(t, n) }, dragGroupControlEnd: function (t, n) { return this.dragGroupEnd(t, n) } }, ca = { name: "renderable", props: {}, events: { onRenderStart: "renderStart", onRender: "render", onRenderEnd: "renderEnd", onRenderGroupStart: "renderGroupStart", onRenderGroup: "renderGroup", onRenderGroupEnd: "renderGroupEnd" }, dragRelation: "weak", dragStart: function (t, n) { ao(t, "onRenderStart", ro(t, n, { isPinch: !!n.isPinch })) }, drag: function (t, n) { ao(t, "onRender", this.fillDragParams(t, n)) }, dragAfter: function (t, n) { if (n.resultCount) return this.drag(t, n) }, dragEnd: function (t, n) { ao(t, "onRenderEnd", this.fillDragEndParams(t, n)) }, dragGroupStart: function (t, n) { ao(t, "onRenderGroupStart", ro(t, n, { isPinch: !!n.isPinch, targets: t.props.targets })) }, dragGroup: function (t, n) { var r = this, e = Ve(t, "beforeRenderable", n), i = t.moveables, o = e.map(function (t, n) { var e = i[n]; return r.fillDragParams(e, t) }); ao(t, "onRenderGroup", ro(t, n, { isPinch: !!n.isPinch, targets: t.props.targets, transform: Ei(n), events: o })) }, dragGroupEnd: function (t, n) { var r = this, e = Ve(t, "beforeRenderable", n), i = t.moveables, o = e.map(function (t, n) { var e = i[n]; return r.fillDragEndParams(e, t) }); ao(t, "onRenderGroupEnd", ro(t, n, { isPinch: !!n.isPinch, isDrag: n.isDrag, targets: t.props.targets, events: o })) }, dragControlStart: function (t, n) { return this.dragStart(t, n) }, dragControl: function (t, n) { return this.drag(t, n) }, dragControlAfter: function (t, n) { return this.dragAfter(t, n) }, dragControlEnd: function (t, n) { return this.dragEnd(t, n) }, dragGroupControlStart: function (t, n) { return this.dragGroupStart(t, n) }, dragGroupControl: function (t, n) { return this.dragGroup(t, n) }, dragGroupControlEnd: function (t, n) { return this.dragGroupEnd(t, n) }, fillDragParams: function (t, n) { return ro(t, n, { isPinch: !!n.isPinch, transform: Ei(n) }) }, fillDragEndParams: function (t, n) { return ro(t, n, { isPinch: !!n.isPinch, isDrag: n.isDrag }) } }; function la(i, t, n, e, r, o, a) { var s = "Start" === r, u = i.state.target, c = o.isRequest; if (!u || s && -1 < e.indexOf("Control") && !c && i.areaElement === o.inputEvent.target) return !1; var l = "" + n + e + r, f = "" + n + e + "Condition", p = "End" === r, d = "After" === r, h = !(!s || i.targetGesto && i.controlGesto && i.targetGesto.isFlag() && i.controlGesto.isFlag()); h && i.updateRect(r, !0, !1), "" !== r || c || po(i.state, o); var v, g = Re([], i[t]); if (c && (v = o.requestAble, g.some(function (t) { return t.name === v }) || g.push.apply(g, i.props.ables.filter(function (t) { return t.name === v }))), !g.length) return !1; var m = Re(Re([ua], g), [ca]).filter(function (t) { return t[l] }), b = o.datas; h && m.forEach(function (t) { t.unset && t.unset(i) }); var x, E = o.inputEvent; p && E && (x = document.elementFromPoint(o.clientX, o.clientY) || E.target); var y = 0, S = m.filter(function (t) { var n = t.name, e = b[n] || (b[n] = {}); if (s && (e.isEventStart = !t[f] || t[f](i, o)), e.isEventStart) { var r = t[l](i, Ce(Ce({}, o), { resultCount: y, datas: e, originalDatas: b, inputTarget: x })); return i._emitter.off(), s && !1 === r && (e.isEventStart = !1), y += r ? 1 : 0, r } return !1 }).length, M = !1; return s && m.length && !S && (M = 0 === m.filter(function (t) { var n = t.name, e = b[n]; return !!e.isEventStart && ("strong" !== t.dragRelation || (e.isEventStart = !1)) }).length), (p || M) && (i.state.gesto = null, i.moveables && i.moveables.forEach(function (t) { t.state.gesto = null })), h && M && m.forEach(function (t) { t.unset && t.unset(i) }), s && !c && S && null != o && o.preventDefault(), !i.isUnmounted && !M && ((!s && S && !a || p) && (i.updateRect(p ? r : "", !0, !1), i.forceUpdate()), s || p || d || !S || a || la(i, t, n, e, r + "After", o), !0) } function fa(e, t, n) { var r = e.controlBox.getElement(), i = []; i.push(r), e.props.dragArea && !e.props.dragTarget || i.push(t); function o(t) { var n = t.inputEvent.target; return n === e.areaElement || !e.isMoveableElement(n) && !e.controlBox.getElement().contains(n) || Yt(n, "moveable-area") || Yt(n, "moveable-padding") } return pa(e, i, "targetAbles", n, { dragStart: o, pinchStart: o }) } function pa(i, t, o, a, s) { void 0 === s && (s = {}); var n = i.props, e = n.pinchOutside, r = n.pinchThreshold, u = { preventDefault: !1, container: window, pinchThreshold: r, pinchOutside: e }, c = new se(t, u); return ["drag", "pinch"].forEach(function (r) { ["Start", "", "End"].forEach(function (e) { c.on("" + r + e, function (t) { var n = t.eventType; (!s[n] || s[n](t)) && la(i, o, r, a, e, t) || t.stop() }) }) }), c } var da = function () { function t(t, n, e) { var i = this; this.target = t, this.moveable = n, this.eventName = e, this.ables = [], this.onEvent = function (n) { var e = i.eventName, r = i.moveable; r.state.disableNativeEvent || i.ables.forEach(function (t) { t[e](r, { inputEvent: n }) }) }, this.target.addEventListener(this.eventName.toLowerCase(), this.onEvent) } var n = t.prototype; return n.setAbles = function (t) { this.ables = t }, n.destroy = function () { this.target.removeEventListener(this.eventName.toLowerCase(), this.onEvent), this.target = null, this.moveable = null }, t }(), ha = function (t) { function n() { var n = null !== t && t.apply(this, arguments) || this; return n.state = Ce({ container: null, gesto: null, renderPoses: [[0, 0], [0, 0], [0, 0], [0, 0]], disableNativeEvent: !1 }, Zi(null)), n.enabledAbles = [], n.targetAbles = [], n.controlAbles = [], n.rotation = 0, n.scale = [1, 1], n.isUnmounted = !1, n.events = { mouseEnter: null, mouseLeave: null }, n._emitter = new Me, n._prevTarget = null, n._prevDragArea = !1, n._observer = null, n._observerId = 0, n.onPreventClick = function (t) { t.stopPropagation(), Xt(window, "click", n.onPreventClick, !0) }, n.checkUpdateRect = function () { var t; n.isDragging() || ((t = n.props.parentMoveable) ? t.checkUpdateRect() : (_t(n._observerId), n._observerId = Pt(function () { n.isDragging() || n.updateRect() }))) }, n } De(n, t); var e = n.prototype; return e.render = function () { var t = this.props, n = this.state, e = t.parentPosition, r = t.className, i = t.target, o = t.zoom, a = t.cspNonce, s = t.translateZ, u = t.cssStyled, c = t.portalContainer; this.checkUpdate(), this.updateRenderPoses(); var l = e || { left: 0, top: 0 }, f = l.left, p = l.top, d = n.left, h = n.top, v = n.target, g = n.direction, m = t.targets, b = (m && m.length || i) && v, x = this.isDragging(), E = {}; return this.getEnabledAbles().forEach(function (t) { E["data-able-" + t.name.toLowerCase()] = !0 }), _(u, Ce({ cspNonce: a, ref: y(this, "controlBox"), className: Ri("control-box", -1 === g ? "reverse" : "", x ? "dragging" : "") + " " + r }, E, { onClick: this.onPreventClick, portalContainer: c, style: { position: "absolute", display: b ? "block" : "none", transform: "translate3d(" + (d - f) + "px, " + (h - p) + "px, " + s + ")", "--zoom": o, "--zoompx": o + "px" } }), this.renderAbles(), this._renderLines()) }, e.componentDidMount = function () { this.isUnmounted = !1, this.controlBox.getElement(); var t = this.props, n = t.parentMoveable, e = t.container, r = t.wrapperMoveable; this._updateTargets(), this._updateNativeEvents(), this._updateEvents(), e || n || r || this.updateRect("", !1, !0), this.updateCheckInput(), this._updateObserver(this.props) }, e.componentDidUpdate = function (t) { this._updateNativeEvents(), this._updateEvents(), this._updateTargets(), this.updateCheckInput(), this._updateObserver(t) }, e.componentWillUnmount = function () { this.isUnmounted = !0, this._emitter.off(), eo(this, "targetGesto"), eo(this, "controlGesto"); var t = this.events; for (var n in t) { var e = t[n]; e && e.destroy() } }, e.getContainer = function () { var t = this.props, n = t.parentMoveable, e = t.wrapperMoveable; return t.container || e && e.getContainer() || n && n.getContainer() || this.controlBox.getElement().parentElement }, e.isMoveableElement = function (t) { return t && -1 < (t.getAttribute("class") || "").indexOf(Te) }, e.dragStart = function (t) { var n = this.targetGesto; return n && !n.isFlag() && n.triggerDragStart(t), this }, e.hitTest = function (t) { var n, e, r = this.state, i = r.target, o = r.pos1, a = r.pos2, s = r.pos3, u = r.pos4, c = r.targetClientRect; if (!i) return 0; var l = (e = t instanceof Element ? { left: (n = t.getBoundingClientRect()).left, top: n.top, width: n.width, height: n.height } : Ce({ width: 0, height: 0 }, t)).left, f = e.top, p = e.width, d = e.height, h = Gn([o, a, u, s], c), v = jn(h, [[l, f], [l + p, f], [l + p, f + d], [l, f + d]]), g = zn(h); return v && g ? Math.min(100, v / g * 100) : 0 }, e.isInside = function (t, n) { var e = this.state, r = e.target, i = e.pos1, o = e.pos2, a = e.pos3, s = e.pos4, u = e.targetClientRect; return !!r && kn([t, n], Gn([i, o, s, a], u)) }, e.updateRect = function (t, n, e) { void 0 === e && (e = !0); var r = this.props, i = r.parentMoveable, o = this.state.target || this.props.target, a = this.getContainer(), s = i ? i.props.rootContainer : r.rootContainer; this.updateState(Zi(this.controlBox && this.controlBox.getElement(), o, a, a, s || a), !i && e) }, e.isDragging = function () { return !!this.targetGesto && this.targetGesto.isFlag() || !!this.controlGesto && this.controlGesto.isFlag() }, e.updateTarget = function (t) { this.updateRect(t, !0) }, e.getRect = function () { var t = this.state, n = no(this.state), e = n[0], r = n[1], i = n[2], o = n[3], a = Yi(n), s = t.width, u = t.height, c = a.width, l = a.height, f = a.left, p = a.top, d = [t.left, t.top], h = Kt(d, t.origin); return { width: c, height: l, left: f, top: p, pos1: e, pos2: r, pos3: i, pos4: o, offsetWidth: s, offsetHeight: u, beforeOrigin: Kt(d, t.beforeOrigin), origin: h, transformOrigin: t.transformOrigin, rotation: this.getRotation() } }, e.getManager = function () { return this }, e.getRotation = function () { var t, n, e = this.state, r = e.pos1, i = e.pos2, o = e.direction; return t = o, n = At(r, i) / Math.PI * 180, n = 0 <= (n = 0 <= t ? n : 180 - n) ? n : 360 + n }, e.request = function (n, t, e) { void 0 === t && (t = {}); var r = this.props, i = r.ables, o = r.groupable, a = i.filter(function (t) { return t.name === n })[0]; if (this.isDragging() || !a || !a.request) return { request: function () { return this }, requestEnd: function () { return this } }; var s = this, u = a.request(this), c = e || t.isInstant, l = u.isControl ? "controlAbles" : "targetAbles", f = (o ? "Group" : "") + (u.isControl ? "Control" : ""), p = { request: function (t) { return la(s, l, "drag", f, "", Ce(Ce({}, u.request(t)), { requestAble: n, isRequest: !0 }), c), this }, requestEnd: function () { return la(s, l, "drag", f, "End", Ce(Ce({}, u.requestEnd()), { requestAble: n, isRequest: !0 }), c), this } }; return la(s, l, "drag", f, "Start", Ce(Ce({}, u.requestStart(t)), { requestAble: n, isRequest: !0 }), c), c ? p.request(t).requestEnd() : p }, e.destroy = function () { this.componentWillUnmount() }, e.updateRenderPoses = function () { var t = this.state, n = this.props, e = t.originalBeforeOrigin, r = t.transformOrigin, i = t.allMatrix, o = t.is3d, a = t.pos1, s = t.pos2, u = t.pos3, c = t.pos4, l = t.left, f = t.top, p = n.padding || {}, d = p.left, h = void 0 === d ? 0 : d, v = p.top, g = void 0 === v ? 0 : v, m = p.bottom, b = void 0 === m ? 0 : m, x = p.right, E = void 0 === x ? 0 : x, y = o ? 4 : 3, S = n.groupable ? e : Kt(e, [l, f]); t.renderPoses = [Kt(a, ho(i, [-h, -g], r, S, y)), Kt(s, ho(i, [E, -g], r, S, y)), Kt(u, ho(i, [-h, b], r, S, y)), Kt(c, ho(i, [E, b], r, S, y))] }, e.checkUpdate = function () { var t, n = this.props, e = n.target, r = n.container, i = n.parentMoveable, o = this.state, a = o.target, s = o.container; (a || e) && (this.updateAbles(), co(a, e) && co(s, r) || ((t = r || this.controlBox) && this.unsetAbles(), this.updateState({ target: e, container: r }), !i && t && this.updateRect("End", !1, !1))) }, e.triggerEvent = function (t, n) { this._emitter.trigger(t, n); var e = this.props[t]; return e && e(n) }, e.useCSS = function (t, n) { var e = this.props.customStyledMap, r = t + n; return e[r] || (e[r] = ye(t, n)), e[r] }, e.unsetAbles = function () { var n = this; this.targetAbles.forEach(function (t) { t.unset && t.unset(n) }) }, e.updateAbles = function (t, n) { void 0 === t && (t = this.props.ables), void 0 === n && (n = ""); var e = this.props, r = e.triggerAblesSimultaneously, i = t.filter(function (t) { return t && (t.always && !1 !== e[t.name] || e[t.name]) }), o = "drag" + n + "ControlStart", a = uo(i, ["drag" + n + "Start", "pinch" + n + "Start"], r), s = uo(i, [o], r); this.enabledAbles = i, this.targetAbles = a, this.controlAbles = s }, e.updateState = function (t, n) { if (n) { if (this.isUnmounted) return; this.setState(t) } else { var e = this.state; for (var r in t) e[r] = t[r] } }, e.getEnabledAbles = function () { var n = this.props; return n.ables.filter(function (t) { return t && n[t.name] }) }, e.renderAbles = function () { var i, o, a, s, t, n = this, e = this.props.triggerAblesSimultaneously, r = { createElement: _ }; return t = uo(this.getEnabledAbles(), ["render"], e).map(function (t) { return (0, t.render)(n, r) || [] }), i = t.reduce(function (t, n) { return t.concat(n) }, []).filter(function (t) { return t }), o = function (t) { return t.key }, a = [], s = {}, i.forEach(function (t, n) { var e = o(t, n, i), r = s[e]; r || (r = [], s[e] = r, a.push(r)), r.push(t) }), a.map(function (t) { return t[0] }) }, e.updateCheckInput = function () { this.targetGesto && (this.targetGesto.options.checkInput = this.props.checkInput) }, e._updateObserver = function (t) { var n, e, r = this.props, i = r.target; window.ResizeObserver && i && r.useResizeObserver ? t.target === i && this._observer || ((e = new ResizeObserver(this.checkUpdateRect)).observe(i, { box: "border-box" }), this._observer = e) : null !== (n = this._observer) && void 0 !== n && n.disconnect() }, e._updateEvents = function () { var t = this.controlBox.getElement(), n = this.targetAbles.length, e = this.controlAbles.length, r = this.props, i = r.dragTarget || r.target; (!n && this.targetGesto || this._isTargetChanged(!0)) && (eo(this, "targetGesto"), this.updateState({ gesto: null })), e || eo(this, "controlGesto"), i && n && !this.targetGesto && (this.targetGesto = fa(this, i, "")), !this.controlGesto && e && (this.controlGesto = pa(this, t, "controlAbles", "Control")) }, e._updateTargets = function () { var t = this.props; this._prevTarget = t.dragTarget || t.target, this._prevDragArea = t.dragArea }, e._renderLines = function () { var t = this.props, n = t.edge, e = t.zoom; if (t.hideDefaultLines) return []; var r = this.state.renderPoses, i = { createElement: _ }; return [Ke(i, n ? "n" : "", r[0], r[1], e, 0), Ke(i, n ? "e" : "", r[1], r[3], e, 1), Ke(i, n ? "w" : "", r[0], r[2], e, 2), Ke(i, n ? "s" : "", r[2], r[3], e, 3)] }, e._isTargetChanged = function (t) { var n = this.props, e = n.dragTarget || n.target, r = this._prevTarget, i = this._prevDragArea, o = n.dragArea; return !o && r !== e || (t || o) && i !== o }, e._updateNativeEvents = function () { var i, o = this, a = this.props.dragArea ? this.areaElement : this.state.target, s = this.events, t = Bt(s); if (this._isTargetChanged()) for (var n in s) { var e = s[n]; e && e.destroy(), s[n] = null } a && (i = this.enabledAbles, t.forEach(function (t) { var n = uo(i, [t]), e = 0 < n.length, r = s[t]; e ? (r || (r = new da(a, o, t), s[t] = r), r.setAbles(n)) : r && (r.destroy(), s[t] = null) })) }, n.defaultProps = { target: null, dragTarget: null, container: null, rootContainer: null, origin: !0, edge: !1, parentMoveable: null, wrapperMoveable: null, parentPosition: null, portalContainer: null, useResizeObserver: !1, ables: [], pinchThreshold: 20, dragArea: !1, passDragArea: !1, transformOrigin: "", className: "", zoom: 1, triggerAblesSimultaneously: !1, padding: {}, pinchOutside: !0, checkInput: !1, groupable: !1, hideDefaultLines: !1, cspNonce: "", translateZ: 0, cssStyled: null, customStyledMap: {}, props: {} }, n }(Y), va = { name: "groupable", props: { defaultGroupRotate: Number, defaultGroupOrigin: String, groupable: Boolean }, events: {}, render: function (e, r) { var t = e.props.targets || []; e.moveables = []; var n = e.state, i = { left: n.left, top: n.top }, o = e.props; return t.map(function (t, n) { return r.createElement(ha, { key: "moveable" + n, ref: a(e, "moveables", n), target: t, origin: !1, cssStyled: o.cssStyled, customStyledMap: o.customStyledMap, useResizeObserver: o.useResizeObserver, parentMoveable: e, parentPosition: i }) }) } }, ga = Oe("clickable", { props: { clickable: Boolean }, events: { onClick: "click", onClickGroup: "clickGroup" }, always: !0, dragRelation: "weak", dragStart: function (t, n) { var e, r, i, o; n.isRequest || (e = window, r = "click", i = t.onPreventClick, o = !0, e.addEventListener(r, i, o)) }, dragControlStart: function (t, n) { this.dragStart(t, n) }, dragGroupStart: function (t, n) { this.dragStart(t, n), n.datas.inputTarget = n.inputEvent && n.inputEvent.target }, dragEnd: function (t, n) { this.endEvent(t); var e, r = t.state.target, i = n.inputEvent, o = n.inputTarget, a = !t.isMoveableElement(o) && t.controlBox.getElement().contains(o); n.isDrag && !a || this.unset(t), !i || !o || n.isDrag || t.isMoveableElement(o) || a || (e = r.contains(o), ao(t, "onClick", ro(t, n, { isDouble: n.isDouble, inputTarget: o, isTarget: r === o, containsTarget: e }))) }, dragGroupEnd: function (t, n) { this.endEvent(t); var e, r, i, o, a = n.inputEvent, s = n.inputTarget; a && s && !n.isDrag && !t.isMoveableElement(s) && n.datas.inputTarget !== s && (i = -1 < (r = (e = t.props.targets).indexOf(s)), o = !1, -1 === r && (o = -1 < (r = Rt(e, function (t) { return t.contains(s) }))), ao(t, "onClickGroup", ro(t, n, { isDouble: n.isDouble, targets: e, inputTarget: s, targetIndex: r, isTarget: i, containsTarget: o }))) }, dragControlEnd: function (t, n) { this.dragEnd(t, n) }, dragGroupControlEnd: function (t, n) { this.dragEnd(t, n) }, endEvent: function (t) { var n = this; Pt(function () { n.unset(t) }) }, unset: function (t) { Xt(window, "click", t.onPreventClick, !0) } }); function ma(t) { var n = t.originalDatas.draggable; return n || (t.originalDatas.draggable = {}, n = t.originalDatas.draggable), Ce(Ce({}, t), { datas: n }) } var ba = Oe("edgeDraggable", { dragControlCondition: function (t, n) { if (!t.props.edgeDraggable || !n.inputEvent) return !1; var e = n.inputEvent.target; return Yt(e, Ri("direction")) && Yt(e, Ri("line")) }, dragControlStart: function (t, n) { return ri.dragStart(t, ma(n)) }, dragControl: function (t, n) { return ri.drag(t, ma(n)) }, dragControlEnd: function (t, n) { return ri.dragEnd(t, ma(n)) }, dragGroupControlCondition: function (t, n) { if (!t.props.edgeDraggable || !n.inputEvent) return !1; var e = n.inputEvent.target; return Yt(e, Ri("direction")) && Yt(e, Ri("line")) }, dragGroupControlStart: function (t, n) { return ri.dragGroupStart(t, ma(n)) }, dragGroupControl: function (t, n) { return ri.dragGroup(t, ma(n)) }, dragGroupControlEnd: function (t, n) { return ri.dragGroupEnd(t, ma(n)) }, unset: function (t) { return ri.unset(t) } }), xa = { name: "individualGroupable", props: { individualGroupable: Boolean }, events: {} }, Ea = [ua, Io, ei, Mo, ri, ba, or, wo, Do, Oo, Fo, No, ko, ia, ra, sa, va, xa, ga, To, ca], ya = Ea.reduce(function (t, n) { return Ce(Ce({}, t), "events" in n ? n.events : {}) }, {}), Sa = Ea.reduce(function (t, n) { return Ce(Ce({}, t), n.props) }, {}), Ma = bo(ya), wa = Object.keys(Ma), Da = Object.keys(Sa); function Ca(t, o) { return Math.max.apply(Math, t.map(function (t) { var n = t[0], e = t[1], r = t[2], i = t[3]; return Math.max(n[o], e[o], r[o], i[o]) })) } function Ra(t, o) { return Math.min.apply(Math, t.map(function (t) { var n = t[0], e = t[1], r = t[2], i = t[3]; return Math.min(n[o], e[o], r[o], i[o]) })) } var Oa = function (r) { function t() { var t = null !== r && r.apply(this, arguments) || this; return t.differ = new Cn, t.moveables = [], t.transformOrigin = "50% 50%", t } De(t, r); var n = t.prototype; return n.checkUpdate = function () { this.updateAbles() }, n.updateRect = function (n, t, e) { var r, i, o, a, s, u, c, l, f, p, d, h, v, g, m, b, x, E, y, S, M, w, D; void 0 === e && (e = !0), this.controlBox && (this.moveables.forEach(function (t) { t.updateRect(n, !1, !1) }), r = this.state, i = this.props, o = r.target || i.target, (!t || "" !== n && i.updateGroup) && (this.rotation = i.defaultGroupRotate, this.transformOrigin = i.defaultGroupOrigin || "50% 50%", this.scale = [1, 1]), a = this.rotation, s = this.scale, c = (u = function (t, n) { if (!t.length) return [0, 0, 0, 0]; var o, i, a, r, s, e, u, c = t.map(function (t) { return no(t.state) }), l = Ne, f = Ne, p = 0, d = 0, h = Nt(n, Ie); return h % 90 ? (o = h / 180 * Math.PI, i = Math.tan(o), a = -1 / i, r = [je, Ne], s = [je, Ne], c.forEach(function (t) { t.forEach(function (t) { var n = t[1] - i * t[0], e = t[1] - a * t[0]; r[0] = Math.max(r[0], n), r[1] = Math.min(r[1], n), s[0] = Math.max(s[0], e), s[1] = Math.min(s[1], e) }) }), r.forEach(function (r) { s.forEach(function (t) { var n = (t - r) / (i - a), e = i * n + r; l = Math.min(l, n), f = Math.min(f, e) }) }), p = Ca(e = c.map(function (t) { var n = t[0], e = t[1], r = t[2], i = t[3]; return [an(n, -o), an(e, -o), an(r, -o), an(i, -o)] }), 0) - Ra(e, 0), d = Ca(e, 1) - Ra(e, 1)) : (l = Ra(c, 0), f = Ra(c, 1), p = Ca(c, 0) - l, d = Ca(c, 1) - f, h % 180 && (u = p, p = d, d = u)), [l, f, p, d] }(this.moveables, a))[0], l = u[1], f = u[2], p = u[3], d = "rotate(" + a + "deg) scale(" + (0 <= s[0] ? 1 : -1) + ", " + (0 <= s[1] ? 1 : -1) + ")", o.style.cssText += "left:0px;top:0px; transform-origin: " + this.transformOrigin + "; width:" + f + "px; height:" + p + "px;transform:" + d, r.width = f, r.height = p, h = this.getContainer(), g = [(v = Zi(this.controlBox.getElement(), o, this.controlBox.getElement(), this.getContainer(), this.props.rootContainer || h)).left, v.top], M = [(S = Tn([b = (m = no(v))[0], x = m[1], E = m[2], y = m[3]])).minX, S.minY], v.pos1 = Jt(b, M), v.pos2 = Jt(x, M), v.pos3 = Jt(E, M), v.pos4 = Jt(y, M), v.left = c - v.left + M[0], v.top = l - v.top + M[1], v.origin = Jt(Kt(g, v.origin), M), v.beforeOrigin = Jt(Kt(g, v.beforeOrigin), M), v.originalBeforeOrigin = Kt(g, v.originalBeforeOrigin), w = v.targetClientRect, D = 0 < s[0] * s[1] ? 1 : -1, w.top += v.top - r.top, w.left += v.left - r.left, o.style.transform = "translate(" + -M[0] + "px, " + -M[1] + "px) " + d, this.updateState(Ce(Ce({}, v), { direction: D, beforeDirection: D }), e)) }, n.getRect = function () { return Ce(Ce({}, r.prototype.getRect.call(this)), { children: this.moveables.map(function (t) { return t.getRect() }) }) }, n.triggerEvent = function (t, n, e) { if (e || -1 < t.indexOf("Group")) return r.prototype.triggerEvent.call(this, t, n); this._emitter.trigger(t, n) }, n.updateAbles = function () { r.prototype.updateAbles.call(this, Re(Re([], this.props.ables), [va]), "Group") }, n._updateTargets = function () { r.prototype._updateTargets.call(this), this._prevTarget = this.props.dragTarget || this.areaElement }, n._updateEvents = function () { var t = this.state, n = this.props, e = this._prevTarget, r = n.dragTarget || this.areaElement; e !== r && (eo(this, "targetGesto"), eo(this, "controlGesto"), t.target = null), t.target || (t.target = this.areaElement, this.controlBox.getElement().style.display = "block", this.targetGesto = fa(this, r, "Group"), this.controlGesto = pa(this, this.controlBox.getElement(), "controlAbles", "GroupControl")); var i = !co(t.container, n.container); i && (t.container = n.container); var o = this.differ.update(n.targets), a = o.added, s = o.changed, u = o.removed; (i || a.length || s.length || u.length) && this.updateRect() }, n._updateObserver = function () { }, t.defaultProps = Ce(Ce({}, ha.defaultProps), { transformOrigin: ["50%", "50%"], groupable: !0, dragArea: !0, keepRatio: !0, targets: [], defaultGroupRotate: 0, defaultGroupOrigin: "50% 50%" }), t }(ha), Pa = function (n) { function t() { var t = null !== n && n.apply(this, arguments) || this; return t.moveables = [], t } De(t, n); var e = t.prototype; return e.render = function () { var e = this, t = this.props, n = t.cspNonce, r = t.cssStyled, i = t.targets; return _(r, { cspNonce: n, ref: y(this, "controlBox"), className: Ri("control-box") }, i.map(function (t, n) { return _(ha, Ce({ key: "moveable" + n, ref: a(e, "moveables", n) }, e.props, { target: t, wrapperMoveable: e })) })) }, e.componentDidUpdate = function () { }, e.updateRect = function (n, e, r) { void 0 === r && (r = !0), this.moveables.forEach(function (t) { t.updateRect(n, e, r) }) }, e.getRect = function () { return Ce(Ce({}, n.prototype.getRect.call(this)), { children: this.moveables.map(function (t) { return t.getRect() }) }) }, e.request = function () { return { request: function () { return this }, requestEnd: function () { return this } } }, e.dragStart = function () { return this }, e.hitTest = function () { return 0 }, e.isInside = function () { return !1 }, e.isDragging = function () { return !1 }, e.updateRenderPoses = function () { }, e.checkUpdate = function () { }, e.triggerEvent = function () { }, e.updateAbles = function () { }, e._updateEvents = function () { }, e._updateObserver = function () { }, t }(ha), _a = function (t) { function n() { return null !== t && t.apply(this, arguments) || this } return De(n, t), n.defaultAbles = Ea, n }(function (n) { function t() { var t = null !== n && n.apply(this, arguments) || this; return t.refTargets = [], t.selectorMap = {}, t } De(t, n); var e, r, i = t.prototype; return t.makeStyled = function () { var e = {}; this.getTotalAbles().forEach(function (t) { var n = t.css; n && n.forEach(function (t) { e[t] = !0 }) }); var r, t = Bt(e).join("\n"); this.defaultStyled = ye("div", (r = Te, (ke + t).replace(/([^}{]*){/gm, function (t, n) { return n.replace(/\.([^{,\s\d.]+)/g, "." + r + "$1") + "{" }))) }, t.getTotalAbles = function () { return Re([Io, va, xa, To], this.defaultAbles) }, i.render = function () { var t = this.constructor; t.defaultStyled || t.makeStyled(); var n, e, r, i = this.props, o = i.ables, a = i.props, s = function (t, n) { var e = {}; for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && n.indexOf(r) < 0 && (e[r] = t[r]); if (null != t && "function" == typeof Object.getOwnPropertySymbols) for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)n.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (e[r[i]] = t[r[i]]); return e }(i, ["ables", "props"]), u = this._updateRefs(!0), c = (n = u, e = this.selectorMap, r = [], n.forEach(function (t) { t && (mt(t) ? e[t] && r.push.apply(r, e[t]) : r.push(t)) }), r), l = 1 < c.length, f = Re(Re([], t.getTotalAbles()), o || []), p = Ce(Ce(Ce({}, s), a || {}), { ables: f, cssStyled: t.defaultStyled, customStyledMap: t.customStyledMap }); return l ? s.individualGroupable ? _(Pa, Ce({ key: "individual-group", ref: y(this, "moveable") }, p, { target: null, targets: c })) : _(Oa, Ce({ key: "group", ref: y(this, "moveable") }, p, { target: null, targets: c })) : _(ha, Ce({ key: "single", ref: y(this, "moveable") }, p, { target: c[0] })) }, i.componentDidMount = function () { this._updateRefs() }, i.componentDidUpdate = function () { this._updateRefs() }, i.componentWillUnmount = function () { this.selectorMap = {}, this.refTargets = [] }, i.getManager = function () { return this.moveable }, i._updateRefs = function (t) { var n = this.refTargets, r = Eo(this.props.target || this.props.targets), e = "undefined" != typeof document, i = n.length !== r.length || n.some(function (t, n) { var e = r[n]; return !(!t && !e) && t !== e }), o = this.selectorMap, a = {}; return this.refTargets.forEach(function (t) { mt(t) && (o[t] ? a[t] = o[t] : e && (i = !0, a[t] = [].slice.call(document.querySelectorAll(t)))) }), this.refTargets = r, this.selectorMap = a, !t && i && this.forceUpdate(), r }, t.defaultAbles = [], t.customStyledMap = {}, t.defaultStyled = null, function (t, n, e, r) { var i, o = arguments.length, a = o < 3 ? n : null === r ? r = Object.getOwnPropertyDescriptor(n, e) : r; if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(t, n, e, r); else for (var s = t.length - 1; 0 <= s; s--)(i = t[s]) && (a = (o < 3 ? i(a) : 3 < o ? i(n, e, a) : i(n, e)) || a); 3 < o && a && Object.defineProperty(n, e, a) }([(e = qe, void 0 === r && (r = {}), function (n, o) { e.forEach(function (i) { var t = r[i] || i; t in n || (n[t] = function () { for (var t, n = [], e = 0; e < arguments.length; e++)n[e] = arguments[e]; var r = (t = this[o])[i].apply(t, n); return r === this[o] ? this : r }) }) })], t.prototype, "moveable", void 0), t }(Y)), Ba = function (e) { function t(t) { var n = e.call(this, t) || this; return n.state = {}, n.state = n.props, n } return i(t, e), t.prototype.render = function () { return t = _(_a, u({ ref: y(this, "moveable") }, this.state)), n = this.state.parentElement, _(X, { element: t, container: n }); var t, n }, t }(j); function za(t, n) { for (var e = t.length, r = 0; r < e; ++r)if (n(t[r], r)) return !0; return !1 } function Ga(t, n) { for (var e = t.length, r = 0; r < e; ++r)if (n(t[r], r)) return t[r]; return null } function Ta(t, n) { try { return new RegExp(t, "g").exec(n) } catch (t) { return null } } function ka(t) { return t.replace(/_/g, ".") } function Aa(t, i) { var o = null, a = "-1"; return za(t, function (t) { var n, e, r = Ta("(" + t.test + ")((?:\\/|\\s|:)([0-9|\\.|_]+))?", i); return r && !t.brand && (o = t, a = r[3] || "-1", t.versionAlias ? a = t.versionAlias : t.versionTest && (n = t.versionTest.toLowerCase(), e = Ta("(" + n + ")((?:\\/|\\s|:)([0-9|\\.|_]+))", i), a = (e ? e[3] : "") || a), a = ka(a), 1) }), { preset: o, version: a } } function Fa(t, e) { var r = { brand: "", version: "-1" }; return za(t, function (t) { var n = Ia(e, t); return n && (r.brand = t.id, r.version = t.versionAlias || n.version, "-1" !== r.version) }), r } function Ia(t, e) { return Ga(t, function (t) { var n = t.brand; return Ta("" + e.test, n.toLowerCase()) }) } var Na = [{ test: "phantomjs", id: "phantomjs" }, { test: "whale", id: "whale" }, { test: "edgios|edge|edg", id: "edge" }, { test: "msie|trident|windows phone", id: "ie", versionTest: "iemobile|msie|rv" }, { test: "miuibrowser", id: "miui browser" }, { test: "samsungbrowser", id: "samsung internet" }, { test: "samsung", id: "samsung internet", versionTest: "version" }, { test: "chrome|crios", id: "chrome" }, { test: "firefox|fxios", id: "firefox" }, { test: "android", id: "android browser", versionTest: "version" }, { test: "safari|iphone|ipad|ipod", id: "safari", versionTest: "version" }], ja = [{ test: "(?=.*applewebkit/(53[0-7]|5[0-2]|[0-4]))(?=.*\\schrome)", id: "chrome", versionTest: "chrome" }, { test: "chromium", id: "chrome" }, { test: "whale", id: "chrome", versionAlias: "-1", brand: !0 }], Ya = [{ test: "applewebkit", id: "webkit", versionTest: "applewebkit|safari" }], Xa = [{ test: "(?=(iphone|ipad))(?!(.*version))", id: "webview" }, { test: "(?=(android|iphone|ipad))(?=.*(naver|daum|; wv))", id: "webview" }, { test: "webview", id: "webview" }], Wa = [{ test: "windows phone", id: "windows phone" }, { test: "windows 2000", id: "window", versionAlias: "5.0" }, { test: "windows nt", id: "window" }, { test: "iphone|ipad|ipod", id: "ios", versionTest: "iphone os|cpu os" }, { test: "mac os x", id: "mac" }, { test: "android", id: "android" }, { test: "tizen", id: "tizen" }, { test: "webos|web0s", id: "webos" }]; function qa(t) { var n, e = function (t) { var n = t; if (void 0 === n) { if ("undefined" == typeof navigator || !navigator) return ""; n = navigator.userAgent || "" } return n.toLowerCase() }(t), r = !!/mobi/g.exec(e), i = { name: "unknown", version: "-1", majorVersion: -1, webview: !!Aa(Xa, e).preset, chromium: !1, chromiumVersion: "-1", webkit: !1, webkitVersion: "-1" }, o = { name: "unknown", version: "-1", majorVersion: -1 }, a = Aa(Na, e), s = a.preset, u = a.version, c = Aa(Wa, e), l = c.preset, f = c.version, p = Aa(ja, e); return i.chromium = !!p.preset, i.chromiumVersion = p.version, i.chromium || (n = Aa(Ya, e), i.webkit = !!n.preset, i.webkitVersion = n.version), l && (o.name = l.id, o.version = f, o.majorVersion = parseInt(f, 10)), s && (i.name = s.id, i.version = u, i.webview && "ios" === o.name && "safari" !== i.name && (i.webview = !1)), i.majorVersion = parseInt(i.version, 10), { browser: i, os: o, isMobile: r, isHints: !1 } } function La(n, e) { return function (t) { t && (n[e] = t) } } var Ha = "function", Va = "object", Ua = "string", $a = "number", Za = "undefined", Ka = typeof window !== Za, Ja = [{ open: "(", close: ")" }, { open: '"', close: '"' }, { open: "'", close: "'" }, { open: '\\"', close: '\\"' }, { open: "\\'", close: "\\'" }], Qa = 1e-7, ts = { cm: function (t) { return 96 * t / 2.54 }, mm: function (t) { return 96 * t / 254 }, in: function (t) { return 96 * t }, pt: function (t) { return 96 * t / 72 }, pc: function (t) { return 96 * t / 6 }, "%": function (t, n) { return t * n / 100 }, vw: function (t, n) { return void 0 === n && (n = window.innerWidth), t / 100 * n }, vh: function (t, n) { return void 0 === n && (n = window.innerHeight), t / 100 * n }, vmax: function (t, n) { return void 0 === n && (n = Math.max(window.innerWidth, window.innerHeight)), t / 100 * n }, vmin: function (t, n) { return void 0 === n && (n = Math.min(window.innerWidth, window.innerHeight)), t / 100 * n } }; function ns(t) { return typeof t === Za } function es(t) { return t && typeof t === Va } function rs(t) { return Array.isArray(t) } function is(t) { return typeof t === Ua } function os(t) { return typeof t === Ha } function as(t, n, e, r, i) { return ss(t, n, e) ? e : function (i, o, t, a, s) { for (var u, n = t; n < a; ++n) { var e = function (t) { var n = o[t].trim(); if (n === i.close && !ss(i, o, t)) return { value: t }; var e = t, r = gs(s, function (t) { return t.open === n }); if (r && (e = as(r, o, t, a, s)), -1 === e) return u = t, "break"; u = t = e }(n); if (n = u, "object" == typeof e) return e.value; if ("break" === e) break } return -1 }(t, n, e + 1, r, i) } function ss(t, n, e) { if (!t.ignore) return null; var r = n.slice(Math.max(e - 3, 0), e + 3).join(""); return new RegExp(t.ignore).exec(r) } function us(t, n) { var e = is(n) ? { separator: n } : n, r = e.separator, s = void 0 === r ? "," : r, u = e.isSeparateFirst, c = e.isSeparateOnlyOpenClose, i = e.isSeparateOpenClose, l = void 0 === i ? c : i, o = e.openCloseCharacters, f = void 0 === o ? Ja : o, a = f.map(function (t) { var n = t.open, e = t.close; return n === e ? n : n + "|" + e }).join("|"), p = new RegExp("(\\s*" + s + "\\s*|" + a + "|\\s+)", "g"), d = t.split(p).filter(Boolean), h = d.length, v = [], g = []; function m() { return g.length && (v.push(g.join("")), g = []) } for (var b, x = 0; x < h; ++x) { var E = function (t) { var n, e, r = d[t].trim(), i = t, o = gs(f, function (t) { return t.open === r }), a = gs(f, function (t) { return t.close === r }); if (o) { if (-1 !== (i = as(o, d, t, h, f)) && l) return m() && u ? (b = t, "break") : (v.push(d.slice(t, i + 1).join("")), t = i, u ? (b = t, "break") : (b = t, "continue")) } else { if (a && !ss(a, d, t)) throw new Error("invalid format: " + a.close); if (n = r, !(("" !== (e = s) && " " != e || "" !== n && " " != n) && n !== e || c)) return m(), u ? (b = t, "break") : (b = t, "continue") } -1 === i && (i = h - 1), g.push(d.slice(t, i + 1).join("")), b = t = i }(x), x = b; if ("break" === E) break } return g.length && v.push(g.join("")), v } function cs(t) { return us(t, "") } function ls(t) { return us(t, ",") } function fs(t) { var n = /([^(]*)\(([\s\S]*)\)([\s\S]*)/g.exec(t); return !n || n.length < 4 ? {} : { prefix: n[1], value: n[2], suffix: n[3] } } function ps(t) { var n = /^([^\d|e|\-|\+]*)((?:\d|\.|-|e-|e\+)+)(\S*)$/g.exec(t); if (!n) return { prefix: "", unit: "", value: NaN }; var e = n[1], r = n[2]; return { prefix: e, unit: n[3], value: parseFloat(r) } } function ds(t, r) { return void 0 === r && (r = "-"), t.replace(/([a-z])([A-Z])/g, function (t, n, e) { return "" + n + r + e.toLowerCase() }) } function hs() { return Date.now ? Date.now() : (new Date).getTime() } function vs(t, n, e) { void 0 === e && (e = -1); for (var r = t.length, i = 0; i < r; ++i)if (n(t[i], i, t)) return i; return e } function gs(t, n, e) { var r = vs(t, n); return -1 < r ? t[r] : e } var ms = function () { var e = hs(), t = Ka && (window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame); return t ? t.bind(window) : function (t) { var n = hs(); return window.setTimeout(function () { t(n - e) }, 1e3 / 60) } }(), bs = function () { var t = Ka && (window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.msCancelAnimationFrame); return t ? t.bind(window) : function (t) { clearTimeout(t) } }(); function xs(t, n) { var e = ps(t), r = e.value, i = e.unit; if (es(n)) { var o = n[i]; if (o) { if (os(o)) return o(r); if (ts[i]) return ts[i](r, o) } } else if ("%" === i) return r * n / 100; return ts[i] ? ts[i](r) : r } function Es(t, e, r) { return [[Cs(e[0], Qa), Cs(e[0] * t[1] / t[0], Qa)], [Cs(e[1] * t[0] / t[1], Qa), Cs(e[1], Qa)]].filter(function (t) { return t.every(function (t, n) { return r ? t <= e[n] : t >= e[n] }) })[0] || t } function ys(t, o, a, n) { if (!n) return t.map(function (t, n) { return e = t, r = o[n], i = a[n], Math.max(r, Math.min(e, i)); var e, r, i }); var e = t[0], r = t[1], i = Es(t, o, !1), s = i[0], u = i[1], c = Es(t, a, !0), l = c[0], f = c[1]; return e < s || r < u ? (e = s, r = u) : (l < e || f < r) && (e = l, r = f), [e, r] } function Ss(t) { for (var n = t.length, e = 0, r = n - 1; 0 <= r; --r)e += t[r]; return n ? e / n : 0 } function Ms(t, n) { var e = n[0] - t[0], r = n[1] - t[1], i = Math.atan2(r, e); return 0 <= i ? i : i + 2 * Math.PI } function ws(t) { var e, n = (e = t, [0, 1].map(function (n) { return Ss(e.map(function (t) { return t[n] })) })), r = Ms(n, t[0]), i = Ms(n, t[1]); return r < i && i - r < Math.PI || i < r && i - r < -Math.PI ? 1 : -1 } function Ds(t, n) { return Math.sqrt(Math.pow((n ? n[0] : 0) - t[0], 2) + Math.pow((n ? n[1] : 0) - t[1], 2)) } function Cs(t, n) { return n ? Math.round(t / n) * n : t } function Rs(e, r) { return e.forEach(function (t, n) { e[n] = Cs(e[n], r) }), e } function Os(t, n) { return t.classList ? t.classList.contains(n) : !!t.className.match(new RegExp("(\\s|^)" + n + "(\\s|$)")) } function Ps(t, n, e, r) { t.addEventListener(n, e, r) } function _s(t, n, e, r) { t.removeEventListener(n, e, r) } function Bs(t, n, e) { void 0 === e && (e = Math.sqrt(t.length)); for (var r = t.slice(), i = 0; i < e; ++i)r[i * e + n - 1] = 0, r[(n - 1) * e + i] = 0; return r[(n - 1) * (e + 1)] = 1, r } function zs(t, n) { void 0 === n && (n = Math.sqrt(t.length)); for (var e = t.slice(), r = $s(n), i = 0; i < n; ++i) { var o = n * i + i; if (!Cs(e[o], Qa)) for (var a = i + 1; a < n; ++a)if (e[n * i + a]) { !function (t, n, e, r, i) { for (var o = 0; o < i; ++o) { var a = e + o * i, s = r + o * i, u = t[a], c = n[a]; t[a] = t[s], t[s] = u, n[a] = n[s], n[s] = c } }(e, r, i, a, n); break } if (!Cs(e[o], Qa)) return []; !function (t, n, e, r, i) { for (var o = 0; o < r; ++o) { var a = e + o * r; t[a] /= i, n[a] /= i } }(e, r, i, n, e[o]); for (a = 0; a < n; ++a) { var s = a, u = e[a + i * n]; Cs(u, Qa) && i !== a && function (t, n, e, r, i, o) { for (var a = 0; a < i; ++a) { var s = e + a * i, u = r + a * i; t[s] += t[u] * o, n[s] += n[u] * o } }(e, r, s, i, n, -u) } } return r } function Gs(t, n) { for (var e = t.slice(), r = t.length; r < n - 1; ++r)e[r] = 0; return e[n - 1] = 1, e } function Ts(t, n, e) { if (void 0 === n && (n = Math.sqrt(t.length)), n === e) return t; for (var r = $s(e), i = Math.min(n, e), o = 0; o < i - 1; ++o) { for (var a = 0; a < i - 1; ++a)r[o * e + a] = t[o * n + a]; r[(o + 1) * e - 1] = t[(o + 1) * n - 1], r[(e - 1) * e + o] = t[(n - 1) * n + o] } return r[e * e - 1] = t[n * n - 1], r } function ks(n) { for (var t = [], e = 1; e < arguments.length; e++)t[e - 1] = arguments[e]; var r = $s(n); return t.forEach(function (t) { r = As(r, t, n) }), r } function As(t, n, e) { void 0 === e && (e = Math.sqrt(t.length)); var r = [], i = t.length / e, o = n.length / i; if (!i) return n; if (!o) return t; for (var a = 0; a < e; ++a)for (var s = 0; s < o; ++s)for (var u = r[s * e + a] = 0; u < i; ++u)r[s * e + a] += t[u * e + a] * n[s * i + u]; return r } function Fs(t, n) { for (var e = Math.min(t.length, n.length), r = t.slice(), i = 0; i < e; ++i)r[i] = r[i] + n[i]; return r } function Is(t, n) { for (var e = Math.min(t.length, n.length), r = t.slice(), i = 0; i < e; ++i)r[i] = r[i] - n[i]; return r } function Ns(t, n) { return void 0 === n && (n = 9 === t.length), n ? [t[0], t[1], t[3], t[4], t[6], t[7]] : t } function js(t, n, e) { void 0 === e && (e = n.length); var r = As(t, n, e), i = r[e - 1]; return r.map(function (t) { return t / i }) } function Ys(t, n) { return As(t, [1, 0, 0, 0, 0, Math.cos(n), Math.sin(n), 0, 0, -Math.sin(n), Math.cos(n), 0, 0, 0, 0, 1], 4) } function Xs(t, n) { return As(t, [Math.cos(n), 0, -Math.sin(n), 0, 0, 1, 0, 0, Math.sin(n), 0, Math.cos(n), 0, 0, 0, 0, 1], 4) } function Ws(t, n) { return As(t, Us(n, 4)) } function qs(t, n) { var e = n[0], r = void 0 === e ? 1 : e, i = n[1], o = void 0 === i ? 1 : i, a = n[2]; return As(t, [r, 0, 0, 0, 0, o, 0, 0, 0, 0, void 0 === a ? 1 : a, 0, 0, 0, 0, 1], 4) } function Ls(t, n) { return js(Us(n, 3), Gs(t, 3)) } function Hs(t, n) { var e = n[0], r = void 0 === e ? 0 : e, i = n[1], o = void 0 === i ? 0 : i, a = n[2]; return As(t, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, r, o, void 0 === a ? 0 : a, 1], 4) } function Vs(t, n) { return As(t, n, 4) } function Us(t, n) { var e = Math.cos(t), r = Math.sin(t), i = $s(n); return i[0] = e, i[1] = r, i[n] = -r, i[n + 1] = e, i } function $s(t) { for (var n = t * t, e = [], r = 0; r < n; ++r)e[r] = r % (t + 1) ? 0 : 1; return e } function Zs(t, n) { for (var e = $s(n), r = Math.min(t.length, n - 1), i = 0; i < r; ++i)e[(n + 1) * i] = t[i]; return e } function Ks(t, n) { for (var e = $s(n), r = Math.min(t.length, n - 1), i = 0; i < r; ++i)e[n * (n - 1) + i] = t[i]; return e } function Js(t, n, e, r, i, o, a, s) { var u = t[0], c = t[1], l = n[0], f = n[1], p = e[0], d = e[1], h = r[0], v = r[1], g = i[0], m = i[1], b = o[0], x = o[1], E = a[0], y = a[1], S = s[0], M = s[1], w = zs([u, 0, l, 0, p, 0, h, 0, c, 0, f, 0, d, 0, v, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, u, 0, l, 0, p, 0, h, 0, c, 0, f, 0, d, 0, v, 0, 1, 0, 1, 0, 1, 0, 1, -g * u, -m * u, -b * l, -x * l, -E * p, -y * p, -S * h, -M * h, -g * c, -m * c, -b * f, -x * f, -E * d, -y * d, -S * v, -M * v], 8); if (!w.length) return []; var D = As(w, [g, m, b, x, E, y, S, M], 8); return D[8] = 1, Ts(function (t, n) { void 0 === n && (n = Math.sqrt(t.length)); for (var e = [], r = 0; r < n; ++r)for (var i = 0; i < n; ++i)e[i * n + r] = t[n * r + i]; return e }(D), 3, 4) } function Qs(t) { return tu(nu(t)) } function tu(t) { var r = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]; return t.forEach(function (t) { var n = t.matrixFunction, e = t.functionValue; n && (r = n(r, e)) }), r } function nu(t) { return (rs(t) ? t : cs(t)).map(function (t) { var n, e, r, i, o, a, s, u, c, l, f, p = fs(t), d = p.prefix, h = p.value, v = null, g = d, m = ""; return "translate" === d || "translateX" === d || "translate3d" === d ? (v = Hs, m = [(n = ls(h).map(function (t) { return parseFloat(t) }))[0], void 0 === (e = n[1]) ? 0 : e, void 0 === (r = n[2]) ? 0 : r]) : "translateY" === d ? (v = Hs, m = [0, parseFloat(h), 0]) : "translateZ" === d ? (v = Hs, m = [0, 0, parseFloat(h)]) : "scale" === d || "scale3d" === d ? (v = qs, m = [s = (i = ls(h).map(function (t) { return parseFloat(t) }))[0], void 0 === (o = i[1]) ? s : o, void 0 === (a = i[2]) ? 1 : a]) : "scaleX" === d ? (v = qs, m = [s = parseFloat(h), 1, 1]) : "scaleY" === d ? (v = qs, m = [1, parseFloat(h), 1]) : "scaleZ" === d ? (v = qs, m = [1, 1, parseFloat(h)]) : "rotate" === d || "rotateZ" === d || "rotateX" === d || "rotateY" === d ? (c = (u = ps(h)).unit, l = u.value, "rotate" === d || "rotateZ" === d ? (g = "rotateZ", v = Ws) : "rotateX" === d ? v = Ys : "rotateY" === d && (v = Xs), m = "rad" === c ? l : l * Math.PI / 180) : "matrix3d" === d ? (v = Vs, m = ls(h).map(function (t) { return parseFloat(t) })) : "matrix" === d ? (v = Vs, m = [(f = ls(h).map(function (t) { return parseFloat(t) }))[0], f[1], 0, 0, f[2], f[3], 0, 0, 0, 0, 1, 0, f[4], f[5], 0, 1]) : g = "", { name: d, functionName: g, value: h, matrixFunction: v, functionValue: m } }) } var eu = function () { function t() { this.keys = [], this.values = [] } var n = t.prototype; return n.get = function (t) { return this.values[this.keys.indexOf(t)] }, n.set = function (t, n) { var e = this.keys, r = this.values, i = e.indexOf(t), o = -1 === i ? e.length : i; e[o] = t, r[o] = n }, t }(), ru = function () { function t() { this.object = {} } var n = t.prototype; return n.get = function (t) { return this.object[t] }, n.set = function (t, n) { this.object[t] = n }, t }(), iu = "function" == typeof Map, ou = function () { function t() { } var n = t.prototype; return n.connect = function (t, n) { this.prev = t, this.next = n, t && (t.next = this), n && (n.prev = this) }, n.disconnect = function () { var t = this.prev, n = this.next; t && (t.next = n), n && (n.prev = t) }, n.getIndex = function () { for (var t = this, n = -1; t;)t = t.prev, ++n; return n }, t }(); var au = function () { function t(t, n, e, r, i, o, a, s) { this.prevList = t, this.list = n, this.added = e, this.removed = r, this.changed = i, this.maintained = o, this.changedBeforeAdded = a, this.fixed = s } var n = t.prototype; return Object.defineProperty(n, "ordered", { get: function () { return this.cacheOrdered || this.caculateOrdered(), this.cacheOrdered }, enumerable: !0, configurable: !0 }), Object.defineProperty(n, "pureChanged", { get: function () { return this.cachePureChanged || this.caculateOrdered(), this.cachePureChanged }, enumerable: !0, configurable: !0 }), n.caculateOrdered = function () { var t, e, s, u, n = (t = this.changedBeforeAdded, e = this.fixed, s = [], u = [], t.forEach(function (t) { var n = t[0], e = t[1], r = new ou; s[n] = r, u[e] = r }), s.forEach(function (t, n) { t.connect(s[n - 1]) }), t.filter(function (t, n) { return !e[n] }).map(function (t, n) { var e = t[0], r = t[1]; if (e === r) return [0, 0]; var i = s[e], o = u[r - 1], a = i.getIndex(); return i.disconnect(), o ? i.connect(o, o.next) : i.connect(void 0, s[0]), [a, i.getIndex()] })), c = this.changed, l = []; this.cacheOrdered = n.filter(function (t, n) { var e = t[0], r = t[1], i = c[n], o = i[0], a = i[1]; if (e !== r) return l.push([o, a]), !0 }), this.cachePureChanged = l }, t }(); function su(t, n, e) { var r = iu ? Map : e ? ru : eu, i = e || function (t) { return t }, o = [], a = [], s = [], u = t.map(i), c = n.map(i), l = new r, f = new r, p = [], d = [], h = {}, v = [], g = 0, m = 0; return u.forEach(function (t, n) { l.set(t, n) }), c.forEach(function (t, n) { f.set(t, n) }), u.forEach(function (t, n) { var e = f.get(t); void 0 === e ? (++m, a.push(n)) : h[e] = m }), c.forEach(function (t, n) { var e = l.get(t); void 0 === e ? (o.push(n), ++g) : (s.push([e, n]), m = h[n] || 0, p.push([e - m, n - g]), d.push(n === e), e !== n && v.push([e, n])) }), a.reverse(), new au(t, n, o, a, v, s, p, d) } var uu, cu = "function" == typeof Map ? void 0 : (uu = 0, function (t) { return t.__DIFF_KEY__ || (t.__DIFF_KEY__ = ++uu) }); function lu(r) { return r.length < 3 ? 0 : Math.abs(function (t) { for (var n = 0, e = t.length - 1; 0 <= e; --e)n += t[e]; return n }(r.map(function (t, n) { var e = r[n + 1] || r[0]; return t[0] * e[1] - e[0] * t[1] }))) / 2 } function fu(t, n) { var e = n.width, r = n.height, i = n.left, o = n.top, a = pu(t), s = a.minX, u = a.minY, c = a.maxX, l = a.maxY, f = e / (c - s), p = r / (l - u); return t.map(function (t) { return [i + (t[0] - s) * f, o + (t[1] - u) * p] }) } function pu(t) { var n = t.map(function (t) { return t[0] }), e = t.map(function (t) { return t[1] }); return { minX: Math.min.apply(Math, n), minY: Math.min.apply(Math, e), maxX: Math.max.apply(Math, n), maxY: Math.max.apply(Math, e) } } function du(t, n, e) { var i = t[0], o = t[1], r = pu(n), a = r.minX, s = r.minY, u = r.maxX, c = r.maxY, l = [[a, o], [u, o]], f = [[i, s], [i, c]], p = hu(l[0], l[1]), d = hu(f[0], f[1]), h = mu(n), v = [], g = []; return h.forEach(function (t) { var n = hu(t[0], t[1]), e = gu(vu(p, n), [l, t]), r = gu(vu(d, n), [f, t]); 1 === e.length && t[0][1] === o || v.push.apply(v, e), 1 === r.length && t[0][0] === i || g.push.apply(g, r), n[0] || v.push.apply(v, e), n[1] || g.push.apply(g, r) }), !e && (-1 < vs(v, function (t) { return t[0] === i }) || -1 < vs(g, function (t) { return t[1] === o })) || !!(v.filter(function (t) { return t[0] > i }).length % 2 && g.filter(function (t) { return t[1] > o }).length % 2) } function hu(t, n) { var e = t[0], r = t[1], i = n[0], o = n[1]; if (e === i && r === o) return [0, 0, 0]; if (e === i) return [1, 0, -e]; if (r === o) return [0, 1, -r]; var a = (i - e) / (r - o); return [1, a, -e - a * r] } function vu(t, n) { var e, r, i = t[0], o = t[1], a = t[2], s = n[0], u = n[1], c = n[2], l = 0 === i && 0 === s, f = 0 === o && 0 === u; if (l && f) return []; if (l) { var p = -a / o; return p != -c / u ? [] : [[-1 / 0, p], [1 / 0, p]] } if (f) { var d = -a / i; return d != -c / s ? [] : [[d, -1 / 0], [d, 1 / 0]] } return 0 !== i ? 0 !== s ? 0 !== o ? 0 !== u ? [[e = (o * c - u * a) / (u * i - o * s), r = -(i * e + a) / o]] : [[e = -c / s, r = -(i * e + a) / o]] : [[e = -a / i, r = -(s * e + c) / u]] : [[e = -(o * (r = -c / u) + a) / i, r]] : [[e = -(u * (r = -a / o) + c) / s, r]] } function gu(t, n) { var e = n.map(function (n) { return [0, 1].map(function (t) { return [Math.min(n[0][t], n[1][t]), Math.max(n[0][t], n[1][t])] }) }); if (2 === t.length) { var r = t[0], i = r[0], o = r[1]; if (i === t[1][0]) { var a = Math.max.apply(Math, e.map(function (t) { return t[1][0] })), s = Math.min.apply(Math, e.map(function (t) { return t[1][1] })); return s < a ? [] : [[i, a], [i, s]] } if (o === t[1][1]) { var u = Math.max.apply(Math, e.map(function (t) { return t[0][0] })), c = Math.min.apply(Math, e.map(function (t) { return t[0][1] })); return c < u ? [] : [[u, o], [c, o]] } } return t.filter(function (n) { return e.every(function (t) { return t[0][0] <= n[0] && n[0] <= t[0][1] && t[1][0] <= n[1] && n[1] <= t[1][1] }) }) } function mu(e) { return function () { for (var t = 0, n = 0, e = arguments.length; n < e; n++)t += arguments[n].length; for (var r = Array(t), i = 0, n = 0; n < e; n++)for (var o = arguments[n], a = 0, s = o.length; a < s; a++, i++)r[i] = o[a]; return r }(e.slice(1), [e[0]]).map(function (t, n) { return [e[n], t] }) } function bu(t, n) { return lu(function (t, n) { var e = t.slice(), s = n.slice(); -1 === ws(e) && e.reverse(), -1 === ws(s) && s.reverse(); var u = mu(e), c = mu(s), r = u.map(function (t) { return hu(t[0], t[1]) }), l = c.map(function (t) { return hu(t[0], t[1]) }), f = []; r.forEach(function (r, i) { var o = u[i], a = []; l.forEach(function (t, n) { var e = gu(vu(r, t), [o, c[n]]); a.push.apply(a, e.map(function (t) { return { index1: i, index2: n, pos: t } })) }), a.sort(function (t, n) { return Ds(o[0], t.pos) - Ds(o[0], n.pos) }), f.push.apply(f, a), du(o[1], s) && f.push({ index1: i, index2: -1, pos: o[1] }) }), c.forEach(function (t, r) { var i, n; du(t[1], e) && (i = !1, -1 === (n = vs(f, function (t) { return t.index2 !== r ? !!i : void (i = !0) })) && (i = !1, n = vs(f, function (t) { var n = t.index1, e = t.index2; if (-1 !== n || e + 1 !== r) return !!i; i = !0 })), -1 === n ? f.push({ index1: -1, index2: r, pos: t[1] }) : f.splice(n, 0, { index1: -1, index2: r, pos: t[1] })) }); var i = f.map(function (t) { return t.pos }), o = {}; return i.filter(function (t) { var n = t[0] + "x" + t[1]; return !o[n] && (o[n] = !0) }) }(t, n)) } var xu = function () { return (xu = Object.assign || function (t) { for (var n, e = 1, r = arguments.length; e < r; e++)for (var i in n = arguments[e]) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]); return t }).apply(this, arguments) }; var Eu = function () { function t() { this._events = {} } var n = t.prototype; return n.on = function (t, n) { if (es(t)) for (var e in t) this.on(e, t[e]); else this._addEvent(t, n, {}); return this }, n.off = function (t, n) { if (t) if (es(t)) for (var e in t) this.off(e); else { var r, i; n ? !(r = this._events[t]) || -1 < (i = vs(r, function (t) { return t.listener === n })) && r.splice(i, 1) : this._events[t] = [] } else this._events = {}; return this }, n.once = function (n, t) { var e = this; return t && this._addEvent(n, t, { once: !0 }), new Promise(function (t) { e._addEvent(n, t, { once: !0 }) }) }, n.emit = function (n, e) { var r = this; void 0 === e && (e = {}); var t = this._events[n]; if (!n || !t) return !0; var i = !1; return e.eventType = n, e.stop = function () { i = !0 }, e.currentTarget = this, function () { for (var t = 0, n = 0, e = arguments.length; n < e; n++)t += arguments[n].length; for (var r = Array(t), i = 0, n = 0; n < e; n++)for (var o = arguments[n], a = 0, s = o.length; a < s; a++, i++)r[i] = o[a]; return r }(t).forEach(function (t) { t.listener(e), t.once && r.off(n, t.listener) }), !i }, n.trigger = function (t, n) { return void 0 === n && (n = {}), this.emit(t, n) }, n._addEvent = function (t, n, e) { var r = this._events; r[t] = r[t] || [], r[t].push(xu({ listener: n }, e)) }, t }(), yu = function (t, n) { return (yu = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, n) { t.__proto__ = n } || function (t, n) { for (var e in n) n.hasOwnProperty(e) && (t[e] = n[e]) })(t, n) }; var Su = function () { return (Su = Object.assign || function (t) { for (var n, e = 1, r = arguments.length; e < r; e++)for (var i in n = arguments[e]) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]); return t }).apply(this, arguments) }; function Mu(t) { var n = t.container; return n === document.body ? [n.scrollLeft || document.documentElement.scrollLeft, n.scrollTop || document.documentElement.scrollTop] : [n.scrollLeft, n.scrollTop] } var wu = function (n) { function t() { this.constructor = e } var e, r; function i() { var t = null !== n && n.apply(this, arguments) || this; return t._startRect = null, t._startPos = [], t._prevTime = 0, t._timer = 0, t._prevScrollPos = [0, 0], t._isWait = !1, t } yu(e = i, r = n), e.prototype = null === r ? Object.create(r) : (t.prototype = r.prototype, new t); var o = i.prototype; return o.dragStart = function (t, n) { var e, r = n.container, i = 0, o = 0, a = 0, s = 0; s = r === document.body ? (a = window.innerWidth, window.innerHeight) : (i = (e = r.getBoundingClientRect()).top, o = e.left, a = e.width, e.height), this._startPos = [t.clientX, t.clientY], this._startRect = { top: i, left: o, width: a, height: s }, this._prevScrollPos = this._getScrollPosition([0, 0], n) }, o.drag = function (t, n) { var e = t.clientX, r = t.clientY, i = n.threshold, o = void 0 === i ? 0 : i, a = this._startRect, s = this._startPos, u = [0, 0]; return a.top > r - o ? (s[1] > a.top || r < s[1]) && (u[1] = -1) : a.top + a.height < r + o && (s[1] < a.top + a.height || r > s[1]) && (u[1] = 1), a.left > e - o ? (s[0] > a.left || e < s[0]) && (u[0] = -1) : a.left + a.width < e + o && (s[0] < a.left + a.width || e > s[0]) && (u[0] = 1), clearTimeout(this._timer), !(!u[0] && !u[1]) && this._continueDrag(Su(Su({}, n), { direction: u, inputEvent: t, isDrag: !0 })) }, o.checkScroll = function (t) { var n = this; if (this._isWait) return !1; var e = t.prevScrollPos, r = void 0 === e ? this._prevScrollPos : e, i = t.direction, o = t.throttleTime, a = void 0 === o ? 0 : o, s = t.inputEvent, u = t.isDrag, c = this._getScrollPosition(i || [0, 0], t), l = c[0] - r[0], f = c[1] - r[1], p = i || [l ? Math.abs(l) / l : 0, f ? Math.abs(f) / f : 0]; return this._prevScrollPos = c, !(!l && !f) && (this.trigger("move", { offsetX: p[0] ? l : 0, offsetY: p[1] ? f : 0, inputEvent: s }), a && u && (this._timer = window.setTimeout(function () { n._continueDrag(t) }, a)), !0) }, o.dragEnd = function () { clearTimeout(this._timer) }, o._getScrollPosition = function (t, n) { var e = n.container, r = n.getScrollPosition; return (void 0 === r ? Mu : r)({ container: e, direction: t }) }, o._continueDrag = function (t) { var n = this, e = t.container, r = t.direction, i = t.throttleTime, o = t.useScroll, a = t.isDrag, s = t.inputEvent; if (!a || !this._isWait) { var u = hs(), c = Math.max(i + this._prevTime - u, 0); if (0 < c) return this._timer = window.setTimeout(function () { n._continueDrag(t) }, c), !1; this._prevTime = u; var l = this._getScrollPosition(r, t); return this._prevScrollPos = l, a && (this._isWait = !0), this.trigger("scroll", { container: e, direction: r, inputEvent: s }), this._isWait = !1, o || this.checkScroll(Su(Su({}, t), { prevScrollPos: l, direction: r, inputEvent: s })) } }, i }(Eu), Du = function (t, n) { return (Du = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, n) { t.__proto__ = n } || function (t, n) { for (var e in n) n.hasOwnProperty(e) && (t[e] = n[e]) })(t, n) }; function Cu(t, n) { function e() { this.constructor = t } Du(t, n), t.prototype = null === n ? Object.create(n) : (e.prototype = n.prototype, new e) } var Ru = function () { return (Ru = Object.assign || function (t) { for (var n, e = 1, r = arguments.length; e < r; e++)for (var i in n = arguments[e]) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]); return t }).apply(this, arguments) }; function Ou(t, n) { var e = {}; for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && n.indexOf(r) < 0 && (e[r] = t[r]); if (null != t && "function" == typeof Object.getOwnPropertySymbols) for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)n.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (e[r[i]] = t[r[i]]); return e } function Pu(t, n) { if (t === n) return !1; for (var e in t) if (!(e in n)) return !0; for (var e in n) if (t[e] !== n[e]) return !0; return !1 } function _u(i, o) { var a = Object.keys(i), e = Object.keys(o), t = su(a, e, function (t) { return t }), r = {}, s = {}, u = {}; return t.added.forEach(function (t) { var n = e[t]; r[n] = o[n] }), t.removed.forEach(function (t) { var n = a[t]; s[n] = i[n] }), t.maintained.forEach(function (t) { var n = t[0], e = a[n], r = [i[e], o[e]]; i[e] !== o[e] && (u[e] = r) }), { added: r, removed: s, changed: u } } function Bu(t) { var n = 0; return t.map(function (t) { return null == t ? "$compat" + ++n : "" + t }) } function zu(t, n, e, r) { return is(t) || typeof t === $a ? new Iu("text_" + t, n, e, r, null, {}) : new ("string" == typeof t.type ? Nu : t.type.prototype.render ? Wu : Xu)(t.type, n, e, r, t.ref, t.props) } function Gu(t) { var n = t.className, e = Ou(t, ["className"]); return null != n && (e.class = n), delete e.style, delete e.children, e } function Tu(t, n) { if (!n) return t; for (var e in n) ns(t[e]) && (t[e] = n[e]); return t } function ku(t, n) { for (var e = [], r = 2; r < arguments.length; r++)e[r - 2] = arguments[r]; var i = n || {}, o = i.key, a = i.ref, s = Ou(i, ["key", "ref"]); return { type: t, key: o, ref: a, props: Ru(Ru({}, s), { children: function n(t) { var e = []; return t.forEach(function (t) { e = e.concat(rs(t) ? n(t) : t) }), e }(e).filter(function (t) { return null != t && !1 !== t }) }) } } var Au = function () { function t(t, n, e, r, i, o) { void 0 === o && (o = {}), this.type = t, this.key = n, this.index = e, this.container = r, this.ref = i, this.props = o, this._providers = [] } var n = t.prototype; return n._should = function (t, n) { return !0 }, n._update = function (t, n, e, r) { if (this.base && !is(n) && !r && !this._should(n.props, e)) return !1; this.original = n, this._setState(e); var i = this.props; return is(n) || (this.props = n.props, this.ref = n.ref), this._render(t, this.base ? i : {}, e), !0 }, n._mounted = function () { var t = this.ref; t && t(this.base) }, n._setState = function (t) { }, n._updated = function () { var t = this.ref; t && t(this.base) }, n._destroy = function () { var t = this.ref; t && t(null) }, t }(); function Fu(t) { var n = {}, e = {}; for (var r in t) 0 === r.indexOf("on") ? e[r.replace("on", "").toLowerCase()] = t[r] : n[r] = t[r]; return { attributes: n, events: e } } var Iu = function (t) { function n() { return null !== t && t.apply(this, arguments) || this } Cu(n, t); var e = n.prototype; return e._render = function (t) { var n = this, e = !this.base; return e && (this.base = document.createTextNode(this.type.replace("text_", ""))), t.push(function () { e ? n._mounted() : n._updated() }), !0 }, e._unmount = function () { this.base.parentNode.removeChild(this.base) }, n }(Au), Nu = function (n) { function t() { var t = null !== n && n.apply(this, arguments) || this; return t.events = {}, t._isSVG = !1, t } Cu(t, n); var e = t.prototype; return e.addEventListener = function (t, n) { var e = this.events; e[t] = function (t) { t.nativeEvent = t, n(t) }, this.base.addEventListener(t, e[t]) }, e.removeEventListener = function (t) { var n = this.events; this.base.removeEventListener(t, n[t]), delete n[t] }, e._should = function (t) { return Pu(this.props, t) }, e._render = function (t, n) { var e, r, i, o = this, a = !this.base; a && (e = this._hasSVG(), this._isSVG = e, (i = this.props.portalContainer) || (r = this.type, i = e ? document.createElementNS("http://www.w3.org/2000/svg", r) : document.createElement(r)), this.base = i), Vu(this, this._providers, this.props.children, t, null); var s = this.base, u = Fu(n), c = u.attributes, l = u.events, f = Fu(this.props), p = f.attributes, d = f.events; return function (t, n, e) { var r = _u(t, n), i = r.added, o = r.removed, a = r.changed; for (var s in i) e.setAttribute(s, i[s]); for (var s in a) e.setAttribute(s, a[s][1]); for (var s in o) e.removeAttribute(s) }(Gu(c), Gu(p), s), function (t, n, e) { var r = _u(t, n), i = r.added, o = r.removed, a = r.changed; for (var s in o) e.removeEventListener(s); for (var s in i) e.addEventListener(s, i[s]); for (var s in a) e.removeEventListener(s), e.addEventListener(s, a[s][1]); for (var s in o) e.removeEventListener(s) }(l, d, this), function (t, n, e) { var r = e.style, i = _u(t, n), o = i.added, a = i.removed, s = i.changed; for (var u in o) { var c = ds(u, "-"); r.setProperty ? r.setProperty(c, o[u]) : r[c] = o[u] } for (var u in s) { c = ds(u, "-"); r.setProperty ? r.setProperty(c, s[u][1]) : r[c] = s[u][1] } for (var u in a) { c = ds(u, "-"); r.removeProperty ? r.removeProperty(c) : r[c] = "" } }(n.style || {}, this.props.style || {}, s), t.push(function () { a ? o._mounted() : o._updated() }), !0 }, e._unmount = function () { var t = this.events, n = this.base; for (var e in t) n.removeEventListener(e, t[e]); this._providers.forEach(function (t) { t._unmount() }), this.events = {}, this.props.portalContainer || n.parentNode.removeChild(n) }, e._hasSVG = function () { if (this._isSVG || "svg" === this.type) return !0; var t = ju(this.container); return t && "ownerSVGElement" in t }, t }(Au); function ju(t) { if (!t) return null; var n = t.base; return n instanceof Node ? n : ju(t.container) } function Yu(t) { if (!t) return null; if (t instanceof Node) return t; var n = t.$_provider._providers; return n.length ? Yu(n[0].base) : null } var Xu = function (t) { function n() { return null !== t && t.apply(this, arguments) || this } Cu(n, t); var e = n.prototype; return e._render = function (t) { var n = this.type(this.props); return Vu(this, this._providers, n ? [n] : [], t), !0 }, e._unmount = function () { this._providers.forEach(function (t) { t._unmount() }) }, n }(Au), Wu = function (a) { function t(t, n, e, r, i, o) { return void 0 === o && (o = {}), a.call(this, t, n, e, r, i, Tu(o, t.defaultProps)) || this } Cu(t, a); var n = t.prototype; return n._should = function (t, n) { return this.base.shouldComponentUpdate(Tu(t, this.type.defaultProps), n || this.base.state) }, n._render = function (t, n, e) { var r = this; this.props = Tu(this.props, this.type.defaultProps); var i = !this.base; i ? (this.base = new this.type(this.props), this.base.$_provider = this) : this.base.props = this.props; var o = this.base, a = o.state, s = o.render(); s && s.props && !s.props.children.length && (s.props.children = this.props.children), Vu(this, this._providers, s ? [s] : [], t, e, null), t.push(function () { i ? (r._mounted(), o.componentDidMount()) : (r._updated(), o.componentDidUpdate(n, a)) }) }, n._setState = function (t) { t && (this.base.state = t) }, n._unmount = function () { this._providers.forEach(function (t) { t._unmount() }), clearTimeout(this.base.$_timer), this.base.componentWillUnmount() }, t }(Au), qu = function () { function t(t) { void 0 === t && (t = {}), this.props = t, this.state = {}, this.$_timer = 0, this.$_state = {} } var n = t.prototype; return n.shouldComponentUpdate = function (t, n) { return !0 }, n.render = function () { return null }, n.setState = function (t, n, e) { var r = this; this.$_timer || (this.$_state = {}), clearTimeout(this.$_timer), this.$_timer = 0, this.$_state = Ru(Ru({}, this.$_state), t), e ? this.$_setState(n, e) : this.$_timer = setTimeout(function () { r.$_timer = 0, r.$_setState(n, e) }) }, n.forceUpdate = function (t) { this.setState({}, t, !0) }, n.componentDidMount = function () { }, n.componentDidUpdate = function (t, n) { }, n.componentWillUnmount = function () { }, n.$_setState = function (t, n) { var e = [], r = this.$_provider; Vu(r.container, [r], [r.original], e, Ru(Ru({}, this.state), this.$_state), n) && (t && e.push(t), e.forEach(function (t) { t() })) }, t }(), Lu = function (t) { function n() { return null !== t && t.apply(this, arguments) || this } return Cu(n, t), n.prototype.shouldComponentUpdate = function (t, n) { return Pu(this.props, t) || Pu(this.state, n) }, n }(qu); function Hu(i, a, o) { var s = o.map(function (t) { return is(t) ? null : t.key }), t = su(Bu(a.map(function (t) { return t.key })), Bu(s), function (t) { return t }); t.removed.forEach(function (t) { a.splice(t, 1)[0]._unmount() }), t.ordered.forEach(function (t) { var n = t[0], e = t[1], r = a.splice(n, 1)[0]; a.splice(e, 0, r); var i = Yu(r.base), o = Yu(a[e + 1] && a[e + 1].base); i && i.parentNode.insertBefore(i, o) }), t.added.forEach(function (t) { a.splice(t, 0, zu(o[t], s[t], t, i)) }); var n = t.maintained.filter(function (t) { t[0]; var n = t[1], e = o[n], r = a[n]; return (is(e) ? "text_" + e : e.type) !== r.type ? (r._unmount(), a.splice(n, 1, zu(e, s[n], n, i)), !0) : (r.index = n, !1) }); return function () { for (var t = 0, n = 0, e = arguments.length; n < e; n++)t += arguments[n].length; for (var r = Array(t), i = 0, n = 0; n < e; n++)for (var o = arguments[n], a = 0, s = o.length; a < s; a++, i++)r[i] = o[a]; return r }(t.added, n.map(function (t) { t[0]; return t[1] })) } function Vu(i, o, e, r, a, s) { var t = Hu(i, o, e), n = o.filter(function (t, n) { return t._update(r, e[n], a, s) }), u = ju(i); return u && t.reverse().forEach(function (t) { var n, e = o[t], r = Yu(e.base); r && (u === r || r.parentNode || (n = function (t, n) { for (var e = t._providers, r = e.length, i = n.index + 1; i < r; ++i) { var o = Yu(e[i].base); if (o) return o } return null }(i, e), u.insertBefore(r, n))) }), 0 < n.length } var Uu = function (t, n) { return (Uu = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, n) { t.__proto__ = n } || function (t, n) { for (var e in n) n.hasOwnProperty(e) && (t[e] = n[e]) })(t, n) }; var $u = function () { return ($u = Object.assign || function (t) { for (var n, e = 1, r = arguments.length; e < r; e++)for (var i in n = arguments[e]) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]); return t }).apply(this, arguments) }; function Zu(t) { return 180 * (n = [t[0].clientX, t[0].clientY], e = [t[1].clientX, t[1].clientY], r = e[0] - n[0], i = e[1] - n[1], (0 <= (o = Math.atan2(i, r)) ? o : o + 2 * Math.PI) / Math.PI); var n, e, r, i, o } function Ku(t) { return t.touches ? function (t) { for (var n = Math.min(t.length, 2), e = [], r = 0; r < n; ++r)e.push(tc(t[r])); return e }(t.touches) : [tc(t)] } function Ju(t, n, e) { var r = e.length, i = nc(t, r), o = i.clientX, a = i.clientY, s = i.originalClientX, u = i.originalClientY, c = nc(n, r), l = c.clientX, f = c.clientY, p = nc(e, r); return { clientX: s, clientY: u, deltaX: o - l, deltaY: a - f, distX: o - p.clientX, distY: a - p.clientY } } function Qu(t) { return Math.sqrt(Math.pow(t[0].clientX - t[1].clientX, 2) + Math.pow(t[0].clientY - t[1].clientY, 2)) } function tc(t) { return { clientX: t.clientX, clientY: t.clientY } } function nc(t, n) { void 0 === n && (n = t.length); for (var e = { clientX: 0, clientY: 0, originalClientX: 0, originalClientY: 0 }, r = 0; r < n; ++r) { var i = t[r]; e.originalClientX += "originalClientX" in i ? i.originalClientX : i.clientX, e.originalClientY += "originalClientY" in i ? i.originalClientY : i.clientY, e.clientX += i.clientX, e.clientY += i.clientY } return n ? { clientX: e.clientX / n, clientY: e.clientY / n, originalClientX: e.originalClientX / n, originalClientY: e.originalClientY / n } : e } var ec = function () { function t(t) { this.prevClients = [], this.startClients = [], this.movement = 0, this.length = 0, this.startClients = t, this.prevClients = t, this.length = t.length } var n = t.prototype; return n.getAngle = function (t) { return void 0 === t && (t = this.prevClients), Zu(t) }, n.getRotation = function (t) { return void 0 === t && (t = this.prevClients), Zu(t) - Zu(this.startClients) }, n.getPosition = function (t, n) { void 0 === t && (t = this.prevClients); var e = Ju(t || this.prevClients, this.prevClients, this.startClients), r = e.deltaX, i = e.deltaY; return this.movement += Math.sqrt(r * r + i * i), this.prevClients = t, e }, n.getPositions = function (e) { void 0 === e && (e = this.prevClients); var r = this.prevClients; return this.startClients.map(function (t, n) { return Ju([e[n]], [r[n]], [t]) }) }, n.getMovement = function (t) { var n = this.movement; if (!t) return n; var e = nc(t, this.length), r = nc(this.prevClients, this.length), i = e.clientX - r.clientX, o = e.clientY - r.clientY; return Math.sqrt(i * i + o * o) + n }, n.getDistance = function (t) { return void 0 === t && (t = this.prevClients), Qu(t) }, n.getScale = function (t) { return void 0 === t && (t = this.prevClients), Qu(t) / Qu(this.startClients) }, n.move = function (n, e) { this.startClients.forEach(function (t) { t.clientX -= n, t.clientY -= e }) }, t }(), rc = ["textarea", "input"], ic = function (u) { function t() { this.constructor = n } var n, e; function r(t, n) { void 0 === n && (n = {}); var b = u.call(this) || this; b.options = {}, b.flag = !1, b.pinchFlag = !1, b.datas = {}, b.isDrag = !1, b.isPinch = !1, b.isMouse = !1, b.isTouch = !1, b.clientStores = [], b.targets = [], b.prevTime = 0, b.doubleFlag = !1, b._dragFlag = !1, b.onDragStart = function (t, n) { if (void 0 === n && (n = !0), b.flag || !1 !== t.cancelable) { var e = b.options, r = e.container, i = e.pinchOutside, o = e.preventRightClick, a = e.preventDefault, s = e.checkInput, u = b.isTouch, c = !b.flag; if (c) { var l, f = document.activeElement, p = t.target, d = p.tagName.toLowerCase(), h = -1 < rc.indexOf(d), v = p.isContentEditable; if (h || v) { if (s || f === p) return !1; if (f && v && f.isContentEditable && f.contains(p)) return !1 } else { (a || "touchstart" === t.type) && f && (l = f.tagName, (f.isContentEditable || -1 < rc.indexOf(l)) && f.blur()) } if (b.clientStores = [new ec(Ku(t))], b.flag = !0, b.isDrag = !1, b._dragFlag = !0, b.datas = {}, o && (3 === t.which || 2 === t.button)) return b.initDrag(), !1; b.doubleFlag = hs() - b.prevTime < 200, !1 === b.emit("dragStart", $u({ datas: b.datas, inputEvent: t, isTrusted: n, isDouble: b.doubleFlag }, b.getCurrentStore().getPosition(), { preventDefault: function () { t.preventDefault() }, preventDrag: function () { b._dragFlag = !1 } })) && b.initDrag(), b.flag && a && t.preventDefault() } if (!b.flag) return !1; var g, m = 0; if (c && u && i && (m = setTimeout(function () { Ps(r, "touchstart", b.onDragStart, { passive: !1 }) })), !c && u && i && _s(r, "touchstart", b.onDragStart), b.flag && ((g = t).touches && 2 <= g.touches.length)) { if (clearTimeout(m), c && t.touches.length !== t.changedTouches.length) return; b.pinchFlag || b.onPinchStart(t) } } }, b.onDrag = function (t, n) { if (b.flag) { var e = Ku(t), r = b.moveClients(e, t, !1); if (b._dragFlag) { if (b.pinchFlag || r.deltaX || r.deltaY) if (!1 === b.emit("drag", $u({}, r, { isScroll: !!n, inputEvent: t }))) return void b.stop(); b.pinchFlag && b.onPinch(t, e) } b.getCurrentStore().getPosition(e, !0) } }, b.onDragEnd = function (t) { var n, e, r, i, o, a; b.flag && (e = (n = b.options).pinchOutside, r = n.container, b.isTouch && e && _s(r, "touchstart", b.onDragStart), b.flag = !1, i = b._getPosition(), o = hs(), a = !b.isDrag && b.doubleFlag, b.prevTime = b.isDrag || a ? 0 : o, b.emit("dragEnd", $u({ datas: b.datas, isDouble: a, isDrag: b.isDrag, isClick: !b.isDrag, inputEvent: t }, i)), b.pinchFlag && b.onPinchEnd(t), b.clientStores = []) }, b.onBlur = function () { b.onDragEnd() }; var e = [].concat(t); b.options = $u({ checkInput: !1, container: 1 < e.length ? window : e[0], preventRightClick: !0, preventDefault: !0, checkWindowBlur: !1, pinchThreshold: 0, events: ["touch", "mouse"] }, n); var r, i = b.options, o = i.container, a = i.events, s = i.checkWindowBlur; return b.isTouch = -1 < a.indexOf("touch"), b.isMouse = -1 < a.indexOf("mouse"), b.targets = e, b.isMouse && (e.forEach(function (t) { Ps(t, "mousedown", b.onDragStart) }), Ps(o, "mousemove", b.onDrag), Ps(o, "mouseup", b.onDragEnd), Ps(o, "contextmenu", b.onDragEnd)), s && Ps(window, "blur", b.onBlur), b.isTouch && (r = { passive: !1 }, e.forEach(function (t) { Ps(t, "touchstart", b.onDragStart, r) }), Ps(o, "touchmove", b.onDrag, r), Ps(o, "touchend", b.onDragEnd, r), Ps(o, "touchcancel", b.onDragEnd, r)), b } Uu(n = r, e = u), n.prototype = null === e ? Object.create(e) : (t.prototype = e.prototype, new t); var i = r.prototype; return i.stop = function () { this.isDrag = !1, this.flag = !1, this.clientStores = [], this.datas = {} }, i.getMovement = function (t) { return this.getCurrentStore().getMovement(t) + this.clientStores.slice(1).reduce(function (t, n) { return t + n.movement }, 0) }, i.isDragging = function () { return this.isDrag }, i.isFlag = function () { return this.flag }, i.isPinchFlag = function () { return this.pinchFlag }, i.isDoubleFlag = function () { return this.doubleFlag }, i.isPinching = function () { return this.isPinch }, i.scrollBy = function (t, n, e, r) { void 0 === r && (r = !0), this.flag && (this.clientStores[0].move(t, n), r && this.onDrag(e, !0)) }, i.move = function (t, n) { var r = t[0], i = t[1], e = this.getCurrentStore().prevClients; return this.moveClients(e.map(function (t) { var n = t.clientX, e = t.clientY; return { clientX: n + r, clientY: e + i, originalClientX: n, originalClientY: e } }), n, !0) }, i.triggerDragStart = function (t) { this.onDragStart(t, !1) }, i.setEventDatas = function (t) { var n = this.datas; for (var e in t) n[e] = t[e]; return this }, i.getCurrentEvent = function (t) { return $u({ datas: this.datas }, this._getPosition(), { movement: this.getMovement(), isDrag: this.isDrag, isPinch: this.isPinch, isScroll: !1, inputEvent: t }) }, i.getEventDatas = function () { return this.datas }, i.unset = function () { var n = this, t = this.targets, e = this.options.container; this.off(), _s(window, "blur", this.onBlur), this.isMouse && (t.forEach(function (t) { _s(t, "mousedown", n.onDragStart) }), _s(e, "mousemove", this.onDrag), _s(e, "mouseup", this.onDragEnd), _s(e, "contextmenu", this.onDragEnd)), this.isTouch && (t.forEach(function (t) { _s(t, "touchstart", n.onDragStart) }), _s(e, "touchstart", this.onDragStart), _s(e, "touchmove", this.onDrag), _s(e, "touchend", this.onDragEnd), _s(e, "touchcancel", this.onDragEnd)) }, i.onPinchStart = function (t) { var n, e = this.options.pinchThreshold; this.isDrag && this.getMovement() > e || (n = new ec(Ku(t)), this.pinchFlag = !0, this.clientStores.splice(0, 0, n), !1 === this.emit("pinchStart", $u({ datas: this.datas, angle: n.getAngle(), touches: this.getCurrentStore().getPositions() }, n.getPosition(), { inputEvent: t })) && (this.pinchFlag = !1)) }, i.onPinch = function (t, n) { var e; !this.flag || !this.pinchFlag || n.length < 2 || (e = this.getCurrentStore(), this.isPinch = !0, this.emit("pinch", $u({ datas: this.datas, movement: this.getMovement(n), angle: e.getAngle(n), rotation: e.getRotation(n), touches: e.getPositions(n), scale: e.getScale(n), distance: e.getDistance(n) }, e.getPosition(n), { inputEvent: t }))) }, i.onPinchEnd = function (t) { var n, e; this.pinchFlag && (n = this.isPinch, this.isPinch = !1, this.pinchFlag = !1, e = this.getCurrentStore(), this.emit("pinchEnd", $u({ datas: this.datas, isPinch: n, touches: e.getPositions() }, e.getPosition(), { inputEvent: t })), this.isPinch = !1, this.pinchFlag = !1) }, i.initDrag = function () { this.clientStores = [], this.pinchFlag = !1, this.doubleFlag = !1, this.prevTime = 0, this.flag = !1 }, i.getCurrentStore = function () { return this.clientStores[0] }, i.moveClients = function (t, n, e) { var r = this._getPosition(t, e); return (r.deltaX || r.deltaY) && (this.isDrag = !0), $u({ datas: this.datas }, r, { movement: this.getMovement(t), isDrag: this.isDrag, isPinch: this.isPinch, isScroll: !1, inputEvent: n }) }, i._getPosition = function (t, n) { var e = this.getCurrentStore().getPosition(t, n), r = this.clientStores.slice(1).reduce(function (t, n) { var e = n.getPosition(); return t.distX += e.distX, t.distY += e.distY, t }, e), i = r.distX, o = r.distY; return $u({}, e, { distX: i, distY: o }) }, r }(Eu), oc = ['"', "'", '\\"', "\\'"]; function ac(t, n, e, r) { for (var i = e; i < r; ++i) { var o = n[i].trim(); if (o === t) return i; var a = i; if ("(" === o ? a = ac(")", n, i + 1, r) : -1 < oc.indexOf(o) && (a = ac(o, n, i + 1, r)), -1 === a) break; i = a } return -1 } function sc(t) { return function (t, n) { for (var e = new RegExp("(\\s*" + (n || ",") + "\\s*|\\(|\\)|\"|'|\\\\\"|\\\\'|\\s+)", "g"), r = t.split(e).filter(Boolean), i = r.length, o = [], a = [], s = 0; s < i; ++s) { var u = r[s].trim(), c = s; if ("(" === u) c = ac(")", r, s + 1, i); else { if (")" === u) throw new Error("invalid format"); if (-1 < oc.indexOf(u)) c = ac(u, r, s + 1, i); else if (u === n) { a.length && (o.push(a.join("")), a = []); continue } } -1 === c && (c = i - 1), a.push(r.slice(s, c + 1).join("")), s = c } return a.length && o.push(a.join("")), o }(t, ",") } var uc = function (t) { for (var n = 5381, e = t.length; e;)n = 33 * n ^ t.charCodeAt(--e); return n >>> 0 }; function cc(t, n, e, r) { var i, o, a = document.createElement("style"); return a.setAttribute("type", "text/css"), a.setAttribute("data-styled-id", t), e.nonce && a.setAttribute("nonce", e.nonce), a.innerHTML = (i = t, o = n, e.original ? o : o.replace(/([^};{\s}][^};{]*|^\s*){/gm, function (t, n) { var e = n.trim(); return (e ? sc(e) : [""]).map(function (t) { var n = t.trim(); return 0 === n.indexOf("@") ? n : -1 < n.indexOf(":global") ? n.replace(/\:global/g, "") : -1 < n.indexOf(":host") ? "" + n.replace(/\:host/g, "." + i) : n ? "." + i + " " + n : "." + i }).join(", ") + " {" })), (r || document.head || document.body).appendChild(a), a } function lc(o) { var a, s = "rCS" + uc(o).toString(36), u = 0; return { className: s, inject: function (t, n) { void 0 === n && (n = {}); var e, r = function (t) { if (t && t.getRootNode) { var n = t.getRootNode(); if (11 === n.nodeType) return n } }(t), i = 0 === u; return (r || i) && (e = cc(s, o, n, r)), i && (a = e), r || ++u, { destroy: function () { r ? (t.removeChild(e), e = null) : (0 < u && --u, 0 === u && a && (a.parentNode.removeChild(a), a = null)) } } } } } var fc = function (t, n) { return (fc = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, n) { t.__proto__ = n } || function (t, n) { for (var e in n) n.hasOwnProperty(e) && (t[e] = n[e]) })(t, n) }; function pc(t, n) { function e() { this.constructor = t } fc(t, n), t.prototype = null === n ? Object.create(n) : (e.prototype = n.prototype, new e) } var dc = function () { return (dc = Object.assign || function (t) { for (var n, e = 1, r = arguments.length; e < r; e++)for (var i in n = arguments[e]) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]); return t }).apply(this, arguments) }; var hc = function (n) { function t() { var t = null !== n && n.apply(this, arguments) || this; return t.injectResult = null, t.tag = "div", t } pc(t, n); var e = t.prototype; return e.render = function () { var n, e, t = this.props, r = t.className, i = void 0 === r ? "" : r, o = (t.cspNonce, t.portalContainer), a = function (t, n) { var e = {}; for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && n.indexOf(r) < 0 && (e[r] = t[r]); if (null != t && "function" == typeof Object.getOwnPropertySymbols) for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)n.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (e[r[i]] = t[r[i]]); return e }(t, ["className", "cspNonce", "portalContainer"]), s = this.injector.className, u = this.tag, c = {}; return -1 < "simple-1.1.0".indexOf("simple") && o && (c = { portalContainer: o }), ku(u, dc({ ref: (n = this, e = "element", function (t) { t && (n[e] = t) }), "data-styled-id": s, className: i + " " + s }, c, a)) }, e.componentDidMount = function () { this.injectResult = this.injector.inject(this.element, { nonce: this.props.cspNonce }) }, e.componentWillUnmount = function () { this.injectResult.destroy(), this.injectResult = null }, e.getElement = function () { return this.element }, t }(qu); var vc = function () { return (vc = Object.assign || function (t) { for (var n, e = 1, r = arguments.length; e < r; e++)for (var i in n = arguments[e]) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]); return t }).apply(this, arguments) }; var gc = function () { function t() { this._events = {} } var n = t.prototype; return n.on = function (t, n) { if (es(t)) for (var e in t) this.on(e, t[e]); else this._addEvent(t, n, {}); return this }, n.off = function (t, n) { if (t) if (es(t)) for (var e in t) this.off(e); else { var r, i; n ? !(r = this._events[t]) || -1 < (i = vs(r, function (t) { return t.listener === n })) && r.splice(i, 1) : this._events[t] = [] } else this._events = {}; return this }, n.once = function (n, t) { var e = this; return t && this._addEvent(n, t, { once: !0 }), new Promise(function (t) { e._addEvent(n, t, { once: !0 }) }) }, n.emit = function (n, e) { var r = this; void 0 === e && (e = {}); var t = this._events[n]; if (!n || !t) return !0; var i = !1; return e.eventType = n, e.stop = function () { i = !0 }, e.currentTarget = this, function () { for (var t = 0, n = 0, e = arguments.length; n < e; n++)t += arguments[n].length; for (var r = Array(t), i = 0, n = 0; n < e; n++)for (var o = arguments[n], a = 0, s = o.length; a < s; a++, i++)r[i] = o[a]; return r }(t).forEach(function (t) { t.listener(e), t.once && r.off(n, t.listener) }), !i }, n.trigger = function (t, n) { return void 0 === n && (n = {}), this.emit(t, n) }, n._addEvent = function (t, n, e) { var r = this._events; r[t] = r[t] || [], r[t].push(vc({ listener: n }, e)) }, t }(), mc = function (t, n) { return (mc = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, n) { t.__proto__ = n } || function (t, n) { for (var e in n) Object.prototype.hasOwnProperty.call(n, e) && (t[e] = n[e]) })(t, n) }; var bc = function () { return (bc = Object.assign || function (t) { for (var n, e = 1, r = arguments.length; e < r; e++)for (var i in n = arguments[e]) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]); return t }).apply(this, arguments) }; function xc(t, n, e) { if (e || 2 === arguments.length) for (var r, i = 0, o = n.length; i < o; i++)!r && i in n || ((r = r || Array.prototype.slice.call(n, 0, i))[i] = n[i]); return t.concat(r || Array.prototype.slice.call(n)) } function Ec(t, n) { var e; return bc({ events: {}, props: ((e = {})[t] = Boolean, e), name: t }, n) } var yc, Sc, Mc, wc = (void 0 === yc && function () { if ("undefined" != typeof navigator && navigator && navigator.userAgentData) { var t = navigator.userAgentData, n = t.brands || t.uaList; return n && n.length } }() ? function (t) { var n = navigator.userAgentData, e = (n.uaList || n.brands).slice(), r = n.mobile || !1, i = e[0], o = { name: i.brand, version: i.version, majorVersion: -1, webkit: !1, webkitVersion: "-1", chromium: !1, chromiumVersion: "-1", webview: !!Fa(Xa, e).brand }, a = { name: "unknown", version: "-1", majorVersion: -1 }; o.webkit = !o.chromium && za(Ya, function (t) { return Ia(e, t) }); var s, u, c, l = Fa(ja, e); o.chromium = !!l.brand, o.chromiumVersion = l.version, o.chromium || (s = Fa(Ya, e), o.webkit = !!s.brand, o.webkitVersion = s.version), t && (u = t.platform.toLowerCase(), c = Ga(Wa, function (t) { return new RegExp("" + t.test, "g").exec(u) }), a.name = c ? c.id : u, a.version = t.platformVersion); var f = Fa(Na, e); return f.brand && (o.name = f.brand, o.version = t ? t.uaFullVersion : f.version), "Linux armv8l" === navigator.platform ? a.name = "android" : o.webkit && (a.name = r ? "ios" : "mac"), "ios" === a.name && o.webview && (o.version = "-1"), a.version = ka(a.version), o.version = ka(o.version), a.majorVersion = parseInt(a.version, 10), o.majorVersion = parseInt(o.version, 10), { browser: o, os: a, isMobile: r, isHints: !0 } }() : qa(yc)).browser.webkit, Dc = wc && (Sc = "undefined" == typeof window ? { userAgent: "" } : window.navigator, !!(Mc = /applewebkit\/([^\s]+)/g.exec(Sc.userAgent.toLowerCase())) && parseFloat(Mc[1]) < 605), Cc = "moveable-", Rc = [[0, 1, 2], [1, 0, 3], [2, 0, 3], [3, 1, 2]], Oc = 1e-4, Pc = 1e-7, _c = ["n", "w", "s", "e", "nw", "ne", "sw", "se"], Bc = { n: [0, 1], s: [2, 3], w: [2, 0], e: [1, 3], nw: [0], ne: [1], sw: [2], se: [3] }, zc = { n: 0, s: 180, w: 270, e: 90, nw: 315, ne: 45, sw: 225, se: 135 }; function Gc(t, n, e, r, i) { var o = n.gesto.move(e, t.inputEvent), a = o.originalDatas || o.datas, s = a.draggable || (a.draggable = {}); return bc(bc({}, i ? np(n, o) : o), { isDrag: !0, isPinch: !!r, parentEvent: !0, datas: s, originalDatas: t.originalDatas }) } var Tc = function () { function t() { this.prevX = 0, this.prevY = 0, this.startX = 0, this.startY = 0, this.isDrag = !1, this.isFlag = !1, this.datas = { draggable: {} } } var n = t.prototype; return n.dragStart = function (t, n) { this.isDrag = !1, this.isFlag = !1; var e = n.originalDatas; return (this.datas = e).draggable || (e.draggable = {}), bc(bc({}, this.move(t, n.inputEvent)), { type: "dragstart" }) }, n.drag = function (t, n) { return this.move([t[0] - this.prevX, t[1] - this.prevY], n) }, n.move = function (t, n) { var e, r; return this.isFlag ? (e = this.prevX + t[0], r = this.prevY + t[1], this.isDrag = !0) : (this.prevX = t[0], this.prevY = t[1], this.startX = t[0], this.startY = t[1], e = t[0], r = t[1], this.isFlag = !0), { type: "drag", clientX: this.prevX = e, clientY: this.prevY = r, inputEvent: n, isDrag: this.isDrag, distX: e - this.startX, distY: r - this.startY, deltaX: t[0], deltaY: t[1], datas: this.datas.draggable, originalDatas: this.datas, parentEvent: !0, parentGesto: this } }, t }(); function kc(t, e, r) { var n = r.originalDatas; n.groupable = n.groupable || {}; var i = n.groupable; i.childDatas = i.childDatas || []; var o = i.childDatas; return t.moveables.map(function (t, n) { return o[n] = o[n] || {}, o[n][e] = o[n][e] || {}, bc(bc({}, r), { datas: o[n][e], originalDatas: o[n] }) }) } function Ac(t, o, a, s, n, u) { var c = !!a.match(/Start$/g), l = !!a.match(/End$/g), f = n.isPinch, p = n.datas, e = kc(t, o.name, n), d = t.moveables, r = e.map(function (t, n) { var e = d[n], r = t, r = c ? (new Tc).dragStart(s, t) : (e.state.gesto || (e.state.gesto = p.childGestos[n]), Gc(t, e.state, s, f, u)), i = o[a](e, bc(bc({}, r), { parentFlag: !0 })); return l && (e.state.gesto = null), i }); return c && (p.childGestos = d.map(function (t) { return t.state.gesto })), r } function Fc(t, o, a, n, s, u) { void 0 === s && (s = function (t, n) { return n }); var c = !!a.match(/End$/g), e = kc(t, o.name, n), l = t.moveables; return e.map(function (t, n) { var e = l[n], r = s(e, t), i = o[a](e, bc(bc({}, r), { parentFlag: !0 })); return i && u && u(e, t, i, n), c && (e.state.gesto = null), i }) } function Ic(t, n, r, i) { void 0 === i && (i = ""); var e = t.state, o = e.renderPoses, a = e.rotation, s = e.direction, u = t.props, c = u.renderDirections, l = void 0 === c ? n : c, f = u.zoom, p = {}; if (!l) return []; var d = 0 < s ? 1 : -1, h = !0 === l ? _c : l, v = a / Math.PI * 180; return h.forEach(function (t) { p[t] = !0 }), h.map(function (t) { var n = Bc[t]; if (!n || !p[t]) return null; var e = (Cs(v, 15) + d * zc[t] + 720) % 180; return r.createElement("div", { className: vf("control", "direction", t, i), "data-rotation": e, "data-direction": t, key: "direction-".concat(t), style: Af.apply(void 0, xc([a, f], n.map(function (t) { return o[t] }), !1)) }) }) } function Nc(t, n, e, r, i, o) { for (var a = [], s = 6; s < arguments.length; s++)a[s - 6] = arguments[s]; var u = Ms(e, r), c = n ? Cs(u / Math.PI * 180, 15) % 180 : -1; return t.createElement("div", { key: "line".concat(o), className: vf.apply(void 0, xc(["line", "direction", n], a, !1)), "data-rotation": c, "data-line-index": o, "data-direction": n, style: kf(e, r, i, u) }) } function jc(t, n) { return Ic(t, _c, n) } function Yc(t, n) { return Ic(t, ["nw", "ne", "sw", "se"], n) } function Xc(t, n, e, r, i, o) { var a = t.state.is3d ? 4 : 3, s = Of(t.state.rootMatrix, i, a), u = Fs([o.left, o.top], s); n.startAbsoluteOrigin = u, n.prevDeg = Ms(u, [e, r]) / Math.PI * 180, n.defaultDeg = n.prevDeg, n.prevSnapDeg = 0, n.loop = 0 } function Wc(t, n, e) { var r = e.defaultDeg, i = e.prevDeg, o = i % 360, a = Math.floor(i / 360); o < 0 && (o += 360), t < o && 270 < o && t < 90 ? ++a : o < t && o < 90 && 270 < t && --a; var s = n * (360 * a + t - r); return e.prevDeg = r + s, s } function qc(t, n, e, r) { return Wc(Ms(r.startAbsoluteOrigin, [t, n]) / Math.PI * 180, e, r) } function Lc(t, n, e, r, i, o) { var a = t.props.throttleRotate, s = void 0 === a ? 0 : a, u = r, c = e.prevSnapDeg; o && (u = function (t, n, e, r) { if (!Jc(t, "rotatable")) return r; var i = n.pos1, o = n.pos2, a = n.pos3, s = n.pos4, u = r * Math.PI / 180, c = [i, o, a, s].map(function (t) { return Is(t, e) }), l = c.map(function (t) { return Ls(t, u) }), f = xc(xc([], function (t, c, n, e, r) { if (!t.props.bounds) return []; var l = r * Math.PI / 180, i = Sl(t), o = i.left, a = i.top, s = i.right, u = i.bottom, f = o - e[0], p = s - e[0], d = a - e[1], h = u - e[1], v = { left: f, top: d, right: p, bottom: h }; if (!wl(n, v, 0)) return []; var g = []; return [[f, 0], [p, 0], [d, 1], [h, 1]].forEach(function (t) { var s = t[0], u = t[1]; n.forEach(function (t) { var e, n, r, i, o, a = Ms([0, 0], t); g.push.apply(g, (n = s, r = u, i = Gf(e = t), [o = Math.sqrt(i * i - n * n) || 0, -o].sort(function (t, n) { return Math.abs(t - e[r ? 0 : 1]) - Math.abs(n - e[r ? 0 : 1]) }).map(function (t) { return Ms([0, 0], r ? [t, n] : [n, t]) }).map(function (t) { return l + t - a }).filter(function (t) { return !wl(c, v, t) }).map(function (t) { return Cs(180 * t / Math.PI, Pc) }))) }) }), g }(t, c, l, e, r), !0), function (t, n, e, r, i) { var o = t.props.innerBounds, a = i * Math.PI / 180; if (!o) return []; var s = o.left, u = o.top, c = o.width, l = o.height, f = s - r[0], p = s + c - r[0], d = u - r[1], h = u + l - r[1], v = [[f, d], [p, d], [f, h], [p, h]], g = nf(e, [0, 0]); if (!El(e, v, g, 0)) return []; var m = [], b = v.map(function (t) { return [Gf(t), Ms([0, 0], t)] }); return [[e[0], e[1]], [e[1], e[3]], [e[3], e[2]], [e[2], e[0]]].forEach(function (t) { var i = Ms([0, 0], function (t) { var n = t[0], e = t[1], r = e[0] - n[0], i = e[1] - n[1]; if (!r) return [n[0], 0]; if (!i) return [0, n[1]]; var o = i / r, a = -o * n[0] + n[1]; return [-a / (o + 1 / o), a / (o * o + 1)] }(t)), o = function (t) { var n = t[0], e = t[1], r = e[0] - n[0], i = e[1] - n[1]; if (!r) return Math.abs(n[0]); if (!i) return Math.abs(n[1]); var o = i / r; return Math.abs((-o * n[0] + n[1]) / Math.sqrt(Math.pow(o, 2) + 1)) }(t); m.push.apply(m, b.filter(function (t) { var n = t[0]; return n && o <= n }).map(function (t) { var n = t[0], e = t[1], r = Math.acos(n ? o / n : 0); return [a + (e + r) - i, a + (e - r) - i] }).reduce(function (t, n) { return t.push.apply(t, n), t }, []).filter(function (t) { return !El(n, v, g, t) }).map(function (t) { return Cs(180 * t / Math.PI, Pc) })) }), m }(t, c, l, e, r), !0); return f.sort(function (t, n) { return Math.abs(t - r) - Math.abs(n - r) }), f.length ? f[0] : r }(t, n, e.origin, u)); var l = Cs(i + u, s), f = l - i; return [(e.prevSnapDeg = f) - c, u, l] } function Hc(t, n) { if (n.isRequest) return "rotatable" === n.requestAble; var e = n.inputEvent.target; if (Os(e, vf("rotation-control"))) return !0; var r, i, o = t.props.rotationTarget; return !!o && (i = !0, ((r = o) ? (function (t) { if (!t || !es(t)) return !1; if (t instanceof Element) return !1; return rs(t) || "length" in t }(r) ? [].slice.call(r) : [r]).reduce(function (t, n) { return is(n) && i ? xc(xc([], t, !0), [].slice.call(document.querySelectorAll(n)), !0) : (t.push(ap(n, i)), t) }, []) : []).some(function (t) { return !!t && (e === t || e.contains(t)) })) } var Vc = { name: "rotatable", canPinch: !0, props: { rotatable: Boolean, rotationPosition: String, throttleRotate: Number, renderDirections: Object, rotationTarget: Object }, events: { onRotateStart: "rotateStart", onBeforeRotate: "beforeRotate", onRotate: "rotate", onRotateEnd: "rotateEnd", onRotateGroupStart: "rotateGroupStart", onBeforeRotateGroup: "beforeRotateGroup", onRotateGroup: "rotateGroup", onRotateGroupEnd: "rotateGroupEnd" }, css: [".rotation {\n            position: absolute;\n            height: 40px;\n            width: 1px;\n            transform-origin: 50% 100%;\n            height: calc(40px * var(--zoom));\n            top: auto;\n            left: 0;\n            bottom: 100%;\n            will-change: transform;\n        }\n        .rotation .rotation-line {\n            display: block;\n            width: 100%;\n            height: 100%;\n            transform-origin: 50% 50%;\n        }\n        .rotation .rotation-control {\n            border-color: #4af;\n            border-color: var(--moveable-color);\n            background:#fff;\n            cursor: alias;\n        }"], render: function (t, n) { var e = t.props, r = e.rotatable, i = e.rotationPosition, o = e.zoom, a = e.renderDirections, s = t.state, u = s.renderPoses, c = s.direction; if (!r) return null; var l, f, p = function (t, n, e) { var r = n[0], i = n[1], o = n[2], a = n[3]; if ("none" !== t) { var s = (t || "top").split("-"), u = s[0], c = s[1], l = [r, i]; "left" === u ? l = [o, r] : "right" === u ? l = [i, a] : "bottom" === u && (l = [a, o]); var f, p, d = [(l[0][0] + l[1][0]) / 2, (l[0][1] + l[1][1]) / 2], h = If(l, e); return c && (p = "bottom" === u || "left" === u, d = l[(f = "top" === c || "left" === c) && !p || !f && p ? 0 : 1]), [d, h] } }(i, u, c), d = []; return p && (l = p[0], f = p[1], d.push(n.createElement("div", { key: "rotation", className: vf("rotation"), style: { transform: "translate(-50%) translate(".concat(l[0], "px, ").concat(l[1], "px) rotate(").concat(f, "rad)") } }, n.createElement("div", { className: vf("line rotation-line"), style: { transform: "scaleX(".concat(o, ")") } }), n.createElement("div", { className: vf("control rotation-control"), style: { transform: "translate(0.5px) scale(".concat(o, ")") } })))), a && d.push.apply(d, Ic(t, [], n)), d }, dragControlCondition: Hc, dragControlStart: function (t, n) { var e = n.datas, r = n.clientX, i = n.clientY, o = n.parentRotate, a = n.parentFlag, s = n.isPinch, u = n.isRequest, c = t.state, l = c.target, f = c.left, p = c.top, d = c.origin, h = c.beforeOrigin, v = c.direction, g = c.beforeDirection, m = c.targetTransform, b = c.moveableClientRect; if (!u && !l) return !1; var x, E = t.getRect(); e.rect = E, e.transform = m, e.left = f, e.top = p, e.fixedPosition = pf(t, ff(t)), u || s || a ? (x = o || 0, e.beforeInfo = { origin: E.beforeOrigin, prevDeg: x, defaultDeg: x, prevSnapDeg: 0 }, e.afterInfo = bc(bc({}, e.beforeInfo), { origin: E.origin }), e.absoluteInfo = bc(bc({}, e.beforeInfo), { origin: E.origin, startValue: x })) : (e.beforeInfo = { origin: E.beforeOrigin }, e.afterInfo = { origin: E.origin }, e.absoluteInfo = { origin: E.origin, startValue: E.rotation }, Xc(t, e.beforeInfo, r, i, h, b), Xc(t, e.afterInfo, r, i, d, b), Xc(t, e.absoluteInfo, r, i, d, b)), e.direction = v, e.beforeDirection = g, e.startValue = 0, e.datas = {}, of(n, "rotate"); var y = Hf(t, n, bc(bc({ set: function (t) { e.startValue = t * Math.PI / 180 } }, rf(n)), { dragStart: Ll.dragStart(t, (new Tc).dragStart([0, 0], n)) })), S = $f(t, "onRotateStart", y); return e.isRotate = !1 !== S, t.state.snapRenderInfo = { request: n.isRequest }, !!e.isRotate && y }, dragControl: function (t, n) { var e, r, i, o = n.datas, a = n.clientX, s = n.clientY, u = n.parentRotate, c = n.parentFlag, l = n.isPinch, f = n.groupDelta, p = o.beforeDirection, d = o.beforeInfo, h = o.afterInfo, v = o.absoluteInfo, g = o.isRotate, m = o.startValue, b = o.rect; if (g) { Ul(n, "rotate"); var x, E, y, S, M, w, D, C, R, O, P = p * zf(n.datas.beforeTransform, [50, 50], 100, 100).direction, _ = t.props.parentMoveable, B = 180 / Math.PI * m, z = v.startValue, G = !1; if (!c && "parentDist" in n ? (D = n.parentDist, O = R = C = D) : l || c ? (C = Wc(u, p, d), R = Wc(u, P, h), O = Wc(u, P, v)) : (C = qc(a, s, p, d), R = qc(a, s, P, h), O = qc(a, s, P, v), G = !0), $f(t, "onBeforeRotate", Hf(t, n, { beforeRotation: B + C, rotation: B + R, absoluteRotation: z + O, setRotation: function (t) { O = C = R = t - B } }, !0)), x = (e = Lc(t, b, d, C, B, G))[0], C = e[1], E = e[2], y = (r = Lc(t, b, h, R, B, G))[0], R = r[1], S = r[2], M = (i = Lc(t, b, v, O, z, G))[0], O = i[1], w = i[2], M || y || x || _) { var T, k, A, F, I, N = $l(o, "rotate(".concat(S, "deg)"), "rotate(".concat(R, "deg)")), j = (T = t, k = R, A = o.fixedPosition, F = o, I = ff(T), lf(T, "rotate(".concat(k, "deg)"), I, A, F)), Y = Is(Fs(f || [0, 0], j), o.prevInverseDist || [0, 0]); o.prevInverseDist = j, o.requestValue = null; var X = Hf(t, n, bc({ delta: y, dist: R, rotate: S, rotation: S, beforeDist: C, beforeDelta: x, beforeRotate: E, beforeRotation: E, absoluteDist: O, absoluteDelta: M, absoluteRotate: w, absoluteRotation: w, isPinch: !!l }, cf(t, N, Y, l, n))); return $f(t, "onRotate", X), X } } }, dragControlAfter: function (t, n) { n.datas.requestValue }, dragControlEnd: function (t, n) { var e = n.datas; if (e.isRotate) { e.isRotate = !1; var r = Vf(t, n, {}); return $f(t, "onRotateEnd", r), r } }, dragGroupControlCondition: Hc, dragGroupControlStart: function (t, n) { var e = n.datas, r = t.state, s = r.left, u = r.top, c = r.beforeOrigin, i = this.dragControlStart(t, n); if (!i) return !1; i.set(e.beforeDirection * t.rotation); var o = Fc(t, this, "dragControlStart", n, function (t, n) { var e = t.state, r = e.left, i = e.top, o = e.beforeOrigin, a = Fs(Is([r, i], [s, u]), Is(o, c)); return n.datas.groupClient = a, bc(bc({}, n), { parentRotate: 0 }) }), a = $f(t, "onRotateGroupStart", bc(bc({}, i), { targets: t.props.targets, events: o })); return e.isRotate = !1 !== a, !!e.isRotate && i }, dragGroupControl: function (n, e) { var t = e.datas; if (t.isRotate) { Uf(n, "onBeforeRotate", function (t) { $f(n, "onBeforeRotateGroup", Hf(n, e, bc(bc({}, t), { targets: n.props.targets }), !0)) }); var r = this.dragControl(n, e); if (r) { var c = t.beforeDirection, l = r.beforeDist, f = r.beforeDelta / 180 * Math.PI, i = Fc(n, this, "dragControl", e, function (t, n) { var e = n.datas.groupClient, r = e[0], i = e[1], o = Ls([r, i], f * c), a = o[0], s = o[1], u = [a - r, s - i]; return n.datas.groupClient = [a, s], bc(bc({}, n), { parentRotate: l, groupDelta: u }) }); n.rotation = c * r.beforeRotation; var o = bc({ targets: n.props.targets, events: i, set: function (t) { n.rotation = t }, setGroupRotation: function (t) { n.rotation = t } }, r); return $f(n, "onRotateGroup", o), o } } }, dragGroupControlEnd: function (t, n) { var e = n.isDrag; if (n.datas.isRotate) { this.dragControlEnd(t, n); var r = Fc(t, this, "dragControlEnd", n); return $f(t, "onRotateGroupEnd", Vf(t, n, { targets: t.props.targets, events: r })), e } }, request: function (t) { var n = {}, e = 0, r = t.getRotation(); return { isControl: !0, requestStart: function () { return { datas: n } }, request: function (t) { return "deltaRotate" in t ? e += t.deltaRotate : "rotate" in t && (e = t.rotate - r), { datas: n, parentDist: e } }, requestEnd: function () { return { datas: n, isDrag: !0 } } } } }, Uc = ["left", "right", "center"], $c = ["top", "bottom", "middle"], Zc = { start: "left", end: "right", center: "center" }, Kc = { start: "top", end: "bottom", center: "middle" }; function Jc(t, n) { var e = t.props, r = e.snappable, i = e.bounds, o = e.innerBounds, a = e.verticalGuidelines, s = e.horizontalGuidelines, u = e.snapGridWidth, c = e.snapGridHeight, l = t.state, f = l.guidelines, p = l.enableSnap; return r && p && !(n && !0 !== r && r.indexOf(n) < 0) && !!(u || c || i || o || f && f.length || a && a.length || s && s.length) } function Qc(t) { return !1 === t ? {} : !0 !== t && t ? t : { left: !0, right: !0, top: !0, bottom: !0 } } function tl(t, n) { var e = function (t, n) { var e = Qc(t), r = {}; for (var i in e) i in n && e[i] && (r[i] = n[i]); return r }(t, n), r = $c.filter(function (t) { return t in e }), i = Uc.filter(function (t) { return t in e }); return { horizontal: r.map(function (t) { return e[t] }), vertical: i.map(function (t) { return e[t] }) } } function nl(t, n, e, r, i, o, a) { void 0 === i && (i = 0), void 0 === o && (o = 0), void 0 === a && (a = { left: 0, top: 0, right: 0, bottom: 0 }); var s = [], u = a.left, c = a.top, l = a.bottom, f = e + a.right - u, p = r + l - c; return t && t.forEach(function (t) { s.push({ type: "horizontal", pos: [u, Cs(t - o + c, .1)], size: f }) }), n && n.forEach(function (t) { s.push({ type: "vertical", pos: [Cs(t - i + u, .1), c], size: p }) }), s } function el(t, n) { if (!n.length) return []; var e, r, i, o = t.state, a = o.containerClientRect, s = o.targetClientRect, u = s.top, c = s.left, p = o.rootMatrix, d = o.is3d ? 4 : 3, l = (r = d, i = Of(p, [(e = a).clientLeft, e.clientTop], r), [e.left + i[0], e.top + i[1]]), h = l[0], v = l[1], f = pu(qf(o)), g = Is([f.minX, f.minY], tp(p, [c - h, u - v], d)).map(function (t) { return n = t, Math.round(n % 1 == -.5 ? n - 1 : n); var n }), m = g[0], b = g[1]; return n.map(function (t) { var n = t.element.getBoundingClientRect(), e = n.left - h, r = n.top - v, i = r + n.height, o = e + n.width, a = tp(p, [e, r], d), s = a[0], u = a[1], c = tp(p, [o, i], d), l = c[0], f = c[1]; return bc(bc({}, t), { rect: { left: s + m, right: l + m, top: u + b, bottom: f + b, center: (s + l) / 2 + m, middle: (u + f) / 2 + b } }) }) } function rl(t) { var n = t.state, e = t.props.elementGuidelines, r = void 0 === e ? [] : e; if (!r.length) return n.elementRects = [], []; var i, o, a = (n.elementRects || []).filter(function (t) { return !t.refresh }), s = r.map(function (t) { return es(t) && "element" in t ? t : { element: ap(t, !0) } }).filter(function (t) { return t.element }), u = (i = a.map(function (t) { return t.element }), o = s.map(function (t) { return t.element }), su(i, o, cu)), c = u.maintained, l = u.added, f = []; c.forEach(function (t) { var n = t[0], e = t[1]; f[e] = a[n] }), el(t, l.map(function (t) { return s[t] })).map(function (t, n) { f[l[n]] = t }), n.elementRects = f; var w = Qc(t.props.elementSnapDirections), D = []; return f.forEach(function (n) { var e = n.element, t = n.top, r = void 0 === t ? w.top : t, i = n.left, o = void 0 === i ? w.left : i, a = n.right, s = void 0 === a ? w.right : a, u = n.bottom, c = void 0 === u ? w.bottom : u, l = n.center, f = void 0 === l ? w.center : l, p = n.middle, d = void 0 === p ? w.middle : p, h = n.className, v = n.rect, g = tl({ top: r, right: s, left: o, bottom: c, center: f, middle: d }, v), m = g.horizontal, b = g.vertical, x = v.top, E = v.left, y = v.right - E, S = v.bottom - x, M = [y, S]; b.forEach(function (t) { D.push({ type: "vertical", element: e, pos: [Cs(t, .1), x], size: S, sizes: M, className: h, elementRect: n }) }), m.forEach(function (t) { D.push({ type: "horizontal", element: e, pos: [E, Cs(t, .1)], size: y, sizes: M, className: h, elementRect: n }) }) }), D } function il(t) { var n, e, r, i, o, a, x, c, E, s = t.state, u = s.snapOffset, l = s.containerClientRect, f = l.overflow, p = l.scrollHeight, d = l.scrollWidth, h = l.clientHeight, v = l.clientWidth, g = l.clientLeft, m = l.clientTop, b = t.props, y = b.snapGap, S = void 0 === y || y, M = b.verticalGuidelines, w = b.horizontalGuidelines, D = b.snapThreshold, C = void 0 === D ? 5 : D, R = b.snapGridWidth, O = void 0 === R ? 0 : R, P = b.snapGridHeight, _ = void 0 === P ? 0 : P, B = xc([], rl(t), !0); return S && (e = (n = _f(qf(t.state))).top, r = n.left, i = n.bottom, o = n.right, B.push.apply(B, (a = { top: e, left: r, bottom: i, right: o, center: (r + o) / 2, middle: (e + i) / 2 }, x = C, c = t.state.elementRects, E = [], [["vertical", Zc, Kc], ["horizontal", Kc, Zc]].forEach(function (t) { var h = t[0], v = t[1], s = t[2], g = a[v.start], m = a[v.end], b = a[v.center], e = a[s.start], r = a[s.end]; function i(t) { var n = t.rect; return n[v.end] < g + x ? g - n[v.end] : m - x < n[v.start] ? n[v.start] - m : -1 } var n = c.filter(function (t) { var n = t.rect; return !(n[s.start] > r || n[s.end] < e) && 0 < i(t) }).sort(function (t, n) { return i(t) - i(n) }), u = []; n.forEach(function (a) { n.forEach(function (t) { var n, e, r, i, o; a !== t && (n = a.rect, e = t.rect, r = n[s.start], i = n[s.end], o = e[s.start], e[s.end] < r || i < o || u.push([a, t])) }) }), u.forEach(function (t) { var n = t[0], e = t[1], r = n.rect, i = e.rect, o = r[v.start], a = r[v.end], s = i[v.start], u = i[v.end], c = 0, l = 0, f = !1, p = !1, d = !1; if (a <= g && m <= s) { if (p = !0, l = a + (c = (s - a - (m - g)) / 2) + (m - g) / 2, Math.abs(l - b) > x) return } else if (a < s && u < g + x) { if (f = !0, l = u + (c = s - a), Math.abs(l - g) > x) return } else { if (!(a < s && m - x < o)) return; if (d = !0, l = o - (c = s - a), Math.abs(l - m) > x) return } c && E.push({ type: h, pos: "vertical" === h ? [l, 0] : [0, l], element: e.element, size: 0, className: e.className, isStart: f, isCenter: p, isEnd: d, gap: c, hide: !0, gapRects: [n, e] }) }) }), E))), B.push.apply(B, function (t, n, e, r, i, o) { void 0 === i && (i = 0); void 0 === o && (o = 0); var a = []; if (n) for (var s = 0; s <= r; s += n)a.push({ type: "horizontal", pos: [0, Cs(s - o, .1)], size: e, hide: !0 }); if (t) for (s = 0; s <= e; s += t)a.push({ type: "vertical", pos: [Cs(s - i, .1), 0], size: r, hide: !0 }); return a }(O, _, f ? d : v, f ? p : h, g, m)), B.push.apply(B, nl(w || !1, M || !1, f ? d : v, f ? p : h, g, m, u)), B } function ol(t, n, e, r) { var i = function () { for (var t = [], n = 0; n < arguments.length; n++)t[n] = arguments[n]; for (var e = t.length - 1, r = 0; r < e; ++r) { var i = t[r]; if (!ns(i)) return i } return t[e] }(r, t.props.snapThreshold, 5); return al(t.state.guidelines, n, e, i) } function al(t, n, e, r) { return { vertical: cl(t, "vertical", n, r), horizontal: cl(t, "horizontal", e, r) } } function sl(t, n, e) { var r = tl(t.props.snapDirections, n); return ol(t, r.vertical, r.horizontal, e) } function ul(t) { var n = t.isSnap; if (!n) return { isSnap: !1, offset: 0, dist: -1, pos: 0, guideline: null }; var e = t.posInfos[0], r = e.guidelineInfos[0], i = r.offset, o = r.dist, a = r.guideline; return { isSnap: n, offset: i, dist: o, pos: e.pos, guideline: a } } function cl(e, i, t, o) { if (!e || !e.length) return { isSnap: !1, index: -1, posInfos: [] }; var a = "vertical" === i ? 0 : 1, n = t.map(function (r, t) { var n = e.map(function (t) { var n = t.pos, e = r - n[a]; return { offset: e, dist: Math.abs(e), guideline: t } }).filter(function (t) { var n = t.guideline, e = t.dist; return !(n.type !== i || o < e) }).sort(function (t, n) { return t.dist - n.dist }); return { pos: r, index: t, guidelineInfos: n } }).filter(function (t) { return 0 < t.guidelineInfos.length }).sort(function (t, n) { return t.guidelineInfos[0].dist - n.guidelineInfos[0].dist }), r = 0 < n.length; return { isSnap: r, index: r ? n[0].index : -1, posInfos: n } } function ll(t, n) { var e = Math.abs(t.offset), r = Math.abs(n.offset); return t.isBound && n.isBound ? r - e : t.isBound ? -1 : n.isBound ? 1 : t.isSnap && n.isSnap ? r - e : t.isSnap ? -1 : n.isSnap || e < Pc ? 1 : r < Pc ? -1 : e - r } function fl(t, a) { return t.slice().sort(function (t, n) { var e = t.sign[a], r = n.sign[a], i = t.offset[a], o = n.offset[a]; return e ? r ? ll({ isBound: t.isBound, isSnap: t.isSnap, offset: i }, { isBound: n.isBound, isSnap: n.isSnap, offset: o }) : -1 : 1 })[0] } function pl(t, n) { var e = Ss([n[0][0], n[1][0]]), r = Ss([n[0][1], n[1][1]]); return { vertical: e <= t[0], horizontal: r <= t[1] } } function dl(t, n) { var e, r, i = n[0], o = n[1], a = o[0] - i[0], s = o[1] - i[1]; return Math.abs(a) < Pc && (a = 0), Math.abs(s) < Pc && (s = 0), r = a ? (e = s ? s / a * (t[0] - i[0]) + i[1] : i[1], t[1]) : (e = i[0], t[0]), e - r } function hl(t, e, r) { void 0 === r && (r = Pc); var i = dl(t[0], e) <= 0; return t.slice(1).every(function (t) { var n = dl(t, e); return n <= 0 == i || Math.abs(n) <= r }) } function vl(t, n, e, r, i) { return void 0 === i && (i = 0), r && n - i <= t || !r && t <= e + i ? { isBound: !0, offset: r ? n - t : e - t } : { isBound: !1, offset: 0 } } function gl(t, n, e, r, i) { var o = t[0], a = t[1], s = n[0], u = n[1], c = ip(a[1] - o[1]), l = ip(a[0] - o[0]), f = ip(u[1] - s[1]); if (!ip(u[0] - s[0])) { if (i && !c) return { isBound: !1, offset: 0 }; if (l) return vl(c / l * (s[0] - o[0]) + o[1], s[1], u[1], e, r); var p = s[0] - o[0]; return { isBound: d = Math.abs(p) <= (r || 0), offset: d ? p : 0 } } if (f) return { isBound: !1, offset: 0 }; if (i && !l) return { isBound: !1, offset: 0 }; if (c) return vl((s[1] - o[1]) / (c / l) + o[0], s[0], u[0], e, r); var d, p = s[1] - o[1]; return { isBound: d = Math.abs(p) <= (r || 0), offset: d ? p : 0 } } function ml(l, t, f, p) { return t.map(function (t) { var e = t[0], n = t[1], r = t[2], i = function (t, n, e) { var r = t.props.innerBounds; if (!r) return { isAllBound: !1, isBound: !1, isVerticalBound: !1, isHorizontalBound: !1, offset: [0, 0] }; var i = r.left, o = r.top, a = r.width, s = r.height, u = [[i, o], [i, o + s]], c = [[i, o], [i + a, o]], l = [[i + a, o], [i + a, o + s]], f = [[i, o + s], [i + a, o + s]], p = pl(e, n), d = p.horizontal, h = p.vertical; if (hl([e, [i, o], [i + a, o], [i, o + s], [i + a, o + s]], n)) return { isAllBound: !1, isBound: !1, isVerticalBound: !1, isHorizontalBound: !1, offset: [0, 0] }; var v = gl(n, c, h), g = gl(n, f, h), m = gl(n, u, d), b = gl(n, l, d), x = v.isBound && g.isBound, E = v.isBound || g.isBound, y = m.isBound && b.isBound, S = m.isBound || b.isBound, M = Qf(v.offset, g.offset), w = Qf(m.offset, b.offset), D = [0, 0], C = !1; return { isAllBound: Math.abs(w) < Math.abs(M) ? (D = [M, 0], C = E, x) : (D = [0, w], C = S, y), isVerticalBound: E, isHorizontalBound: S, isBound: C, offset: D } }(l, [n, r], f), o = i.isBound, a = i.offset, s = i.isVerticalBound, u = i.isHorizontalBound, c = Jl({ datas: p, distX: a[0], distY: a[1] }).map(function (t, n) { return t * (e[n] ? 2 / e[n] : 0) }); return { sign: e, isBound: o, isVerticalBound: s, isHorizontalBound: u, isSnap: !1, offset: c } }) } function bl(t, n, e) { var r, i, o, a, s, u, c, l, f, p, d, h, v, g = ml(t, xl(n, [0, 0], !1).map(function (t) { var n = t[0], e = t[1], r = t[2]; return [n.map(function (t) { return 2 * Math.abs(t) }), e, r] }), nf(n, [0, 0]), e), m = fl(g, 0), b = fl(g, 1), x = 0, E = 0, y = m.isVerticalBound || b.isVerticalBound, S = m.isHorizontalBound || b.isHorizontalBound; return (y || S) && (i = { datas: e, distX: -m.offset[0], distY: -b.offset[1] }, a = i.datas, s = i.distX, u = i.distY, c = a.beforeMatrix, l = a.matrix, f = a.is3d, p = a.startDragBeforeDist, d = a.startDragDist, h = a.absoluteOrigin, v = f ? 4 : 3, x = (r = Is(js(o ? c : l, Fs(o ? p : d, [s, u]), v), h))[0], E = r[1]), { vertical: { isBound: y, offset: x }, horizontal: { isBound: S, offset: E } } } function xl(i, t, n) { return r = n, o = [], a = (e = t)[0], s = e[1], a && s ? o.push([[0, 2 * s], e, [-a, s]], [[2 * a, 0], e, [a, -s]]) : a ? (o.push([[2 * a, 0], [a, 1], [a, -1]]), r && o.push([[0, -1], [a, -1], [-a, -1]], [[0, 1], [a, 1], [-a, 1]])) : s ? (o.push([[0, 2 * s], [1, s], [-1, s]]), r && o.push([[-1, 0], [-1, s], [-1, -s]], [[1, 0], [1, s], [1, -s]])) : o.push([[-1, 0], [-1, -1], [-1, 1]], [[1, 0], [1, -1], [1, 1]], [[0, -1], [-1, -1], [1, -1]], [[0, 1], [-1, 1], [1, 1]]), o.map(function (t) { var n = t[0], e = t[1], r = t[2]; return [n, nf(i, e), nf(i, r)] }); var e, r, o, a, s } function El(t, n, e, r) { var i = r ? t.map(function (t) { return Ls(t, r) }) : t, o = xc([e], n, !0); return [[i[0], i[1]], [i[1], i[3]], [i[3], i[2]], [i[2], i[0]]].some(function (t) { return !hl(o, t) }) } function yl(t, n, e) { var r = t || {}, i = r.position, o = r.left, a = r.top, s = r.right, u = r.bottom, c = { position: void 0 === i ? "client" : i, left: void 0 === o ? -1 / 0 : o, top: void 0 === a ? -1 / 0 : a, right: void 0 === s ? 1 / 0 : s, bottom: void 0 === u ? 1 / 0 : u }; return { vertical: Ml(c, n, !0), horizontal: Ml(c, e, !1) } } function Sl(t, n) { var e = t.state, r = e.containerClientRect, i = r.clientHeight, o = r.clientWidth, a = r.clientLeft, s = r.clientTop, u = e.snapOffset, c = u.left, l = u.top, f = u.right, p = u.bottom, d = n || t.props.bounds || {}, h = "css" === (d.position || "client"), v = d.left, g = d.top, m = d.right, b = void 0 === m ? h ? -1 / 0 : 1 / 0 : m, x = d.bottom, E = void 0 === x ? h ? -1 / 0 : 1 / 0 : x; return h && (b = o + f - c - b, E = i + p - l - E), { left: (void 0 === v ? -1 / 0 : v) + c - a, right: b + c - a, top: (void 0 === g ? -1 / 0 : g) + l - s, bottom: E + l - s } } function Ml(t, n, e) { var r = t[e ? "left" : "top"], i = t[e ? "right" : "bottom"], o = Math.min.apply(Math, n), a = Math.max.apply(Math, n), s = []; return o < r + 1 && s.push({ isBound: !0, offset: o - r, pos: r }), i - 1 < a && s.push({ isBound: !0, offset: a - i, pos: i }), s.length || s.push({ isBound: !1, offset: 0, pos: 0 }), s.sort(function (t, n) { return Math.abs(n.offset) - Math.abs(t.offset) }) } function wl(t, n, e) { return (e ? t.map(function (t) { return Ls(t, e) }) : t).some(function (t) { return t[0] < n.left && .1 < Math.abs(t[0] - n.left) || t[0] > n.right && .1 < Math.abs(t[0] - n.right) || t[1] < n.top && .1 < Math.abs(t[1] - n.top) || t[1] > n.bottom && .1 < Math.abs(t[1] - n.bottom) }) } function Dl(t, n) { return e = bc(bc({}, t), { classNames: xc([vf("line", "guideline", t.direction)], t.classNames, !0).filter(function (t) { return t }), size: t.size || "".concat(t.sizeValue, "px"), pos: t.pos || t.posValue.map(function (t) { return "".concat(Cs(t, .1), "px") }) }), r = n, o = e.direction, a = e.classNames, s = e.size, u = e.pos, c = e.zoom, l = e.key, p = (f = "horizontal" === o) ? "Y" : "X", r.createElement("div", { key: l, className: a.join(" "), style: ((i = {})[f ? "width" : "height"] = "".concat(s), i.transform = "translate(".concat(u[0], ", ").concat(u[1], ") translate").concat(p, "(-50%) scale").concat(p, "(").concat(c, ")"), i) }); var e, r, i, o, a, s, u, c, l, f, p } function Cl(t, o, n, a, s, u, c, l) { var f = t.props.zoom; return n.map(function (t, n) { var e = t.type, r = t.pos, i = [0, 0]; return i[c] = a, i[c ? 0 : 1] = -s + r, Dl({ key: "".concat(o, "TargetGuideline").concat(n), classNames: [vf("target", "bold", e)], posValue: i, sizeValue: u, zoom: f, direction: o }, l) }) } function Rl(t, a, n, s, e, u) { var r = t.props, c = r.zoom, i = r.isDisplayInnerSnapDigit, o = "horizontal" === a ? Zc : Kc, l = e[o.start], f = e[o.end]; return n.filter(function (t) { var n = t.hide, e = t.elementRect; if (n) return !1; if (i && e) { var r = e.rect; if (r[o.start] <= l && f <= r[o.end]) return !1 } return !0 }).map(function (t, n) { var e = t.pos, r = t.size, i = t.element, o = [-s[0] + e[0], -s[1] + e[1]]; return Dl({ key: "".concat(a, "-default-guideline-").concat(n), classNames: i ? [vf("bold")] : [], direction: a, posValue: o, sizeValue: r, zoom: c }, u) }) } function Ol(t, n, e, r, i, o, a, s) { var u, c = t.props, l = c.snapDigit, f = void 0 === l ? 0 : l, p = c.isDisplaySnapDigit, d = void 0 === p || p, h = c.snapDistFormat, v = void 0 === h ? function (t) { return t } : h, g = c.zoom, m = "horizontal" === n ? "X" : "Y", b = "vertical" === n ? "height" : "width", x = Math.abs(i), E = d ? parseFloat(x.toFixed(f)) : 0; return s.createElement("div", { key: "".concat(n, "-").concat(e, "-guideline-").concat(r), className: vf("guideline-group", n), style: ((u = { left: "".concat(o[0], "px"), top: "".concat(o[1], "px") })[b] = "".concat(x, "px"), u) }, Dl({ direction: n, classNames: [vf(e), a], size: "100%", posValue: [0, 0], sizeValue: x, zoom: g }, s), s.createElement("div", { className: vf("size-value", "gap"), style: { transform: "translate".concat(m, "(-50%) scale(").concat(g, ")") } }, 0 < E ? v(E) : "")) } function Pl(M, i, w, D, C) { var R = M.props.isDisplayInnerSnapDigit, O = []; return ["vertical", "horizontal"].forEach(function (s) { var p, t, n, d, o, a, u, c, h, v, g, m, b, e = i.filter(function (t) { return t.type === s }), l = "vertical" === s ? 1 : 0, f = l ? 0 : 1, r = (t = e, d = R, v = "vertical" === (p = s) ? 1 : 0, m = (n = D)[(g = (h = "vertical" === p ? 0 : 1) ? Zc : Kc).start], b = n[g.end], a = function (t) { return t.pos[h] }, u = [], c = [], (o = t).forEach(function (t, n) { var e = a(t, n, o), r = c.indexOf(e), i = u[r] || []; -1 === r && (c.push(e), u.push(i)), i.push(t) }), u.map(function (t) { var l = [], f = []; return t.forEach(function (t) { var n, e, r, i, o, a, s, u = t.element, c = t.elementRect.rect; c[g.end] < m ? l.push(t) : b < c[g.start] ? f.push(t) : c[g.start] <= m && b <= c[g.end] && d && (r = t.pos, i = { element: u, rect: bc(bc({}, c), ((n = {})[g.end] = c[g.start], n)) }, o = { element: u, rect: bc(bc({}, c), ((e = {})[g.start] = c[g.end], e)) }, s = [0, 0], (a = [0, 0])[h] = r[h], a[v] = r[v], s[h] = r[h], s[v] = r[v] + t.size, l.push({ type: p, pos: a, size: 0, elementRect: i }), f.push({ type: p, pos: s, size: 0, elementRect: o })) }), l.sort(function (t, n) { return n.pos[v] - t.pos[v] }), f.sort(function (t, n) { return t.pos[v] - n.pos[v] }), { total: t, start: l, end: f, inner: [] } })), x = l ? Kc : Zc, E = l ? Zc : Kc, y = D[x.start], S = D[x.end]; r.forEach(function (t) { var n = t.total, e = t.start, r = t.end, i = t.inner, a = w[f] + n[0].pos[f] - D[E.start], o = D; e.forEach(function (t) { var n, e = t.elementRect.rect, r = o[x.start] - e[x.end]; 0 < r && ((n = [0, 0])[l] = w[l] + o[x.start] - y - r, n[f] = a, O.push(Ol(M, s, "dashed", O.length, r, n, t.className, C))), o = e }), o = D, r.forEach(function (t) { var n, e = t.elementRect.rect, r = e[x.start] - o[x.end]; 0 < r && ((n = [0, 0])[l] = w[l] + o[x.end] - y, n[f] = a, O.push(Ol(M, s, "dashed", O.length, r, n, t.className, C))), o = e }), i.forEach(function (t) { var n = t.elementRect.rect, e = y - n[x.start], r = n[x.end] - S, i = [0, 0], o = [0, 0]; i[l] = w[l] - e, i[f] = a, o[l] = w[l] + S - y, o[f] = a, O.push(Ol(M, s, "dashed", O.length, e, i, t.className, C)), O.push(Ol(M, s, "dashed", O.length, r, o, t.className, C)) }) }) }), O } function _l(t, n, e, r, i) { var o = function (t, n, e, r) { var i = n[0] - t[0], o = n[1] - t[1]; if (Math.abs(i) < Qa && (i = 0), Math.abs(o) < Qa && (o = 0), !i) return r ? [0, 0] : [0, e]; if (!o) return r ? [e, 0] : [0, 0]; var a = o / i, s = t[1] - a * t[0]; return r ? [e, a * (n[0] + e) + s - n[1]] : [(n[1] + e - s) / a - n[0], e] }(t, n, e, r); if (!o) return { isOutside: !1, offset: [0, 0] }; var a = Ds(t, n), s = Ds(o, t), u = Ds(o, n), c = a < s || a < u, l = Jl({ datas: i, distX: o[0], distY: o[1] }); return { offset: [l[0], l[1]], isOutside: c } } function Bl(t, n) { return t.isBound ? t.offset : n.isSnap ? ul(n).offset : 0 } function zl(t, n, e, r, i, o) { if (!Jc(t, "draggable")) return [{ isSnap: !1, isBound: !1, offset: 0 }, { isSnap: !1, isBound: !1, offset: 0 }]; var a, s, u, c, l, f, p, d, h, v, g, m, b, x, E, y, S, M, w, D = Wf(o.absolutePoses, [n, e]), C = _f(D), R = C.left, O = C.right, P = C.top, _ = C.bottom, B = { horizontal: D.map(function (t) { return t[1] }), vertical: D.map(function (t) { return t[0] }) }, z = Gl(t, i, tl(Qc(t.props.snapDirections), { left: R, right: O, top: P, bottom: _, center: (R + O) / 2, middle: (P + _) / 2 }), B), G = z.vertical, T = z.horizontal, k = bl(t, D, o), A = k.vertical, F = k.horizontal, I = G.isSnap, N = T.isSnap, j = G.isBound || A.isBound, Y = T.isBound || F.isBound, X = Qf(G.offset, A.offset), W = Qf(T.offset, F.offset), q = (a = r, u = [j, Y], c = [I, N], l = [X, W], v = (s = [n, e])[0], g = s[1], m = u[0], b = u[1], x = c[0], E = c[1], y = l[0], S = l[1], M = -y, w = -S, a && v && g ? (w = M = 0, f = [], m && b ? f.push([0, S], [y, 0]) : m ? f.push([y, 0]) : b ? f.push([0, S]) : x && E ? f.push([0, S], [y, 0]) : x ? f.push([y, 0]) : E && f.push([0, S]), f.length && (f.sort(function (t, n) { return Gf(Is([v, g], t)) - Gf(Is([v, g], n)) }), (p = f[0])[0] && Math.abs(v) > Qa ? (M = -p[0], w = g * Math.abs(v + M) / Math.abs(v) - g) : p[1] && Math.abs(g) > Qa && (d = g, w = -p[1], M = v * Math.abs(g + w) / Math.abs(d) - v), a && b && m && (Math.abs(M) > Qa && Math.abs(M) < Math.abs(y) ? (M *= h = Math.abs(y) / Math.abs(M), w *= h) : Math.abs(w) > Qa && Math.abs(w) < Math.abs(S) ? (M *= h = Math.abs(S) / Math.abs(w), w *= h) : (M = Qf(-y, M), w = Qf(-S, w))))) : (M = v || m ? -y : 0, w = g || b ? -S : 0), [M, w]); return [{ isBound: j, isSnap: I, offset: q[0] }, { isBound: Y, isSnap: N, offset: q[1] }] } function Gl(t, n, e, r) { void 0 === r && (r = e); var i = yl(Sl(t), r.vertical, r.horizontal), o = i.horizontal, a = i.vertical, s = n ? { horizontal: { isSnap: !1, index: -1 }, vertical: { isSnap: !1, index: -1 } } : ol(t, e.vertical, e.horizontal), u = s.horizontal, c = s.vertical, l = Bl(o[0], u), f = Bl(a[0], c), p = Math.abs(l), d = Math.abs(f); return { horizontal: { isBound: o[0].isBound, isSnap: u.isSnap, snapIndex: u.index, offset: l, dist: p, bounds: o, snap: u }, vertical: { isBound: a[0].isBound, isSnap: c.isSnap, snapIndex: c.index, offset: f, dist: d, bounds: a, snap: c } } } function Tl(t, n, e, r, i) { var o = yl(n, e, r), a = o.horizontal, s = o.vertical, u = al(t, e, r, i), c = u.horizontal, l = u.vertical, f = Bl(a[0], c), p = Bl(s[0], l), d = Math.abs(f), h = Math.abs(p); return { horizontal: { isBound: a[0].isBound, isSnap: c.isSnap, snapIndex: c.index, offset: f, dist: d, bounds: a, snap: c }, vertical: { isBound: s[0].isBound, isSnap: l.isSnap, snapIndex: l.index, offset: p, dist: h, bounds: s, snap: l } } } function kl(L, H, t, V, U, $) { return t.map(function (t) { var n, e, r, i, o, a, s, u, c, l, f, p, d, h, v = t[0], g = t[1], m = nf(H, v), b = nf(H, g), x = V ? (i = U, o = function (t, n, e) { var r = Sl(t), i = r.left, o = r.top, a = r.right, s = r.bottom, u = e[0], c = e[1], l = Is(e, n), f = l[0], p = l[1]; Math.abs(f) < Pc && (f = 0), Math.abs(p) < Pc && (p = 0); var d, h, v, g, m, b = 0 < p, x = 0 < f, E = { isBound: !1, offset: 0, pos: 0 }, y = { isBound: !1, offset: 0, pos: 0 }; return 0 === f && 0 === p || (0 === f ? b ? s < c && (y.pos = s, y.offset = c - s) : c < o && (y.pos = o, y.offset = c - o) : 0 === p ? x ? a < u && (E.pos = a, E.offset = u - a) : u < i && (E.pos = i, E.offset = u - i) : (d = p / f, h = e[1] - d * u, g = v = 0, m = !1, x && a <= u ? (v = d * a + h, g = a, m = !0) : !x && u <= i && (v = d * i + h, g = i, m = !0), m && (v < o || s < v) && (m = !1), m || (b && s <= c ? (g = ((v = s) - h) / d, m = !0) : !b && c <= o && (g = ((v = o) - h) / d, m = !0)), m && (E.isBound = !0, E.pos = g, E.offset = u - g, y.isBound = !0, y.pos = v, y.offset = c - v))), { vertical: E, horizontal: y } }(n = L, e = m, r = b), a = o.horizontal, s = o.vertical, u = i ? { horizontal: { isSnap: !1 }, vertical: { isSnap: !1 } } : function (t, n, e) { var r = e[0], i = e[1], o = n[0], a = n[1], s = Is(e, n), u = s[0], c = 0 < (f = s[1]), l = 0 < u, u = ip(u), f = ip(f), p = { isSnap: !1, offset: 0, pos: 0 }, d = { isSnap: !1, offset: 0, pos: 0 }; if (0 === u && 0 === f) return { vertical: p, horizontal: d }; var h = ol(t, u ? [r] : [], f ? [i] : []), v = h.vertical, g = h.horizontal; v.posInfos.filter(function (t) { var n = t.pos; return l ? o <= n : n <= o }), g.posInfos.filter(function (t) { var n = t.pos; return c ? a <= n : n <= a }), v.isSnap = 0 < v.posInfos.length, g.isSnap = 0 < g.posInfos.length; var m, b, x, E, y, S = ul(v), M = S.isSnap, w = S.guideline, D = ul(g), C = D.isSnap, R = D.guideline, O = C ? R.pos[1] : 0, P = M ? w.pos[0] : 0; return 0 === u ? C && (d.isSnap = !0, d.pos = R.pos[1], d.offset = i - d.pos) : 0 === f ? M && (p.isSnap = !0, p.pos = P, p.offset = r - P) : (m = f / u, b = e[1] - m * r, E = x = 0, y = !1, M ? (x = m * (E = P) + b, y = !0) : C && (E = ((x = O) - b) / m, y = !0), y && (p.isSnap = !0, p.pos = E, p.offset = r - E, d.isSnap = !0, d.pos = x, d.offset = i - x)), { vertical: p, horizontal: d } }(n, e, r), c = u.horizontal, l = u.vertical, f = Al(a, c), p = Al(s, l), d = Math.abs(f), h = Math.abs(p), { horizontal: { isBound: a.isBound, isSnap: c.isSnap, offset: f, dist: d }, vertical: { isBound: s.isBound, isSnap: l.isSnap, offset: p, dist: h } }) : Gl(L, U, { vertical: [b[0]], horizontal: [b[1]] }), E = x.horizontal, y = E.offset, S = E.isBound, M = E.isSnap, w = x.vertical, D = w.offset, C = w.isBound, R = w.isSnap, O = Is(g, v); if (!D && !y) return { isBound: C || S, isSnap: R || M, sign: O, offset: [0, 0] }; var P, _, B, z, G, T, k, A, F, I, N, j, Y, X = (P = x, _ = V, B = Ms(m, b) / Math.PI * 180, z = P.vertical, G = z.isBound, T = z.isSnap, k = z.dist, A = P.horizontal, F = A.isBound, I = A.isSnap, j = (N = B % 180) < 3 || 177 < N, Y = 87 < N && N < 93, A.dist < k && (G || T && !Y && (!_ || !j)) ? "vertical" : !F && (!I || j || _ && Y) ? "" : "horizontal"); if (!X) return { sign: O, isBound: !1, isSnap: !1, offset: [0, 0] }; var W = "vertical" == X, q = _l(m, b, -(W ? D : y), W, $).offset.map(function (t, n) { return t * (O[n] ? 2 / O[n] : 0) }); return { sign: O, isBound: W ? C : S, isSnap: W ? R : M, offset: q } }) } function Al(t, n) { return t.isBound ? t.offset : n.isSnap ? n.offset : 0 } function Fl(t) { var n, e, r, i, o, a, s, u, c = t.state; c.guidelines && c.guidelines.length || (n = t.state.container, e = t.props.snapContainer || n, r = c.containerClientRect, i = { left: 0, top: 0, bottom: 0, right: 0 }, n === e || (o = ap(e, !0)) && (s = sp(c, [(a = Yf(o)).left - r.left, a.top - r.top]), u = sp(c, [a.right - r.right, a.bottom - r.bottom]), i.left = Cs(s[0], .1), i.top = Cs(s[1], .1), i.right = Cs(u[0], .1), i.bottom = Cs(u[1], .1)), c.snapOffset = i, c.guidelines = il(t), c.enableSnap = !0) } function Il(t, n, e, r, i, o) { var a = Pf(t, n, e, o ? 4 : 3); return Wf(a, Is(i, nf(a, r))) } function Nl(t, n, e, r, i, o) { var a, s, u, c = o.fixedDirection, l = (a = e, s = c, u = [], r ? (1 !== Math.abs(s[0]) || 1 !== Math.abs(s[1]) ? u.push([s, [-1, -1]], [s, [-1, 1]], [s, [1, -1]], [s, [1, 1]]) : u.push([s, [a[0], -a[1]]], [s, [-a[0], a[1]]], [s, a]), u.push([s, a])) : a[0] && a[1] ? u.push([s, [a[0], -a[1]]], [s, [-a[0], a[1]]]) : a[0] ? (1 === Math.abs(s[0]) ? [1] : [1, -1]).forEach(function (t) { u.push([[s[0], -1], [t * a[0], -1]], [[s[0], 0], [t * a[0], 0]], [[s[0], 1], [t * a[0], 1]]) }) : a[1] ? (1 === Math.abs(s[1]) ? [1] : [1, -1]).forEach(function (t) { u.push([[-1, s[1]], [-1, t * a[1]]], [[0, s[1]], [0, t * a[1]]], [[1, s[1]], [1, t * a[1]]]) }) : u.push([s, [1, 0]], [s, [-1, 0]], [s, [0, -1]], [s, [0, 1]], [[1, 0], [1, -1]], [[1, 0], [1, 1]], [[0, 1], [1, 1]], [[0, 1], [-1, 1]], [[-1, 0], [-1, -1]], [[-1, 0], [-1, 1]], [[0, -1], [1, -1]], [[0, -1], [-1, -1]]), u), f = xl(n, e, r), p = xc(xc([], kl(t, n, l, r, i, o), !0), ml(t, f, nf(n, [0, 0]), o), !0), d = fl(p, 0), h = fl(p, 1); return { width: { isBound: d.isBound, offset: d.offset[0] }, height: { isBound: h.isBound, offset: h.offset[1] } } } function jl(t, n, e, r, i, o, a, s) { for (var u, c, l, f, p, d, h, v, g, m, b, x, E, y, S, M, w, D, C, R, O, P, _, B, z, G = qf(t.state), T = t.props.keepRatio, k = 0, A = 0, F = 0; F < 2; ++F) { var I, N, j = Nl(t, n(k, A), i, T, a, s), Y = j.width, X = j.height, W = Y.isBound, q = X.isBound, L = Y.offset, H = X.offset; if (1 === F && (W || (L = 0), q || (H = 0)), 0 === F && a && !W && !q) return [0, 0]; T && (I = Math.abs(L) * (e ? 1 / e : 1), N = Math.abs(H) * (r ? 1 / r : 1), (W && q ? I < N : q || !W && I < N) ? L = e * H / r : H = r * L / e), k += L, A += H } return i[0] && i[1] && (p = t, d = G, v = o, g = s, C = [-(h = i)[0], -h[1]], R = p.state, O = R.width, P = R.height, _ = p.props.bounds, z = B = 1 / 0, _ && (m = [[h[0], -h[1]], [-h[0], h[1]]], b = _.left, x = void 0 === b ? -1 / 0 : b, E = _.top, y = void 0 === E ? -1 / 0 : E, S = _.right, M = void 0 === S ? 1 / 0 : S, w = _.bottom, D = void 0 === w ? 1 / 0 : w, m.forEach(function (t) { var n, e, r, i, o, a, s, u = t[0] !== C[0], c = t[1] !== C[1], l = nf(d, t), f = 360 * Ms(v, l) / Math.PI; c && (i = l.slice(), (Math.abs(f - 360) < 2 || Math.abs(f - 180) < 2) && (i[1] = v[1]), e = (n = _l(v, i, (v[1] < l[1] ? D : y) - l[1], !1, g)).offset[1], r = n.isOutside, isNaN(e) || (z = P + (r ? 1 : -1) * Math.abs(e))), u && (i = l.slice(), (Math.abs(f - 90) < 2 || Math.abs(f - 270) < 2) && (i[0] = v[0]), a = (o = _l(v, i, (v[0] < l[0] ? M : x) - l[0], !0, g)).offset[0], s = o.isOutside, isNaN(a) || (B = O + (s ? 1 : -1) * Math.abs(a))) })), c = (u = { maxWidth: B, maxHeight: z }).maxWidth, l = u.maxHeight, k += L = (f = function (t, n, e, r, i, o, a, s, u) { var c = nf(n, a), l = Gl(t, s, { vertical: [c[0]], horizontal: [c[1]] }), f = l.horizontal.offset, p = l.vertical.offset; if (p || f) { var d = Jl({ datas: u, distX: -p, distY: -f }), h = d[0], v = d[1]; return [Math.min(i || 1 / 0, e + a[0] * h) - e, Math.min(o || 1 / 0, r + a[1] * v) - r] } return [0, 0] }(t, n(k, A).map(function (t) { return t.map(function (t) { return Cs(t, Oc) }) }), e + k, r + A, c, l, i, a, s))[0], A += H = f[1]), [k, A] } function Yl(t, c, n, e, l) { if (!Jc(t, "scalable")) return [0, 0]; var f = l.startOffsetWidth, p = l.startOffsetHeight, d = l.fixedPosition, h = l.fixedDirection, v = l.is3d, r = jl(t, function (t, n) { return Il((e = l, r = Fs(c, [t / f, n / p]), i = e.transformOrigin, o = e.offsetMatrix, a = e.is3d, s = e.targetMatrix, ef(o, As(s, Zs(r, u = a ? 4 : 3), u), i, u)), f, p, h, d, v); var e, r, i, o, a, s, u }, f, p, n, d, e, l); return [r[0] / f, r[1] / p] } function Xl(t) { var e = []; return t.forEach(function (t) { t.guidelineInfos.forEach(function (t) { var n = t.guideline; -1 < e.indexOf(n) || e.push(n) }) }), e } function Wl(t, n, e, i, o, r) { var a = yl(Sl(t, r), n, e), s = a.vertical, u = a.horizontal; s.forEach(function (t) { t.isBound && i.push({ type: "bounds", pos: t.pos }) }), u.forEach(function (t) { t.isBound && o.push({ type: "bounds", pos: t.pos }) }); var c = function (t) { var n = t.props.innerBounds; if (!n) return { vertical: [], horizontal: [] }; var e = t.getRect(), r = e.pos1, i = e.pos2, o = e.pos3, a = e.pos4, u = nf([r, i, o, a], [0, 0]), c = n.left, l = n.top, f = n.width, p = n.height, d = [[c, l], [c, l + p]], h = [[c, l], [c + f, l]], v = [[c + f, l], [c + f, l + p]], g = [[c, l + p], [c + f, l + p]], m = [], b = [], x = { top: !1, bottom: !1, left: !1, right: !1 }; return [[r, i], [i, a], [a, o], [o, r]].forEach(function (t) { var n = pl(u, t), e = n.horizontal, r = n.vertical, i = gl(t, h, r, 1, !0), o = gl(t, g, r, 1, !0), a = gl(t, d, e, 1, !0), s = gl(t, v, e, 1, !0); i.isBound && !x.top && (m.push(l), x.top = !0), o.isBound && !x.bottom && (m.push(l + p), x.bottom = !0), a.isBound && !x.left && (b.push(c), x.left = !0), s.isBound && !x.right && (b.push(c + f), x.right = !0) }), { horizontal: m, vertical: b } }(t), l = c.vertical, f = c.horizontal; l.forEach(function (r) { 0 <= vs(i, function (t) { var n = t.type, e = t.pos; return "bounds" === n && e === r }) || i.push({ type: "bounds", pos: r }) }), f.forEach(function (r) { 0 <= vs(o, function (t) { var n = t.type, e = t.pos; return "bounds" === n && e === r }) || o.push({ type: "bounds", pos: r }) }) } var ql = { name: "snappable", dragRelation: "strong", props: { snappable: [Boolean, Array], snapContainer: Object, snapDirections: [Boolean, Object], elementSnapDirections: [Boolean, Object], snapGap: Boolean, snapGridWidth: Number, snapGridHeight: Number, isDisplaySnapDigit: Boolean, isDisplayInnerSnapDigit: Boolean, snapDigit: Number, snapThreshold: Number, horizontalGuidelines: Array, verticalGuidelines: Array, elementGuidelines: Array, bounds: Object, innerBounds: Object, snapDistFormat: Function }, events: { onSnap: "snap" }, css: [":host {\n    --bounds-color: #d66;\n}\n.guideline {\n    pointer-events: none;\n    z-index: 2;\n}\n.guideline.bounds {\n    background: #d66;\n    background: var(--bounds-color);\n}\n.guideline-group {\n    position: absolute;\n    top: 0;\n    left: 0;\n}\n.guideline-group .size-value {\n    position: absolute;\n    color: #f55;\n    font-size: 12px;\n    font-weight: bold;\n}\n.guideline-group.horizontal .size-value {\n    transform-origin: 50% 100%;\n    transform: translateX(-50%);\n    left: 50%;\n    bottom: 5px;\n}\n.guideline-group.vertical .size-value {\n    transform-origin: 0% 50%;\n    top: 50%;\n    transform: translateY(-50%);\n    left: 5px;\n}\n.guideline.gap {\n    background: #f55;\n}\n.size-value.gap {\n    color: #f55;\n}\n"], render: function (t, n) { var e = t.state, r = e.top, i = e.left, o = e.pos1, a = e.pos2, s = e.pos3, u = e.pos4, c = e.snapRenderInfo; if (!c || !Jc(t, "")) return []; e.guidelines = il(t); var l, f = Math.min(o[0], a[0], s[0], u[0]), p = Math.min(o[1], a[1], s[1], u[1]), d = c.externalPoses || [], h = qf(t.state), v = [], g = [], m = [], b = [], x = [], E = _f(h), y = E.width, S = E.height, M = E.top, w = E.left, D = E.bottom, C = E.right, R = { left: w, right: C, top: M, bottom: D, center: (w + C) / 2, middle: (M + D) / 2 }, O = 0 < d.length, P = O ? _f(d) : {}; c.request || (c.direction && x.push(function (t, n, e) { var r = []; if (e[0] && e[1]) r = [e, [-e[0], e[1]], [e[0], -e[1]]].map(function (t) { return nf(n, t) }); else if (e[0] || e[1]) t.props.keepRatio ? r = [[-1, -1], [-1, 1], [1, -1], [1, 1], e].map(function (t) { return nf(n, t) }) : 1 < (r = tf(n, e)).length && r.push([(r[0][0] + r[1][0]) / 2, (r[0][1] + r[1][1]) / 2]); else for (var i = [n[0], n[1], n[3], n[2], n[0]], o = 0; o < 4; ++o)r.push(i[o]), r.push([(i[o][0] + i[o + 1][0]) / 2, (i[o][1] + i[o + 1][1]) / 2]); return ol(t, r.map(function (t) { return t[0] }), r.map(function (t) { return t[1] }), 1) }(t, h, c.direction)), c.snap && (l = _f(h), c.center && (l.middle = (l.top + l.bottom) / 2, l.center = (l.left + l.right) / 2), x.push(sl(t, l, 1))), O && (c.center && (P.middle = (P.top + P.bottom) / 2, P.center = (P.left + P.right) / 2), x.push(sl(t, P, 1))), x.forEach(function (t) { var n = t.vertical.posInfos, e = t.horizontal.posInfos; v.push.apply(v, n.filter(function (t) { return t.guidelineInfos.some(function (t) { return !t.guideline.hide }) }).map(function (t) { return { type: "snap", pos: t.pos } })), g.push.apply(g, e.filter(function (t) { return t.guidelineInfos.some(function (t) { return !t.guideline.hide }) }).map(function (t) { return { type: "snap", pos: t.pos } })), m.push.apply(m, Xl(n)), b.push.apply(b, Xl(e)) })), Wl(t, [w, C], [M, D], v, g), O && Wl(t, [P.left, P.right], [P.top, P.bottom], v, g, c.externalBounds); var _, B, z, G, T, k, A = xc(xc([], m, !0), b, !0), F = A.filter(function (t) { return t.element && !t.gapRects }), I = A.filter(function (t) { return t.gapRects }); return $f(t, "onSnap", { guidelines: A.filter(function (t) { return !t.element }), elements: F, gaps: I }, !0), xc(xc(xc(xc(xc(xc([], Pl(t, F, [f, p], R, n), !0), (_ = t, B = I, z = [f, p], G = R, T = n, k = [], ["horizontal", "vertical"].forEach(function (n) { var t = B.filter(function (t) { return t.type === n }), s = "vertical" === n ? 0 : 1, u = s ? 0 : 1, c = s ? Kc : Zc, l = s ? Zc : Kc, f = G[c.start], p = G[c.end], d = G[l.start], h = G[l.end]; t.forEach(function (t) { var r = t.gap, n = t.gapRects, i = t.className, e = Math.max.apply(Math, xc([d], n.map(function (t) { return t.rect[l.start] }), !1)), o = Math.min.apply(Math, xc([h], n.map(function (t) { return t.rect[l.end] }), !1)), a = (e + o) / 2; e !== o && a != (d + h) / 2 && n.forEach(function (t) { var n = t.rect, e = [z[0], z[1]]; if (n[c.end] < f) e[s] += n[c.end] - f; else { if (!(p < n[c.start])) return; e[s] += n[c.start] - f - r } e[u] += a - d, k.push(Ol(_, s ? "vertical" : "horizontal", "gap", k.length, r, e, i, T)) }) }) }), k), !0), Rl(t, "horizontal", b, [i, r], R, n), !0), Rl(t, "vertical", m, [i, r], R, n), !0), Cl(t, "horizontal", g, f, r, y, 0, n), !0), Cl(t, "vertical", v, p, i, S, 1, n), !0) }, dragStart: function (t, n) { t.state.snapRenderInfo = { request: n.isRequest, snap: !0, center: !0 }, Fl(t) }, drag: function (t) { t.state.guidelines = il(t) }, pinchStart: function (t) { this.unset(t) }, dragEnd: function (t) { this.unset(t) }, dragControlCondition: function (t, n) { return !(!op(0, n) && !Hc(t, n)) || (!n.isRequest && n.inputEvent ? Os(n.inputEvent.target, vf("snap-control")) : void 0) }, dragControlStart: function (t) { t.state.snapRenderInfo = null, Fl(t) }, dragControl: function (t) { this.drag(t) }, dragControlEnd: function (t) { this.unset(t) }, dragGroupStart: function (t, n) { this.dragStart(t, n) }, dragGroup: function (t) { this.drag(t) }, dragGroupEnd: function (t) { this.unset(t) }, dragGroupControlStart: function (t) { t.state.snapRenderInfo = null, Fl(t) }, dragGroupControl: function (t) { this.drag(t) }, dragGroupControlEnd: function (t) { this.unset(t) }, unset: function (t) { var n = t.state; n.enableSnap = !1, n.guidelines = [], n.snapRenderInfo = null, n.elementRects = [] } }, Ll = { name: "draggable", props: { draggable: Boolean, throttleDrag: Number, throttleDragRotate: Number, startDragRotate: Number, edgeDraggable: Boolean }, events: { onDragStart: "dragStart", onDrag: "drag", onDragEnd: "dragEnd", onDragGroupStart: "dragGroupStart", onDragGroup: "dragGroup", onDragGroupEnd: "dragGroupEnd" }, render: function (t, n) { var e = t.props, r = e.throttleDragRotate, i = e.zoom, o = t.state, a = o.dragInfo, s = o.beforeOrigin; if (!r || !a) return []; var u = a.dist; if (!u[0] && !u[1]) return []; var c = Gf(u), l = Ms(u, [0, 0]); return [n.createElement("div", { className: vf("line", "horizontal", "dragline", "dashed"), key: "dragRotateGuideline", style: { width: "".concat(c, "px"), transform: "translate(".concat(s[0], "px, ").concat(s[1], "px) rotate(").concat(l, "rad) scaleY(").concat(i, ")") } })] }, dragStart: function (t, n) { var e = n.datas, r = n.parentEvent, i = n.parentGesto, o = t.state, a = o.target; if (o.gesto) return !1; o.gesto = i || t.targetGesto; var s, u = Zf(a); e.datas = {}, e.left = parseFloat(u.left || "") || 0, e.top = parseFloat(u.top || "") || 0, e.bottom = parseFloat(u.bottom || "") || 0, e.right = parseFloat(u.right || "") || 0, e.startValue = [0, 0], Vl(t, n), of(n, "translate"), s = t, e.absolutePoses = qf(s.state), e.prevDist = [0, 0], e.prevBeforeDist = [0, 0], e.isDrag = !1, e.deltaOffset = [0, 0]; var c = Hf(t, n, bc({ set: function (t) { e.startValue = t } }, rf(n))); return !1 !== (r || $f(t, "onDragStart", c)) ? (e.isDrag = !0, t.state.dragInfo = { startRect: t.getRect(), dist: [0, 0] }) : (o.gesto = null, e.isPinch = !1), !!e.isDrag && c }, drag: function (t, n) { if (n) { Ul(n, "translate"); var e = n.datas, r = n.parentEvent, i = n.parentFlag, o = n.isPinch, a = n.isRequest, s = n.deltaOffset, u = n.distX, c = n.distY, l = e.isDrag, f = e.prevDist, p = e.prevBeforeDist, d = e.startValue; if (l) { s && (u += s[0], c += s[1]); var h, v, g, m, b, x, E, y, S, M, w, D, C = t.props, R = C.parentMoveable, O = !r && C.throttleDrag || 0, P = !r && C.throttleDragRotate || 0, _ = !1, B = 0; !r && 0 < P && (u || c) && (v = Cs((h = C.startDragRotate || 0) + 180 * Ms([0, 0], [u, c]) / Math.PI, P) - h, g = c * Math.abs(Math.cos((v - 90) / 180 * Math.PI)), m = Gf([u * Math.abs(Math.cos(v / 180 * Math.PI)), g]), B = v * Math.PI / 180, u = m * Math.cos(B), c = m * Math.sin(B)), o || r || i || P && !u && !c || (x = (b = zl(t, u, c, P, a || s, e))[0], E = b[1], y = x.isSnap, S = x.isBound, M = x.offset, w = E.isSnap, D = E.isBound, _ = y || w || S || D, u += M, c += E.offset); var z, G, T, k, A, F, I, N = Fs(Kl({ datas: e, distX: u, distY: c }), d), j = Fs((G = (z = { datas: e, distX: u, distY: c }).datas, T = z.distX, k = z.distY, A = Kl({ datas: G, distX: T, distY: k }), F = A[0], I = A[1], js(Zl(G, function (t, n) { for (var e = $s(n), r = 0; r < n - 1; ++r)e[n * (n - 1) + r] = t[r] || 0; return e }([F, I], 4)), Gs([0, 0, 0], 4), 4)), d); P || _ || (Rs(j, O), Rs(N, O)); var Y = Is(N, d), X = Is(j, d), W = Is(X, f), q = Is(Y, p); e.prevDist = X, e.prevBeforeDist = Y, e.passDelta = W, e.passDist = X; var L = e.left + Y[0], H = e.top + Y[1], V = e.right - Y[0], U = e.bottom - Y[1], $ = $l(e, "translate(".concat(j[0], "px, ").concat(j[1], "px)"), "translate(".concat(X[0], "px, ").concat(X[1], "px)")); if (sf(n, $), t.state.dragInfo.dist = r ? [0, 0] : X, r || R || !W.every(function (t) { return !t }) || !q.some(function (t) { return !t })) { var Z = t.state, K = Hf(t, n, { transform: $, dist: X, delta: W, translate: j, beforeDist: Y, beforeDelta: q, beforeTranslate: N, left: L, top: H, right: V, bottom: U, width: Z.width, height: Z.height, isPinch: o }); return r || $f(t, "onDrag", K), K } } } }, dragAfter: function (t, n) { var e = n.datas, r = e.deltaOffset; return !(!r[0] && !r[1]) && (e.deltaOffset = [0, 0], this.drag(t, bc(bc({}, n), { deltaOffset: r }))) }, dragEnd: function (t, n) { var e = n.parentEvent, r = n.datas; if (t.state.gesto = null, t.state.dragInfo = null, r.isDrag) { r.isDrag = !1; var i = Vf(t, n, {}); return e || $f(t, "onDragEnd", i), i } }, dragGroupStart: function (t, n) { var e = n.datas, r = n.clientX, i = n.clientY, o = this.dragStart(t, n); if (!o) return !1; var a = Ac(t, this, "dragStart", [r || 0, i || 0], n, !1), s = $f(t, "onDragGroupStart", bc(bc({}, o), { targets: t.props.targets, events: a })); return e.isDrag = !1 !== s, !!e.isDrag && o }, dragGroup: function (t, n) { if (n.datas.isDrag) { var e = this.drag(t, n), r = Ac(t, this, "drag", n.datas.passDelta, n, !1); if (e) { var i = bc({ targets: t.props.targets, events: r }, e); return $f(t, "onDragGroup", i), i } } }, dragGroupEnd: function (t, n) { var e = n.isDrag; if (n.datas.isDrag) { this.dragEnd(t, n); var r = Ac(t, this, "dragEnd", [0, 0], n, !1); return $f(t, "onDragGroupEnd", Vf(t, n, { targets: t.props.targets, events: r })), e } }, request: function (t) { var n = {}, e = t.getRect(), r = 0, i = 0; return { isControl: !1, requestStart: function () { return { datas: n } }, request: function (t) { return "x" in t ? r = t.x - e.left : "deltaX" in t && (r += t.deltaX), "y" in t ? i = t.y - e.top : "deltaY" in t && (i += t.deltaY), { datas: n, distX: r, distY: i } }, requestEnd: function () { return { datas: n, isDrag: !0 } } } }, unset: function (t) { t.state.dragInfo = null } }; function Hl(t, n) { var e = n.clientX, r = n.clientY, i = n.datas, o = t.state, a = o.moveableClientRect, s = o.rootMatrix, u = o.is3d, c = o.pos1, l = Is(tp(s, [e - a.left, r - a.top], u ? 4 : 3), c), f = Jl({ datas: i, distX: l[0], distY: l[1] }); return [f[0], f[1]] } function Vl(t, n) { var e = n.datas, r = t.state, i = r.allMatrix, o = r.beforeMatrix, a = r.is3d, s = r.left, u = r.top, c = r.origin, l = r.offsetMatrix, f = r.targetMatrix, p = r.transformOrigin, d = a ? 4 : 3; e.is3d = a, e.matrix = i, e.targetMatrix = f, e.beforeMatrix = o, e.offsetMatrix = l, e.transformOrigin = p, e.inverseMatrix = zs(i, d), e.inverseBeforeMatrix = zs(o, d), e.absoluteOrigin = Gs(Fs([s, u], c), d), e.startDragBeforeDist = js(e.inverseBeforeMatrix, e.absoluteOrigin, d), e.startDragDist = js(e.inverseMatrix, e.absoluteOrigin, d) } function Ul(t, n) { var e = t.datas, r = t.originalDatas.beforeRenderable, i = e.transformIndex, o = r.nextTransforms, a = r.nextTransformAppendedIndexes, s = 0; -1 === i ? (s = o.length, e.transformIndex = s) : s = i + a.filter(function (t) { return t < i }).length; var u, c, l, f, p, d, h, v, g, m, b, x, E, y, S, M, w, D = (c = s, l = (u = o).slice(0, c < 0 ? void 0 : c), f = u.slice(0, c < 0 ? void 0 : c + 1), p = u[c] || "", d = c < 0 ? [] : u.slice(c), h = c < 0 ? [] : u.slice(c + 1), v = nu(l), g = nu(f), m = nu([p]), b = nu(d), x = nu(h), E = tu(v), y = tu(g), S = tu(b), M = tu(x), w = As(E, S, 4), { transforms: u, beforeFunctionMatrix: E, beforeFunctionMatrix2: y, targetFunctionMatrix: tu(m), afterFunctionMatrix: S, afterFunctionMatrix2: M, allFunctionMatrix: w, beforeFunctions: v, beforeFunctions2: g, targetFunction: m[0], afterFunctions: b, afterFunctions2: x, beforeFunctionTexts: l, beforeFunctionTexts2: f, targetFunctionText: p, afterFunctionTexts: d, afterFunctionTexts2: h }), C = D.targetFunction, R = "rotate" === n ? "rotateZ" : n; e.beforeFunctionTexts = D.beforeFunctionTexts, e.afterFunctionTexts = D.afterFunctionTexts, e.beforeTransform = D.beforeFunctionMatrix, e.beforeTransform2 = D.beforeFunctionMatrix2, e.targetTansform = D.targetFunctionMatrix, e.afterTransform = D.afterFunctionMatrix, e.afterTransform2 = D.afterFunctionMatrix2, e.targetAllTransform = D.allFunctionMatrix, C.functionName === R ? (e.afterFunctionTexts.splice(0, 1), e.isAppendTransform = !1) : (e.isAppendTransform = !0, r.nextTransformAppendedIndexes = xc(xc([], a, !0), [s], !1)) } function $l(t, n, e) { return "".concat(t.beforeFunctionTexts.join(" "), " ").concat(t.isAppendTransform ? e : n, " ").concat(t.afterFunctionTexts.join(" ")) } function Zl(t, n, e) { var r = t.beforeTransform, i = t.afterTransform, o = t.beforeTransform2, a = t.afterTransform2, s = t.targetAllTransform, u = e ? As(s, n, 4) : As(n, s, 4), c = As(zs(e ? o : r, 4), u, 4); return As(c, zs(e ? a : i, 4), 4) } function Kl(t) { var n = t.datas, e = t.distX, r = t.distY, i = n.inverseBeforeMatrix, o = n.is3d, a = n.startDragBeforeDist, s = o ? 4 : 3; return Is(js(i, Fs(n.absoluteOrigin, [e, r]), s), a) } function Jl(t, n) { var e = t.datas, r = t.distX, i = t.distY, o = e.inverseBeforeMatrix, a = e.inverseMatrix, s = e.is3d, u = e.startDragBeforeDist, c = e.startDragDist, l = s ? 4 : 3; return Is(js(n ? o : a, Fs(e.absoluteOrigin, [r, i]), l), n ? u : c) } function Ql(t) { var n = []; return 0 <= t[1] && (0 <= t[0] && n.push(3), t[0] <= 0 && n.push(2)), t[1] <= 0 && (0 <= t[0] && n.push(1), t[0] <= 0 && n.push(0)), n } function tf(n, t) { return Ql(t).map(function (t) { return n[t] }) } function nf(t, n) { var e = tf(t, n); return [Ss(e.map(function (t) { return t[0] })), Ss(e.map(function (t) { return t[1] }))] } function ef(t, n, e, r) { return As(t, gf(n, r, e), r) } function rf(e) { var r = e.originalDatas.beforeRenderable; return { setTransform: function (t, n) { void 0 === n && (n = -1), r.startTransforms = rs(t) ? t : cs(t), af(e, n) }, setTransformIndex: function (t) { af(e, t) } } } function of(t, n) { af(t, vs(t.originalDatas.beforeRenderable.startTransforms, function (t) { return 0 === t.indexOf("".concat(n, "(")) })) } function af(t, n) { var e, r, i = t.originalDatas.beforeRenderable, o = t.datas; -1 === (o.transformIndex = n) || (e = i.startTransforms[n]) && (r = nu([e]), o.startValue = r[0].functionValue) } function sf(t, n) { t.originalDatas.beforeRenderable.nextTransforms = cs(n) } function uf(t) { return t.originalDatas.beforeRenderable.nextTransforms.join(" ") } function cf(t, n, e, r, i) { return sf(i, n), { transform: n, drag: Ll.drag(t, Gc(i, t.state, e, r, !1)) } } function lf(t, n, e, r, i) { var o, a, s, u, c, l, f, p, d, h = t.state, v = h.left, g = h.top, m = t.props.groupable, b = m ? v : 0, x = m ? g : 0, E = Is(r, pf(t, e, (o = t.state, a = i, s = n, u = o.transformOrigin, c = o.offsetMatrix, l = o.is3d, f = a.beforeTransform, p = a.afterTransform, d = l ? 4 : 3, ef(c, Ts(As(As(f, Qs([s]), 4), p, 4), 4, d), u, d)))); return Is(E, [b, x]) } function ff(t) { var n = t.state, e = n.width, r = n.height, i = n.transformOrigin; return [i[0] / (e / 2) - 1, i[1] / (r / 2) - 1] } function pf(t, n, e) { void 0 === e && (e = t.state.allMatrix); var r = t.state, i = r.width, o = r.height, a = r.is3d ? 4 : 3; return Of(e, [i / 2 * (1 + n[0]), o / 2 * (1 + n[1])], a) } function df(t, n, e, r, i, o) { var a, s, u, c, l, f, p, d, h, v = t.props.groupable, g = t.state, m = g.transformOrigin, b = g.targetMatrix, x = g.offsetMatrix, E = g.is3d, y = g.width, S = g.height, M = g.left, w = g.top, D = E ? 4 : 3, C = v ? M : 0, R = v ? w : 0, O = ef(x, b, (s = n, u = e, void 0 === (c = y) && (c = s), void 0 === (l = S) && (l = u), void 0 === (f = m) && (f = [0, 0]), (a = o) ? a.map(function (t, n) { var e = ps(t), r = e.value, i = e.unit, o = n ? l : c, a = n ? u : s; return "%" === t || isNaN(r) ? a * (o ? f[n] / o : 0) : "%" !== i ? r : a * r / 100 }) : f), D); return Is((p = i, d = r, h = nf(Pf(O, n, e, D), d), [p[0] - h[0], p[1] - h[1]]), [C, R]) } function hf(t, n) { return nf(qf(t.state), n) } function vf() { for (var t = [], n = 0; n < arguments.length; n++)t[n] = arguments[n]; return function (n) { for (var t = [], e = 1; e < arguments.length; e++)t[e - 1] = arguments[e]; return t.map(function (t) { return t.split(" ").map(function (t) { return t ? "" + n + t : "" }).join(" ") }).join(" ") }.apply(void 0, xc([Cc], t, !1)) } function gf(t, n, e) { return ks(n, Ks(e, n), t, Ks(e.map(function (t) { return -t }), n)) } function mf(s) { return bf(Zf(s, ":before")).map(function (t, n) { var e, r, i = ps(t), o = i.value, a = i.unit; return o * (e = s, r = 0 === n, "%" !== a ? 1 : Rf(e.ownerSVGElement)[r ? "width" : "height"] / 100) }) } function bf(t) { var n = t.transformOrigin; return n ? n.split(" ") : ["0", "0"] } function xf(t, n) { void 0 === n && (n = Zf(t)); var e = n.transform; if (e && "none" !== e) return n.transform; if ("transform" in t) { var r = t.transform.baseVal; if (!r) return ""; var i = r.length; if (!i) return ""; for (var o = [], a = 0; a < i; ++a)!function () { var n = r[0].matrix; o.push("matrix(".concat(["a", "b", "c", "d", "e", "f"].map(function (t) { return n[t] }).join(", "), ")")) }(); return o.join(" ") } return "" } function Ef(t, n, e) { for (var r = document.body, i = !t || e ? t : t.parentElement, o = t === n || i === n, a = "relative"; i && i !== r;) { n === i && (o = !0); var s = Zf(i), u = i.tagName.toLowerCase(), c = xf(i, s), a = s.position; if ("svg" === u || "static" !== a || c && "none" !== c) break; i = i.parentElement, a = "relative" } return { isStatic: "static" === a, isEnd: o || !i || i === r, offsetParent: i || r } } function yf(t, n) { var e, r, i, o = t.tagName.toLowerCase(), a = t.offsetLeft, s = t.offsetTop, u = ns(a), c = !u; return c || "svg" === o ? i = (r = bf(n).map(function (t) { return parseFloat(t) })).slice() : (i = (r = Dc ? mf(t) : bf(n).map(function (t) { return parseFloat(t) })).slice(), c = !0, a = (e = function (t, n) { if (!t.getBBox || "g" === t.tagName.toLowerCase()) return [0, 0, 0, 0]; var e = t.getBBox(), r = Rf(t.ownerSVGElement), i = e.x - r.x, o = e.y - r.y; return [i, o, n[0] - i, n[1] - o] }(t, r))[0], s = e[1], r[0] = e[2], r[1] = e[3]), { tagName: o, isSVG: u, hasOffset: c, offset: [a || 0, s || 0], origin: r, targetOrigin: i } } function Sf(t, n, e) { void 0 === e && (e = Zf(t)); var r = Zf(document.body), i = r.position; if (!(n || i && "static" !== i)) return [0, 0]; var o = parseInt(r.marginLeft, 10), a = parseInt(r.marginTop, 10); return "absolute" === e.position && ("auto" === e.top && "auto" === e.bottom || (a = 0), "auto" === e.left && "auto" === e.right || (o = 0)), [o, a] } function Mf(t) { t.forEach(function (t) { var n = t.matrix; n && (t.matrix = Ts(n, 3, 4)) }) } function wf(t, n, e) { for (var r, i, o, a, s, u, c = t, l = [], f = !e && t === n || t === document.body, p = f, d = !1, h = 3, v = !1, g = Ef(n, n, !0).offsetParent; c && !p;) { p = f; var m = Zf(c), b = m.position, x = xf(c, m), E = (a = (u = x) && "none" !== u ? es(u) ? u : Qs(u) : [1, 0, 0, 1, 0, 0], (s = void 0) === s && (s = 6 === a.length), s ? [a[0], a[1], 0, a[2], a[3], 0, a[4], a[5], 1] : a), y = "fixed" === b, S = { hasTransform: !1, fixedContainer: null }; y && (v = !0, g = (S = function (t) { for (var n = t.parentElement, e = !1; n;) { var r = Zf(n).transform; if (r && "none" !== r) { e = !0; break } if (n === document.body) break; n = n.parentElement } return { fixedContainer: n || document.body, hasTransform: e } }(c)).fixedContainer); var M = E.length; d || 16 !== M || (d = !0, h = 4, Mf(l), o = o && Ts(o, 3, 4)), d && 9 === M && (E = Ts(E, 3, 4)); var w = yf(c, m), D = w.tagName, C = w.hasOffset, R = w.isSVG, O = w.origin, P = w.targetOrigin, _ = w.offset, B = _[0], z = _[1]; "svg" === D && o ? (l.push({ type: "target", target: c, matrix: function (t, n) { var e = Rf(t), r = e.width, i = e.height, o = e.clientWidth, a = e.clientHeight, s = o / r, u = a / i, c = t.preserveAspectRatio.baseVal, l = c.align, f = c.meetOrSlice, p = [0, 0], d = [s, u], h = [0, 0]; { var v, g, m; 1 !== l && (v = (l - 2) % 3, g = Math.floor((l - 2) / 3), p[0] = r * v / 2, p[1] = i * g / 2, m = 2 === f ? Math.max(u, s) : Math.min(s, u), d[0] = m, d[1] = m, h[0] = (o - r) / 2 * v, h[1] = (a - i) / 2 * g) } var b = Zs(d, n); return b[n * (n - 1)] = h[0], b[n * (n - 1) + 1] = h[1], gf(b, n, p) }(c, h) }), l.push({ type: "offset", target: c, matrix: $s(h) })) : "g" === D && t !== c && (z = B = 0); var G, T = void 0, k = !1, A = !1; y ? (T = S.fixedContainer, k = !0) : (T = (G = Ef(c, n)).offsetParent, k = G.isEnd, A = G.isStatic), wc && C && !R && A && ("relative" === b || "static" === b) && (B -= T.offsetLeft, z -= T.offsetTop, f = f || k); var F, I = 0, N = 0, j = 0, Y = 0; if (y ? C && S.hasTransform && (j = T.clientLeft, Y = T.clientTop) : (C && g !== T && (I = T.clientLeft, N = T.clientTop), C && T === document.body && (B += (F = Sf(c, !1, m))[0], z += F[1])), l.push({ type: "target", target: c, matrix: gf(E, h, O) }), C ? l.push({ type: "offset", target: c, matrix: Ks([B - c.scrollLeft + I - j, z - c.scrollTop + N - Y], h) }) : l.push({ type: "offset", target: c, origin: O }), o = o || E, r = r || O, i = i || P, p || y) break; c = T, f = k, e && c !== document.body || (p = f) } return { offsetContainer: g, matrixes: l, targetMatrix: o = o || $s(h), transformOrigin: r = r || [0, 0], targetOrigin: i = i || [0, 0], is3d: d, hasFixed: v } } function Df(t, n, e, r) { void 0 === e && (e = n); var i, o, a, s, u = 0, c = 0, l = 0, f = {}; t && (u = (i = Ff(t)).offsetWidth, c = i.offsetHeight), t && (a = zf((o = function (t, n, e, r) { var i; void 0 === e && (e = n); var o = wf(t, n), a = o.matrixes, s = o.is3d, u = o.targetMatrix, c = o.transformOrigin, l = o.targetOrigin, f = o.offsetContainer, p = o.hasFixed, d = wf(f, e, !0), h = d.matrixes, v = d.is3d, g = r || v || s, m = g ? 4 : 3, b = "svg" !== t.tagName.toLowerCase() && "ownerSVGElement" in t, x = u, E = $s(m), y = $s(m), S = $s(m), M = $s(m), w = a.length; h.reverse(), a.reverse(), !s && g && (x = Ts(x, 3, 4), Mf(a)); !v && g && Mf(h); h.forEach(function (t) { y = As(y, t.matrix, m) }); var D = e || document.body, C = (null === (i = h[0]) || void 0 === i ? void 0 : i.target) || Ef(D, D, !0).offsetParent, R = h.slice(1).reduce(function (t, n) { return As(t, n.matrix, m) }, $s(m)); a.forEach(function (t, n) { var e; w - 2 === n && (S = E.slice()), w - 1 === n && (M = E.slice()), t.matrix || (e = function (t, n, e, r, i) { var o, a = t.target, s = t.origin, u = n.matrix, c = Ff(a), l = c.offsetWidth, f = c.offsetHeight, p = e.getBoundingClientRect(), d = [0, 0]; e === document.body && (d = Sf(a, !0)); var h = a.getBoundingClientRect(), v = h.left - p.left + e.scrollLeft - (e.clientLeft || 0) + d[0], g = h.top - p.top + e.scrollTop - (e.clientTop || 0) + d[1], m = h.width, b = h.height, x = ks(r, i, u), E = Bf(x, l, f, r), y = E.left, S = E.top, M = E.width, w = E.height, D = Of(x, s, r), C = Is(D, [y, S]), R = [v + C[0] * m / M, g + C[1] * b / w], O = [0, 0], P = 0; for (; ++P < 10;) { var _ = zs(i, r); o = Is(Of(_, R, r), Of(_, D, r)), O[0] = o[0], O[1] = o[1]; var B = Bf(ks(r, i, Ks(O, r), u), l, f, r), z = B.left, G = B.top, T = z - v, k = G - g; if (Math.abs(T) < 2 && Math.abs(k) < 2) break; R[0] -= T, R[1] -= k } return O.map(function (t) { return Math.round(t) }) }(t, a[n + 1], C, m, As(R, E, m)), t.matrix = Ks(e, m)), E = As(E, t.matrix, m) }); var O = !b && s; x = x || $s(O ? 4 : 3); var P = Cf(b && 16 === x.length ? Ts(x, 4, 3) : x, O); return y = Bs(y, m, m), { hasFixed: p, rootMatrix: y, beforeMatrix: S, offsetMatrix: M, allMatrix: E, targetMatrix: x, targetTransform: P, transformOrigin: c, targetOrigin: l, is3d: g } }(t, n, e, r)).allMatrix, o.transformOrigin, u, c), f = bc(bc({}, o), a), l = If([(s = zf(o.allMatrix, [50, 50], 100, 100)).pos1, s.pos2], s.direction)); var p = r ? 4 : 3; return bc({ width: u, height: c, rotation: l, rootMatrix: $s(p), beforeMatrix: $s(p), offsetMatrix: $s(p), allMatrix: $s(p), targetMatrix: $s(p), targetTransform: "", transformOrigin: [0, 0], targetOrigin: [0, 0], is3d: !!r, left: 0, top: 0, right: 0, bottom: 0, origin: [0, 0], pos1: [0, 0], pos2: [0, 0], pos3: [0, 0], pos4: [0, 0], direction: 1, hasFixed: !1 }, f) } function Cf(t, n) { return void 0 === n && (n = 9 < t.length), "".concat(n ? "matrix3d" : "matrix", "(").concat(Ns(t, !n).join(","), ")") } function Rf(t) { var n = t.clientWidth, e = t.clientHeight; if (!t) return { x: 0, y: 0, width: 0, height: 0, clientWidth: n, clientHeight: e }; var r = t.viewBox, i = r && r.baseVal || { x: 0, y: 0, width: 0, height: 0 }; return { x: i.x, y: i.y, width: i.width || n, height: i.height || e, clientWidth: n, clientHeight: e } } function Of(t, n, e) { return js(t, Gs(n, e), e) } function Pf(n, t, e, r) { return [[0, 0], [t, 0], [0, e], [t, e]].map(function (t) { return Of(n, t, r) }) } function _f(t) { var n = t.map(function (t) { return t[0] }), e = t.map(function (t) { return t[1] }), r = Math.min.apply(Math, n), i = Math.min.apply(Math, e), o = Math.max.apply(Math, n), a = Math.max.apply(Math, e); return { left: r, top: i, right: o, bottom: a, width: o - r, height: a - i } } function Bf(t, n, e, r) { return _f(Pf(t, n, e, r)) } function zf(t, n, e, r) { var i = 16 === t.length ? 4 : 3, o = Pf(t, e, r, i), a = o[0], s = a[0], u = a[1], c = o[1], l = c[0], f = c[1], p = o[2], d = p[0], h = p[1], v = o[3], g = v[0], m = v[1], b = Of(t, n, i), x = b[0], E = b[1], y = Math.min(s, l, d, g), S = Math.min(u, f, h, m); return { left: y, top: S, right: Math.max(s, l, d, g), bottom: Math.max(u, f, h, m), origin: [x = x - y || 0, E = E - S || 0], pos1: [s = s - y || 0, u = u - S || 0], pos2: [l = l - y || 0, f = f - S || 0], pos3: [d = d - y || 0, h = h - S || 0], pos4: [g = g - y || 0, m = m - S || 0], direction: ws(o) } } function Gf(t) { return Math.sqrt(t[0] * t[0] + t[1] * t[1]) } function Tf(t, n) { return Gf([n[0] - t[0], n[1] - t[1]]) } function kf(t, n, e, r) { void 0 === e && (e = 1), void 0 === r && (r = Ms(t, n)); var i = Tf(t, n); return { transform: "translateY(-50%) translate(".concat(t[0], "px, ").concat(t[1], "px) rotate(").concat(r, "rad) scaleY(").concat(e, ")"), width: "".concat(i, "px") } } function Af(t, n) { for (var e = [], r = 2; r < arguments.length; r++)e[r - 2] = arguments[r]; var i = e.length, o = e.reduce(function (t, n) { return t + n[0] }, 0) / i, a = e.reduce(function (t, n) { return t + n[1] }, 0) / i; return { transform: "translateZ(0px) translate(".concat(o, "px, ").concat(a, "px) rotate(").concat(t, "rad) scale(").concat(n, ")") } } function Ff(t, n) { if (void 0 === n && (n = Zf(t)), !ns(t.offsetWidth) || "svg" === t.tagName.toLowerCase()) { var e = "border-box" === n.boxSizing, r = parseFloat(n.borderLeftWidth) || 0, i = parseFloat(n.borderRightWidth) || 0, o = parseFloat(n.borderTopWidth) || 0, a = parseFloat(n.borderBottomWidth) || 0, s = parseFloat(n.paddingLeft) || 0, u = parseFloat(n.paddingRight) || 0, c = parseFloat(n.paddingTop) || 0, l = parseFloat(n.paddingBottom) || 0, f = parseFloat(n.width), p = parseFloat(n.height), d = f, h = p, v = s + u, g = c + l, m = v + (r + i), b = g + (o + a); return e ? (f = d - m, p = h - b) : (d = f + m, h = p + b), { svg: !1, offsetWidth: d, offsetHeight: h, clientWidth: f + v, clientHeight: p + g, cssWidth: f, cssHeight: p } } var d, h, x = t.getBBox(); return { svg: !0, offsetWidth: d = x.width, offsetHeight: h = x.height, clientWidth: d, clientHeight: h, cssWidth: d, cssHeight: h } } function If(t, n) { return Ms(0 < n ? t[0] : t[1], 0 < n ? t[1] : t[0]) } function Nf(t, n, e, r, i) { var o, a, s = 1, u = [0, 0], c = jf(), l = jf(), f = jf(), p = Df(n, e, i, !1); return n && (o = p.is3d ? 4 : 3, s = (a = zf(p.offsetMatrix, Fs(p.transformOrigin, function (t, n) { void 0 === n && (n = Math.sqrt(t.length)); for (var e = [], r = t[n * n - 1], i = 0; i < n - 1; ++i)e[i] = t[n * (n - 1) + i] / r; return e[n - 1] = 0, e }(p.targetMatrix, o)), p.width, p.height)).direction, u = Fs(a.origin, [a.left - p.left, a.top - p.top]), c = Yf(n), l = Yf(Ef(r, r, !0).offsetParent || document.body, !0), t && (f = Yf(t))), bc({ targetClientRect: c, containerClientRect: l, moveableClientRect: f, beforeDirection: s, beforeOrigin: u, originalBeforeOrigin: u, target: n }, p) } function jf() { return { left: 0, right: 0, top: 0, bottom: 0, width: 0, height: 0, clientLeft: 0, clientTop: 0, clientWidth: 0, clientHeight: 0, scrollWidth: 0, scrollHeight: 0 } } function Yf(t, n) { var e, r, i, o = 0, a = 0, s = 0, u = 0; t === document.body || t === document.documentElement ? (s = window.innerWidth, u = window.innerHeight, o = (r = [-(e = [document.documentElement.scrollLeft || document.body.scrollLeft, document.documentElement.scrollTop || document.body.scrollTop])[0], -e[1]])[0], a = r[1]) : (o = (i = t.getBoundingClientRect()).left, a = i.top, s = i.width, u = i.height); var c = { left: o, right: o + s, top: a, bottom: a + u, width: s, height: u }; return n && (c.clientLeft = t.clientLeft, c.clientTop = t.clientTop, c.clientWidth = t.clientWidth, c.clientHeight = t.clientHeight, c.scrollWidth = t.scrollWidth, c.scrollHeight = t.scrollHeight, c.overflow = "visible" !== Zf(t).overflow), c } function Xf(t) { if (t) { var n = t.getAttribute("data-direction"); if (n) { var e = [0, 0]; return -1 < n.indexOf("w") && (e[0] = -1), -1 < n.indexOf("e") && (e[0] = 1), -1 < n.indexOf("n") && (e[1] = -1), -1 < n.indexOf("s") && (e[1] = 1), e } } } function Wf(t, n) { return [Fs(n, t[0]), Fs(n, t[1]), Fs(n, t[2]), Fs(n, t[3])] } function qf(t) { var n = t.left, e = t.top; return Wf([t.pos1, t.pos2, t.pos3, t.pos4], [n, e]) } function Lf(t, n) { var e; null !== (e = t[n]) && void 0 !== e && e.unset(), t[n] = null } function Hf(t, n, e, r) { var i = n.datas; i.datas || (i.datas = {}); var o = bc(bc({}, e), { target: t.state.target, clientX: n.clientX, clientY: n.clientY, inputEvent: n.inputEvent, currentTarget: t, moveable: t, datas: i.datas }); return i.isStartEvent ? r || (i.lastEvent = o) : i.isStartEvent = !0, o } function Vf(t, n, e) { var r = n.datas, i = "isDrag" in e ? e.isDrag : n.isDrag; return r.datas || (r.datas = {}), bc(bc({ isDrag: i }, e), { moveable: t, target: t.state.target, clientX: n.clientX, clientY: n.clientY, inputEvent: n.inputEvent, currentTarget: t, lastEvent: r.lastEvent, isDouble: n.isDouble, datas: r.datas }) } function Uf(t, n, e) { t._emitter.on(n, e) } function $f(t, n, e, r) { return t.triggerEvent(n, e, r) } function Zf(t, n) { return window.getComputedStyle(t, n) } function Kf(t, e, r) { var i = {}, o = {}; return t.filter(function (n) { var t = n.name; if (i[t] || !e.some(function (t) { return n[t] })) return !1; if (!r && n.ableGroup) { if (o[n.ableGroup]) return !1; o[n.ableGroup] = !0 } return i[t] = !0 }) } function Jf(t, n) { return t === n || null == t && null == n } function Qf() { for (var t = [], n = 0; n < arguments.length; n++)t[n] = arguments[n]; return t.sort(function (t, n) { return Math.abs(n) - Math.abs(t) }), t[0] } function tp(t, n, e) { return js(zs(t, e), Gs(n, e), e) } function np(t, n) { var e = t.is3d ? 4 : 3, r = tp(t.rootMatrix, [n.distX, n.distY], e); return n.distX = r[0], n.distY = r[1], n } function ep(t, n, e, r, i) { return Is(Of(t, Fs(e, n), i), r) } function rp(t, n, e) { return e ? "".concat(t / n * 100, "%") : "".concat(t, "px") } function ip(t) { return Math.abs(t) <= Pc ? 0 : t } function op(t, n) { return n.isRequest ? ("resizable" === n.requestAble || "scalable" === n.requestAble) && n.parentDirection : Os(n.inputEvent.target, vf("direction")) } function ap(t, n) { return t ? is(t) ? n ? document.querySelector(t) : t : os(t) ? t() : "current" in t ? t.current : t : null } function sp(t, n) { var e, r, i, o = t.rootMatrix, a = t.is3d, s = zs(o, a ? 4 : 3); return a || (s = Ts(s, 3, 4)), s[12] = 0, s[13] = 0, s[14] = 0, r = js(s, [(e = n)[0], e[1] || 0, e[2] || 0, 1], 4), i = r[3] || 1, [r[0] / i, r[1] / i, r[2] / i] } function up(e, t, n, r) { var i, o, a, s, u, c, l, f, p, d = n.ratio, h = n.startOffsetWidth, v = n.startOffsetHeight, g = 0, m = 0, b = r.distX, x = r.distY, E = r.parentDistance, y = r.parentDist, S = r.parentScale, M = r.isPinch, w = n.fixedDirection; return y ? (g = y[0], m = y[1], t && (g ? m = m || g / d : g = m * d)) : S ? (g = (S[0] - 1) * h, m = (S[1] - 1) * v) : M ? E && (m = (g = E) * v / h) : (p = Jl({ datas: n, distX: b, distY: x }), p = [0, 1].map(function (t) { var n = Math.abs(e[t] - w[t]); return 0 !== n && (n = 2 / n), p[t] * n }), t && h && v ? (i = Ms([0, 0], p), o = Ms([0, 0], e), a = Gf(p), s = Math.cos(i - o) * a, e[0] ? m = e[1] ? (u = 2 * e[0] * h, c = 2 * e[1] * v, l = Gf([u + p[0], c + p[1]]) - Gf([u, c]), f = Ms([0, 0], [d, 1]), g = Math.cos(f) * l, Math.sin(f) * l) : (g = s) / d : g = (m = s) * d) : (g = e[0] * p[0], m = e[1] * p[1])), { distWidth: g, distHeight: m } } var cp = Ec("pinchable", { events: { onPinchStart: "pinchStart", onPinch: "pinch", onPinchEnd: "pinchEnd", onPinchGroupStart: "pinchGroupStart", onPinchGroup: "pinchGroup", onPinchGroupEnd: "pinchGroupEnd" }, dragStart: function () { return !0 }, pinchStart: function (e, r) { var t = r.datas, n = r.targets, i = r.angle, o = r.originalDatas, a = e.props, s = a.pinchable, u = a.ables; if (!s) return !1; var c = "onPinch".concat(n ? "Group" : "", "Start"), l = "drag".concat(n ? "Group" : "", "ControlStart"), f = (!0 === s ? e.controlAbles : u.filter(function (t) { return -1 < s.indexOf(t.name) })).filter(function (t) { return t.canPinch && t[l] }), p = Hf(e, r, {}); n && (p.targets = n); var d = $f(e, c, p); t.isPinch = !1 !== d, t.ables = f; var h = t.isPinch; return !!h && (f.forEach(function (t) { var n; o[t.name] = o[t.name] || {}, t[l] && (n = bc(bc({}, r), { datas: o[t.name], parentRotate: i, isPinch: !0 }), t[l](e, n)) }), e.state.snapRenderInfo = { request: r.isRequest, direction: [0, 0] }, h) }, pinch: function (n, e) { var t = e.datas, r = e.scale, i = e.distance, o = e.originalDatas, a = e.inputEvent, s = e.targets, u = e.angle; if (t.isPinch) { var c = i * (1 - 1 / r), l = Hf(n, e, {}); s && (l.targets = s); var f = "onPinch".concat(s ? "Group" : ""); $f(n, f, l); var p = t.ables, d = "drag".concat(s ? "Group" : "", "Control"); return p.forEach(function (t) { t[d] && t[d](n, bc(bc({}, e), { datas: o[t.name], inputEvent: a, parentDistance: c, parentRotate: u, isPinch: !0 })) }), l } }, pinchEnd: function (n, e) { var t = e.datas, r = e.isPinch, i = e.inputEvent, o = e.targets, a = e.originalDatas; if (t.isPinch) { var s = "onPinch".concat(o ? "Group" : "", "End"), u = Vf(n, e, { isDrag: r }); o && (u.targets = o), $f(n, s, u); var c = t.ables, l = "drag".concat(o ? "Group" : "", "ControlEnd"); return c.forEach(function (t) { t[l] && t[l](n, bc(bc({}, e), { isDrag: r, datas: a[t.name], inputEvent: i, isPinch: !0 })) }), r } }, pinchGroupStart: function (t, n) { return this.pinchStart(t, bc(bc({}, n), { targets: t.props.targets })) }, pinchGroup: function (t, n) { return this.pinch(t, bc(bc({}, n), { targets: t.props.targets })) }, pinchGroupEnd: function (t, n) { return this.pinchEnd(t, bc(bc({}, n), { targets: t.props.targets })) } }), lp = { name: "resizable", ableGroup: "size", canPinch: !0, props: { resizable: Boolean, throttleResize: Number, renderDirections: Array, keepRatio: Boolean, resizeFormat: Function }, events: { onResizeStart: "resizeStart", onBeforeResize: "beforeResize", onResize: "resize", onResizeEnd: "resizeEnd", onResizeGroupStart: "resizeGroupStart", onBeforeResizeGroup: "beforeResizeGroup", onResizeGroup: "resizeGroup", onResizeGroupEnd: "resizeGroupEnd" }, render: function (t, n) { var e = t.props, r = e.resizable, i = e.edge; if (r) return (i ? Yc : jc)(t, n) }, dragControlCondition: op, dragControlStart: function (t, n) { var e, r, i = n.inputEvent, o = n.isPinch, a = n.parentDirection, s = n.datas, u = n.parentFlag, c = a || (o ? [0, 0] : Xf(i.target)), l = t.state, f = l.target, p = l.width, d = l.height; if (!c || !f) return !1; o || Vl(t, n), s.datas = {}, s.direction = c, s.startOffsetWidth = p, s.startOffsetHeight = d, s.prevWidth = 0, s.prevHeight = 0, r = Zf(f), e = [parseFloat(r.width), parseFloat(r.height)], s.startWidth = e[0], s.startHeight = e[1]; var h, v, g, m, b, x, E, y, S, M, w, D = [Math.max(0, p - s.startWidth), Math.max(0, d - s.startHeight)]; s.minSize = D, s.maxSize = [1 / 0, 1 / 0], u || (v = (h = Zf(f)).position, g = h.minWidth, m = h.minHeight, b = h.maxWidth, x = h.maxHeight, M = p, w = d, (y = (E = "static" === v || "relative" === v) ? f.parentElement : f.offsetParent) && (M = y.clientWidth, w = y.clientHeight, E && (S = Zf(y), M -= parseFloat(S.paddingLeft) || 0, w -= parseFloat(S.paddingTop) || 0)), s.minSize = Fs([xs(g, M) || 0, xs(m, w) || 0], D), s.maxSize = Fs([xs(b, M) || 1 / 0, xs(x, w) || 1 / 0], D)); var C = t.props.transformOrigin || "% %"; function R(t) { s.ratio = t && isFinite(t) ? t : 0 } function O(t) { s.fixedDirection = t, s.fixedPosition = nf(s.startPositions, t) } s.transformOrigin = C && is(C) ? C.split(" ") : C, s.isWidth = !c[0] && !c[1] || c[0] || !c[1], s.startPositions = qf(t.state), R(p / d), O([-c[0], -c[1]]); var P = Hf(t, n, { direction: c, set: function (t) { var n = t[0], e = t[1]; s.startWidth = n, s.startHeight = e }, setMin: function (t) { s.minSize = t }, setMax: function (t) { s.maxSize = [t[0] || 1 / 0, t[1] || 1 / 0] }, setRatio: R, setFixedDirection: s.setFixedDirection = O, setOrigin: function (t) { s.transformOrigin = t }, dragStart: Ll.dragStart(t, (new Tc).dragStart([0, 0], n)) }); return !1 !== $f(t, "onResizeStart", P) && (s.isResize = !0, t.state.snapRenderInfo = { request: n.isRequest, direction: c }), !!s.isResize && P }, dragControl: function (t, r) { var n, i = r.datas, e = r.parentFlag, o = r.isPinch, a = r.parentKeepRatio, s = r.dragClient, u = r.parentDist, c = r.isRequest, l = i.isResize, f = i.transformOrigin, p = i.startWidth, d = i.startHeight, h = i.prevWidth, v = i.prevHeight, g = i.minSize, m = i.maxSize, b = i.ratio, x = i.isWidth, E = i.startOffsetWidth, y = i.startOffsetHeight; if (l) { var S = t.props, M = S.resizeFormat, w = S.throttleResize, D = void 0 === w ? 1 : w, C = S.parentMoveable, R = S.snapThreshold, O = void 0 === R ? 5 : R, P = i.direction, _ = P, B = 0, z = 0; P[0] || P[1] || (_ = [1, 1]); var G = b && (null != a ? a : S.keepRatio) || !1, T = W(), k = T[0], A = T[1]; i.setFixedDirection(i.fixedDirection), $f(t, "onBeforeResize", Hf(t, r, { setFixedDirection: function (t) { var n; return i.setFixedDirection(t), n = W(), k = n[0], A = n[1], [k, A] }, boundingWidth: k, boundingHeight: A, setSize: function (t) { k = t[0], A = t[1] } }, !0)); var F = s; s || (F = !e && o ? hf(t, [0, 0]) : i.fixedPosition); var I, N = [0, 0]; o || (N = function (t, e, r, n, i, o, a) { if (!Jc(t, "resizable")) return [0, 0]; var s = a.fixedDirection, u = t.state, c = u.allMatrix, l = u.is3d; return jl(t, function (t, n) { return Il(c, e + t, r + n, s, i, l) }, e, r, n, i, o, a) }(t, k, A, P, F, c, i)), u && (u[0] || (N[0] = 0), u[1] || (N[1] = 0)), G ? (_[0] && _[1] && N[0] && N[1] && (Math.abs(N[0]) > Math.abs(N[1]) ? N[1] = 0 : N[0] = 0), (I = !N[0] && !N[1]) && q(), _[0] && !_[1] || N[0] && !N[1] || I && x ? (k += N[0], A = k / b) : (!_[0] && _[1] || !N[0] && N[1] || I && !x) && (A += N[1], k = A * b)) : (E + B < -O && (N[0] = 0), E + z < -O && (N[1] = 0), k += N[0], A += N[1]), n = ys([k, A], g, m, G), k = n[0], A = n[1], q(); var j = [(B = k - E) - h, (z = A - y) - v]; i.prevWidth = B, i.prevHeight = z; var Y = df(t, k, A, i.fixedDirection, F, f); if (C || !j.every(function (t) { return !t }) || !Y.every(function (t) { return !t })) { var X = Hf(t, r, { width: p + B, height: d + z, offsetWidth: Math.round(k), offsetHeight: Math.round(A), boundingWidth: k, boundingHeight: A, direction: P, dist: [B, z], delta: j, isPinch: !!o, drag: Ll.drag(t, Gc(r, t.state, Y, !!o, !1)) }); return $f(t, "onResize", X), X } } function W() { var t = up(_, G, i, r); B = t.distWidth, z = t.distHeight; var n = _[0] || G ? Math.max(E + B, Pc) : E, e = _[1] || G ? Math.max(y + z, Pc) : y; return G && E && y && (x ? e = n / b : n = e * b), [n, e] } function q() { var t; M && (t = M([k, A]), k = t[0], A = t[1]), k = Cs(k, D), A = Cs(A, D) } }, dragControlAfter: function (t, n) { var e = n.datas, r = e.isResize, i = e.startOffsetWidth, o = e.startOffsetHeight, a = e.prevWidth, s = e.prevHeight; if (r) { var u = t.state, c = u.width - (i + a), l = u.height - (o + s), f = 3 < Math.abs(c), p = 3 < Math.abs(l); return f && (e.startWidth += c, e.startOffsetWidth += c, e.prevWidth += c), p && (e.startHeight += l, e.startOffsetHeight += l, e.prevHeight += l), f || p ? this.dragControl(t, n) : void 0 } }, dragControlEnd: function (t, n) { var e = n.datas; if (e.isResize) { e.isResize = !1; var r = Vf(t, n, {}); return $f(t, "onResizeEnd", r), r } }, dragGroupControlCondition: op, dragGroupControlStart: function (u, t) { var c = t.datas, n = this.dragControlStart(u, t); if (!n) return !1; var r = kc(u, "resizable", t); function i(t, n) { var e = c.fixedDirection, r = c.fixedPosition, i = nf(n.datas.startPositions || qf(t.state), e), o = js(Us(-u.rotation / 180 * Math.PI, 3), [i[0] - r[0], i[1] - r[1], 1], 3), a = o[0], s = o[1]; return n.datas.originalX = a, n.datas.originalY = s, n } function e(e) { n.setFixedDirection(e), o.forEach(function (t, n) { t.setFixedDirection(e), i(t.moveable, r[n]) }) } var o = Fc(u, this, "dragControlStart", t, i); c.setFixedDirection = e; var a = bc(bc({}, n), { targets: u.props.targets, events: o, setFixedDirection: e }), s = $f(u, "onResizeGroupStart", a); return c.isResize = !1 !== s, !!c.isResize && n }, dragGroupControl: function (o, n) { var t = n.datas; if (t.isResize) { Uf(o, "onBeforeResize", function (t) { $f(o, "onBeforeResizeGroup", Hf(o, n, bc(bc({}, t), { targets: o.props.targets }), !0)) }); var e = this.dragControl(o, n); if (e) { var r = e.boundingWidth, i = e.boundingHeight, a = e.dist, s = o.props.keepRatio, u = [r / (r - a[0]), i / (i - a[1])], c = t.fixedPosition, l = Fc(o, this, "dragControl", n, function (t, n) { var e = js(Us(o.rotation / 180 * Math.PI, 3), [n.datas.originalX * u[0], n.datas.originalY * u[1], 1], 3), r = e[0], i = e[1]; return bc(bc({}, n), { parentDist: null, parentScale: u, dragClient: Fs(c, [r, i]), parentKeepRatio: s }) }), f = bc({ targets: o.props.targets, events: l }, e); return $f(o, "onResizeGroup", f), f } } }, dragGroupControlEnd: function (t, n) { var e = n.isDrag; if (n.datas.isResize) { this.dragControlEnd(t, n); var r = Fc(t, this, "dragControlEnd", n); return $f(t, "onResizeGroupEnd", Vf(t, n, { targets: t.props.targets, events: r })), e } }, request: function (t) { var n = {}, e = 0, r = 0, i = t.getRect(); return { isControl: !0, requestStart: function (t) { return { datas: n, parentDirection: t.direction || [1, 1] } }, request: function (t) { return "offsetWidth" in t ? e = t.offsetWidth - i.offsetWidth : "deltaWidth" in t && (e += t.deltaWidth), "offsetHeight" in t ? r = t.offsetHeight - i.offsetHeight : "deltaHeight" in t && (r += t.deltaHeight), { datas: n, parentDist: [e, r], parentKeepRatio: t.keepRatio } }, requestEnd: function () { return { datas: n, isDrag: !0 } } } } }, fp = { name: "scalable", ableGroup: "size", canPinch: !0, props: { scalable: Boolean, throttleScale: Number, renderDirections: String, keepRatio: Boolean }, events: { onScaleStart: "scaleStart", onBeforeScale: "beforeScale", onScale: "scale", onScaleEnd: "scaleEnd", onScaleGroupStart: "scaleGroupStart", onBeforeScaleGroup: "beforeScaleGroup", onScaleGroup: "scaleGroup", onScaleGroupEnd: "scaleGroupEnd" }, render: function (t, n) { var e = t.props, r = e.resizable, i = e.scalable, o = e.edge; if (!r && i) return (o ? Yc : jc)(t, n) }, dragControlCondition: op, dragControlStart: function (t, n) { var e = n.datas, r = n.isPinch, i = n.inputEvent, o = n.parentDirection || (r ? [0, 0] : Xf(i.target)), a = t.state, s = a.width, u = a.height, c = a.targetTransform, l = a.target, f = a.pos1, p = a.pos2, d = a.pos4; if (!o || !l) return !1; r || Vl(t, n), e.datas = {}, e.transform = c, e.prevDist = [1, 1], e.direction = o, e.startOffsetWidth = s, e.startOffsetHeight = u, e.startValue = [1, 1]; var h = Ds(f, p), v = Ds(p, d), g = !o[0] && !o[1] || o[0] || !o[1]; function m(t) { e.ratio = t && isFinite(t) ? t : 0 } function b(t) { e.fixedDirection = t, e.fixedPosition = nf(e.startPositions, t) } e.scaleWidth = h, e.scaleHeight = v, e.scaleXRatio = h / s, e.scaleYRatio = v / u, of(n, "scale"), e.isWidth = g, e.startPositions = qf(t.state), e.setFixedDirection = b, m(Ds(f, p) / Ds(p, d)), b([-o[0], -o[1]]); var x = Hf(t, n, bc(bc({ direction: o, set: function (t) { e.startValue = t }, setRatio: m, setFixedDirection: b }, rf(n)), { dragStart: Ll.dragStart(t, (new Tc).dragStart([0, 0], n)) })); return !1 !== $f(t, "onScaleStart", x) && (e.isScale = !0, t.state.snapRenderInfo = { request: n.isRequest, direction: o }), !!e.isScale && x }, dragControl: function (t, o) { Ul(o, "scale"); var a = o.datas, n = o.parentKeepRatio, e = o.parentFlag, r = o.isPinch, i = o.dragClient, s = o.isRequest, u = a.prevDist, c = a.direction, l = a.startOffsetWidth, f = a.startOffsetHeight, p = a.isScale, d = a.startValue, h = a.isWidth, v = a.ratio; if (!p) return !1; var g = t.props, m = g.throttleScale, b = g.parentMoveable, x = c; c[0] || c[1] || (x = [1, 1]); var E = v && (null != n ? n : g.keepRatio) || !1, y = t.state; function S() { var t = up(x, E, a, o), n = t.distWidth, e = t.distHeight, r = (l + n) / l, i = (f + e) / f, r = x[0] || E ? r * d[0] : d[0], i = x[1] || E ? i * d[1] : d[1]; return 0 === r && (r = 1e-9 * (0 < u[0] ? 1 : -1)), 0 === i && (i = 1e-9 * (0 < u[1] ? 1 : -1)), [r, i] } var M, w = S(); r || !t.props.groupable || rs(M = (y.snapRenderInfo || {}).direction) && (M[0] || M[1]) && (y.snapRenderInfo = { direction: c, request: o.isRequest }), $f(t, "onBeforeScale", Hf(t, o, { scale: w, setFixedDirection: function (t) { return a.setFixedDirection(t), w = S() }, setScale: function (t) { w = t } }, !0)); var D, C, R, O = [w[0] / d[0], w[1] / d[1]], P = i, _ = [0, 0]; i || (P = !e && r ? hf(t, [0, 0]) : a.fixedPosition), r || (_ = Yl(t, O, c, s, a)), E ? (x[0] && x[1] && _[0] && _[1] && (Math.abs(_[0] * l) > Math.abs(_[1] * f) ? _[1] = 0 : _[0] = 0), (D = !_[0] && !_[1]) && (h ? O[0] = Cs(O[0] * d[0], m) / d[0] : O[1] = Cs(O[1] * d[1], m) / d[1]), x[0] && !x[1] || _[0] && !_[1] || D && h ? (O[0] += _[0], C = l * O[0] * d[0] / v, O[1] = C / f / d[1]) : (!x[0] && x[1] || !_[0] && _[1] || D && !h) && (O[1] += _[1], R = f * O[1] * d[1] * v, O[0] = R / l / d[0])) : (O[0] += _[0], O[1] += _[1], _[0] || (O[0] = Cs(O[0] * d[0], m) / d[0]), _[1] || (O[1] = Cs(O[1] * d[1], m) / d[1])), 0 === O[0] && (O[0] = 1e-9 * (0 < u[0] ? 1 : -1)), 0 === O[1] && (O[1] = 1e-9 * (0 < u[1] ? 1 : -1)); var B, z, G = [O[0] / u[0], O[1] / u[1]]; z = d, w = [(B = O)[0] * z[0], B[1] * z[1]]; var T, k, A, F, I, N = (T = t, k = O, A = a.fixedDirection, F = P, I = a, lf(T, "scale(".concat(k.join(", "), ")"), A, F, I)), j = Is(N, a.prevInverseDist || [0, 0]); if (a.prevDist = O, a.prevInverseDist = N, w[0] === u[0] && w[1] === u[1] && j.every(function (t) { return !t }) && !b) return !1; var Y = $l(a, "scale(".concat(w.join(", "), ")"), "scale(".concat(O.join(", "), ")")), X = Hf(t, o, bc({ offsetWidth: l, offsetHeight: f, direction: c, scale: w, dist: O, delta: G, isPinch: !!r }, cf(t, Y, j, r, o))); return $f(t, "onScale", X), X }, dragControlEnd: function (t, n) { var e = n.datas, r = n.isDrag; return !!e.isScale && (e.isScale = !1, $f(t, "onScaleEnd", Vf(t, n, {})), r) }, dragGroupControlCondition: op, dragGroupControlStart: function (u, t) { var c = t.datas, n = this.dragControlStart(u, t); if (!n) return !1; var r = kc(u, "resizable", t); function i(t, n) { var e = c.fixedDirection, r = c.fixedPosition, i = nf(n.datas.startPositions || qf(t.state), e), o = js(Us(-u.rotation / 180 * Math.PI, 3), [i[0] - r[0], i[1] - r[1], 1], 3), a = o[0], s = o[1]; return n.datas.originalX = a, n.datas.originalY = s, n } c.moveableScale = u.scale; function e(e) { n.setFixedDirection(e), o.forEach(function (t, n) { t.setFixedDirection(e), i(t.moveable, r[n]) }) } var o = Fc(u, this, "dragControlStart", t, i); c.setFixedDirection = e; var a = bc(bc({}, n), { targets: u.props.targets, events: o, setFixedDirection: e }), s = $f(u, "onScaleGroupStart", a); return c.isScale = !1 !== s, !!c.isScale && a }, dragGroupControl: function (o, n) { var t = n.datas; if (t.isScale) { Uf(o, "onBeforeScale", function (t) { $f(o, "onBeforeScaleGroup", Hf(o, n, bc(bc({}, t), { targets: o.props.targets }), !0)) }); var e = this.dragControl(o, n); if (e) { var r = t.moveableScale; o.scale = [e.scale[0] * r[0], e.scale[1] * r[1]]; var a = o.props.keepRatio, s = e.dist, u = e.scale, c = t.fixedPosition, i = Fc(o, this, "dragControl", n, function (t, n) { var e = js(Us(o.rotation / 180 * Math.PI, 3), [n.datas.originalX * s[0], n.datas.originalY * s[1], 1], 3), r = e[0], i = e[1]; return bc(bc({}, n), { parentDist: null, parentScale: u, parentKeepRatio: a, dragClient: Fs(c, [r, i]) }) }), l = bc({ targets: o.props.targets, events: i }, e); return $f(o, "onScaleGroup", l), l } } }, dragGroupControlEnd: function (t, n) { var e = n.isDrag; if (n.datas.isScale) { this.dragControlEnd(t, n); var r = Fc(t, this, "dragControlEnd", n); return $f(t, "onScaleGroupEnd", Vf(t, n, { targets: t.props.targets, events: r })), e } }, request: function () { var n = {}, e = 0, r = 0; return { isControl: !0, requestStart: function (t) { return { datas: n, parentDirection: t.direction || [1, 1] } }, request: function (t) { return e += t.deltaWidth, r += t.deltaHeight, { datas: n, parentDist: [e, r], parentKeepRatio: t.keepRatio } }, requestEnd: function () { return { datas: n, isDrag: !0 } } } } }; function pp(t, a) { return t.map(function (t, n) { return e = t, r = a[n], (e * (o = 2) + r * (i = 1)) / (i + o); var e, r, i, o }) } function dp(t, n, e) { var r = Ms(t, n), i = Ms(t, e) - r; return 0 <= i ? i : i + 2 * Math.PI } var hp = { name: "warpable", ableGroup: "size", props: { warpable: Boolean, renderDirections: Array }, events: { onWarpStart: "warpStart", onWarp: "warp", onWarpEnd: "warpEnd" }, render: function (t, n) { var e = t.props, r = e.resizable, i = e.scalable, o = e.warpable, a = e.zoom; if (r || i || !o) return []; var s = t.state, u = s.pos1, c = s.pos2, l = s.pos3, f = s.pos4, p = pp(u, c), d = pp(c, u), h = pp(u, l), v = pp(l, u), g = pp(l, f), m = pp(f, l), b = pp(c, f), x = pp(f, c); return xc([n.createElement("div", { className: vf("line"), key: "middeLine1", style: kf(p, g, a) }), n.createElement("div", { className: vf("line"), key: "middeLine2", style: kf(d, m, a) }), n.createElement("div", { className: vf("line"), key: "middeLine3", style: kf(h, b, a) }), n.createElement("div", { className: vf("line"), key: "middeLine4", style: kf(v, x, a) })], jc(t, n), !0) }, dragControlCondition: function (t, n) { return !n.isRequest && Os(n.inputEvent.target, vf("direction")) }, dragControlStart: function (t, n) { var r = n.datas, e = n.inputEvent, i = t.props.target, o = Xf(e.target); if (!o || !i) return !1; var a = t.state, s = a.transformOrigin, u = a.is3d, c = a.targetTransform, l = a.targetMatrix, f = a.width, p = a.height, d = a.left, h = a.top; return r.datas = {}, r.targetTransform = c, r.warpTargetMatrix = u ? l : Ts(l, 3, 4), r.targetInverseMatrix = Bs(zs(r.warpTargetMatrix, 4), 3, 4), r.direction = o, r.left = d, r.top = h, r.poses = [[0, 0], [f, 0], [0, p], [f, p]].map(function (t) { return Is(t, s) }), r.nextPoses = r.poses.map(function (t) { var n = t[0], e = t[1]; return js(r.warpTargetMatrix, [n, e, 0, 1], 4) }), r.startValue = $s(4), r.prevMatrix = $s(4), r.absolutePoses = qf(a), r.posIndexes = Ql(o), Vl(t, n), of(n, "matrix3d"), !(a.snapRenderInfo = { request: n.isRequest, direction: o }) !== $f(t, "onWarpStart", Hf(t, n, bc({ set: function (t) { r.startValue = t } }, rf(n)))) && (r.isWarp = !0), r.isWarp }, dragControl: function (t, n) { var e, r, i, o, a = n.datas, s = n.isRequest, u = n.distX, c = n.distY, l = a.targetInverseMatrix, f = a.prevMatrix, p = a.isWarp, d = a.startValue, h = a.poses, v = a.posIndexes, g = a.absolutePoses; if (!p) return !1; Ul(n, "matrix3d"), Jc(t, "warpable") && (1 < (e = v.map(function (t) { return g[t] })).length && e.push([(e[0][0] + e[1][0]) / 2, (e[0][1] + e[1][1]) / 2]), i = (r = Gl(t, s, { horizontal: e.map(function (t) { return t[1] + c }), vertical: e.map(function (t) { return t[0] + u }) })).horizontal, o = r.vertical, c -= i.offset, u -= o.offset); var m = Jl({ datas: a, distX: u, distY: c }, !0), b = a.nextPoses.slice(); if (v.forEach(function (t) { b[t] = Fs(b[t], m) }), !Rc.every(function (t) { return n = t.map(function (t) { return h[t] }), e = t.map(function (t) { return b[t] }), r = dp(n[0], n[1], n[2]), i = dp(e[0], e[1], e[2]), !((o = Math.PI) <= r && i <= o || r <= o && o <= i); var n, e, r, i, o })) return !1; var x = Js(h[0], h[2], h[1], h[3], b[0], b[2], b[1], b[3]); if (!x.length) return !1; var E = Zl(a, As(l, x, 4), !0), y = As(zs(f, 4), E, 4), S = As(d, a.prevMatrix = E, 4), M = $l(a, "matrix3d(".concat(S.join(", "), ")"), "matrix3d(".concat(E.join(", "), ")")); return sf(n, M), $f(t, "onWarp", Hf(t, n, { delta: y, matrix: S, dist: E, multiply: As, transform: M })), !0 }, dragControlEnd: function (t, n) { var e = n.datas, r = n.isDrag; return !!e.isWarp && (e.isWarp = !1, $f(t, "onWarpEnd", Vf(t, n, {})), r) } }, vp = vf("area-pieces"), gp = vf("area-piece"), mp = vf("avoid"); function bp(t) { var n, e, r, i, o, a, s = t.areaElement; s && (e = (n = t.state).width, r = n.height, o = mp, (i = s).classList ? i.classList.remove(o) : (a = new RegExp("(\\s|^)" + o + "(\\s|$)"), i.className = i.className.replace(a, " ")), s.style.cssText += "left: 0px; top: 0px; width: ".concat(e, "px; height: ").concat(r, "px")) } function xp(t) { return t.createElement("div", { key: "area_pieces", className: vp }, t.createElement("div", { className: gp }), t.createElement("div", { className: gp }), t.createElement("div", { className: gp }), t.createElement("div", { className: gp })) } var Ep = { name: "dragArea", props: { dragArea: Boolean, passDragArea: Boolean }, events: { onClick: "click", onClickGroup: "clickGroup" }, render: function (t, n) { var e = t.props, r = e.target, i = e.dragArea, o = e.groupable, a = e.passDragArea, s = t.state, u = s.width, c = s.height, l = s.renderPoses, f = a ? vf("area", "pass") : vf("area"); if (o) return [n.createElement("div", { key: "area", ref: La(t, "areaElement"), className: f }), xp(n)]; if (!r || !i) return []; var p = Js([0, 0], [u, 0], [0, c], [u, c], l[0], l[1], l[2], l[3]), d = p.length ? Cf(p, !0) : "none"; return [n.createElement("div", { key: "area", ref: La(t, "areaElement"), className: f, style: { top: "0px", left: "0px", width: "".concat(u, "px"), height: "".concat(c, "px"), transformOrigin: "0 0", transform: d } }), xp(n)] }, dragStart: function (t, n) { var e = n.datas, r = n.clientX, i = n.clientY; if (!n.inputEvent) return !1; e.isDragArea = !1; var o, a, s = t.areaElement, u = t.state, c = u.moveableClientRect, l = u.renderPoses, f = u.rootMatrix, p = u.is3d, d = c.left, h = c.top, v = _f(l), g = v.left, m = v.top, b = v.width, x = v.height, E = tp(f, [r - d, i - h], p ? 4 : 3), y = E[0], S = E[1], M = [{ left: g, top: m, width: b, height: (S -= m) - 10 }, { left: g, top: m, width: (y -= g) - 10, height: x }, { left: g, top: m + S + 10, width: b, height: x - S - 10 }, { left: g + y + 10, top: m, width: b - y - 10, height: x }], w = [].slice.call(s.nextElementSibling.children); M.forEach(function (t, n) { w[n].style.cssText = "left: ".concat(t.left, "px;top: ").concat(t.top, "px; width: ").concat(t.width, "px; height: ").concat(t.height, "px;") }), a = mp, (o = s).classList ? o.classList.add(a) : o.className += " " + a, u.disableNativeEvent = !0 }, drag: function (t, n) { var e = n.datas, r = n.inputEvent; if (this.enableNativeEvent(t), !r) return !1; e.isDragArea || (e.isDragArea = !0, bp(t)) }, dragEnd: function (t, n) { this.enableNativeEvent(t); var e = n.inputEvent, r = n.datas; if (!e) return !1; r.isDragArea || bp(t) }, dragGroupStart: function (t, n) { return this.dragStart(t, n) }, dragGroup: function (t, n) { return this.drag(t, n) }, dragGroupEnd: function (t, n) { return this.dragEnd(t, n) }, unset: function (t) { bp(t), t.state.disableNativeEvent = !1 }, enableNativeEvent: function (t) { var n = t.state; n.disableNativeEvent && ms(function () { n.disableNativeEvent = !1 }) } }, yp = Ec("origin", { render: function (t, n) { var e = t.props.zoom, r = t.state, i = r.beforeOrigin, o = r.rotation; return [n.createElement("div", { className: vf("control", "origin"), style: Af(o, e, i), key: "beforeOrigin" })] } }); function Sp(t) { var n = t.scrollContainer; return [n.scrollLeft, n.scrollTop] } var Mp = { name: "scrollable", canPinch: !0, props: { scrollable: Boolean, scrollContainer: Object, scrollThreshold: Number, getScrollPosition: Function }, events: { onScroll: "scroll", onScrollGroup: "scrollGroup" }, dragRelation: "strong", dragStart: function (o, a) { var t = o.props.scrollContainer, n = void 0 === t ? o.getContainer() : t, e = new wu, r = ap(n, !0); a.datas.dragScroll = e; var i = a.isControl ? "controlGesto" : "targetGesto", s = a.targets; e.on("scroll", function (t) { var n = t.container, e = t.direction, r = Hf(o, a, { scrollContainer: n, direction: e }), i = s ? "onScrollGroup" : "onScroll"; s && (r.targets = s), $f(o, i, r) }).on("move", function (t) { var n = t.offsetX, e = t.offsetY; o[i].scrollBy(n, e, a.inputEvent, !1) }), e.dragStart(a, { container: r }) }, checkScroll: function (t, n) { var e = n.datas.dragScroll; if (e) { var r = t.props, i = r.scrollContainer, o = void 0 === i ? t.getContainer() : i, a = r.scrollThreshold, s = void 0 === a ? 0 : a, u = r.getScrollPosition, c = void 0 === u ? Sp : u; return e.drag(n, { container: o, threshold: s, getScrollPosition: function (t) { return c({ scrollContainer: t.container, direction: t.direction }) } }), !0 } }, drag: function (t, n) { return this.checkScroll(t, n) }, dragEnd: function (t, n) { n.datas.dragScroll.dragEnd(), n.datas.dragScroll = null }, dragControlStart: function (t, n) { return this.dragStart(t, bc(bc({}, n), { isControl: !0 })) }, dragControl: function (t, n) { return this.drag(t, n) }, dragControlEnd: function (t, n) { return this.dragEnd(t, n) }, dragGroupStart: function (t, n) { return this.dragStart(t, bc(bc({}, n), { targets: t.props.targets })) }, dragGroup: function (t, n) { return this.drag(t, bc(bc({}, n), { targets: t.props.targets })) }, dragGroupEnd: function (t, n) { return this.dragEnd(t, bc(bc({}, n), { targets: t.props.targets })) }, dragGroupControlStart: function (t, n) { return this.dragStart(t, bc(bc({}, n), { targets: t.props.targets, isControl: !0 })) }, dragGroupContro: function (t, n) { return this.drag(t, bc(bc({}, n), { targets: t.props.targets })) }, dragGroupControEnd: function (t, n) { return this.dragEnd(t, bc(bc({}, n), { targets: t.props.targets })) } }, wp = { name: "", props: { target: Object, dragTarget: Object, container: Object, portalContainer: Object, rootContainer: Object, useResizeObserver: Boolean, zoom: Number, transformOrigin: Array, edge: Boolean, ables: Array, className: String, pinchThreshold: Number, pinchOutside: Boolean, triggerAblesSimultaneously: Boolean, checkInput: Boolean, cspNonce: String, translateZ: Number, hideDefaultLines: Boolean, props: Object }, events: {} }, Dp = Ec("padding", { render: function (t, o) { var n = t.props; if (n.dragArea) return []; var e = n.padding || {}, r = e.left, i = void 0 === r ? 0 : r, a = e.top, s = void 0 === a ? 0 : a, u = e.right, c = void 0 === u ? 0 : u, l = e.bottom, f = void 0 === l ? 0 : l, p = t.state, d = p.renderPoses, h = [p.pos1, p.pos2, p.pos3, p.pos4], v = []; return 0 < i && v.push([0, 2]), 0 < s && v.push([0, 1]), 0 < c && v.push([1, 3]), 0 < f && v.push([2, 3]), v.map(function (t, n) { var e = t[0], r = t[1], i = Js([0, 0], [100, 0], [0, 100], [100, 100], h[e], h[r], d[e], d[r]); if (i.length) return o.createElement("div", { key: "padding".concat(n), className: vf("padding"), style: { transform: Cf(i, !0) } }) }) } }), Cp = ["nw", "ne", "se", "sw"]; function Rp(t, n) { var e = t[0] + t[1], r = n < e ? n / e : 1; return t[0] *= r, t[1] = n - t[1] * r, t } var Op = [1, 2, 5, 6], Pp = [0, 3, 4, 7], _p = [1, -1, -1, 1], Bp = [1, 1, -1, -1]; function zp(t, a, s, u, c, l, f, p, d) { void 0 === l && (l = 0), void 0 === f && (f = 0), void 0 === p && (p = u), void 0 === d && (d = c); var h = [], v = !1, n = t.map(function (t, n) { var e = a[n], r = e.horizontal, i = e.vertical; if (i && !v && (v = !0, h.push("/")), v) { var o = Math.max(0, 1 === i ? t[1] - f : d - t[1]); return h.push(rp(o, c, s)), o } o = Math.max(0, 1 === r ? t[0] - l : p - t[0]); return h.push(rp(o, u, s)), o }); return { styles: h, raws: n } } function Gp(t) { for (var n = [0, 0], e = [0, 0], r = t.length, i = 0; i < r; ++i) { var o = t[i]; o.sub && (o.horizontal && (0 === n[1] && (n[0] = i), n[1] = i - n[0] + 1, e[0] = i + 1), o.vertical && (0 === e[1] && (e[0] = i), e[1] = i - e[0] + 1)) } return { horizontalRange: n, verticalRange: e } } function Tp(t, r, i, o, a, n) { var e, s, u; void 0 === n && (n = [0, 0]); var c = t.indexOf("/"), l = (-1 < c ? t.slice(0, c) : t).length, f = t.slice(0, l), p = t.slice(l + 1), d = f[0], h = void 0 === d ? "0px" : d, v = f[1], g = void 0 === v ? h : v, m = f[2], b = void 0 === m ? h : m, x = f[3], E = void 0 === x ? g : x, y = p[0], S = void 0 === y ? h : y, M = p[1], w = void 0 === M ? S : M, D = p[2], C = void 0 === D ? S : D, R = p[3], O = void 0 === R ? w : R, P = [h, g, b, E].map(function (t) { return xs(t, r) }), _ = [S, w, C, O].map(function (t) { return xs(t, i) }), B = P.slice(), z = _.slice(), G = Rp([B[0], B[1]], r); B[0] = G[0], B[1] = G[1], e = Rp([B[3], B[2]], r), B[3] = e[0], B[2] = e[1], s = Rp([z[0], z[3]], i), z[0] = s[0], z[3] = s[1], u = Rp([z[1], z[2]], i), z[1] = u[0], z[2] = u[1]; var T = B.slice(0, Math.max(n[0], f.length)), k = z.slice(0, Math.max(n[1], p.length)); return xc(xc([], T.map(function (t, n) { var e = Cp[n]; return { horizontal: _p[n], vertical: 0, pos: [o + t, a + (-1 === Bp[n] ? i : 0)], sub: !0, raw: P[n], direction: e } }), !0), k.map(function (t, n) { var e = Cp[n]; return { horizontal: 0, vertical: Bp[n], pos: [o + (-1 === _p[n] ? r : 0), a + t], sub: !0, raw: _[n], direction: e } }), !0) } function kp(t, n, e, r, i) { void 0 === i && (i = n.length); var o = Gp(t.slice(r)), a = o.horizontalRange, s = o.verticalRange, u = e - r, c = 0; if (0 == u) c = i; else if (0 < u && u < a[1]) c = a[1] - u; else { if (!(u >= s[0])) return; c = s[0] + s[1] - u } t.splice(e, c), n.splice(e, c) } function Ap(t, n, e, r, i, o, a, s, u, c, l) { void 0 === c && (c = 0), void 0 === l && (l = 0); var f = Gp(t.slice(e)), p = f.horizontalRange, d = f.verticalRange; if (-1 < r) for (var h = 1 === _p[r] ? o - c : s - o, v = p[1]; v <= r; ++v) { var g = 1 === Bp[v] ? l : u, m = 0; if (r === v ? m = o : 0 === v ? m = c + h : -1 === _p[v] && (m = s - (n[e][0] - c)), t.splice(e + v, 0, { horizontal: _p[v], vertical: 0, pos: [m, g] }), n.splice(e + v, 0, [m, g]), 0 === v) break } else if (-1 < i) { var b, x = 1 === Bp[i] ? a - l : u - a; 0 === p[1] && 0 === d[1] && (b = [c + x, l], t.push({ horizontal: _p[0], vertical: 0, pos: b }), n.push(b)); for (var E = d[0], v = d[1]; v <= i; ++v) { m = 1 === _p[v] ? c : s, g = 0; if (i === v ? g = a : 0 === v ? g = l + x : 1 === Bp[v] ? g = n[e + E][1] : -1 === Bp[v] && (g = u - (n[e + E][1] - l)), t.push({ horizontal: 0, vertical: Bp[v], pos: [m, g] }), n.push([m, g]), 0 === v) break } } } function Fp(t, e) { return void 0 === e && (e = t.map(function (t) { return t.raw })), { horizontals: t.map(function (t, n) { return t.horizontal ? e[n] : null }).filter(function (t) { return null != t }), verticals: t.map(function (t, n) { return t.vertical ? e[n] : null }).filter(function (t) { return null != t }) } } var Ip = [[0, -1, "n"], [1, 0, "e"]], Np = [[-1, -1, "nw"], [0, -1, "n"], [1, -1, "ne"], [1, 0, "e"], [1, 1, "se"], [0, 1, "s"], [-1, 1, "sw"], [-1, 0, "w"]]; function jp(t, n, e) { var r = t.props.clipRelative, i = t.state, o = i.width, a = i.height, s = n.type, u = n.poses, c = "rect" === s, l = "circle" === s; if ("polygon" === s) return e.map(function (t) { return "".concat(rp(t[0], o, r), " ").concat(rp(t[1], a, r)) }); if (c || "inset" === s) { var f = e[1][1], p = e[3][0], d = e[7][0], h = e[5][1]; if (c) return [f, p, h, d].map(function (t) { return "".concat(t, "px") }); var v, g, m, b = [f, o - p, a - h, d].map(function (t, n) { return rp(t, n % 2 ? o : a, r) }); return 8 < e.length && (g = (v = Is(e[4], e[0]))[0], m = v[1], b.push.apply(b, xc(["round"], zp(e.slice(8), u.slice(8), r, g, m, d, f, p, h).styles, !1))), b } if (l || "ellipse" === s) { var x = e[0], E = rp(Math.abs(e[1][1] - x[1]), l ? Math.sqrt((o * o + a * a) / 2) : a, r); return (b = l ? [E] : [rp(Math.abs(e[2][0] - x[0]), o, r), E]).push("at", rp(x[0], o, r), rp(x[1], a, r)), b } } function Yp(t, n, e, r) { var a = [r, (r + n) / 2, n], s = [t, (t + e) / 2, e]; return Np.map(function (t) { var n = t[0], e = t[1], r = t[2], i = a[n + 1], o = s[e + 1]; return { vertical: Math.abs(e), horizontal: Math.abs(n), direction: r, pos: [i, o] } }) } function Xp(t, i, o, n, e) { var r, a, s, u = e; if (u || (u = "none" !== (s = (a = Zf(t)).clipPath) ? s : a.clip), u && "none" !== u && "auto" !== u || (u = n)) { var c = fs(u), l = c.prefix, f = void 0 === l ? u : l, p = c.value, d = void 0 === p ? "" : p, h = "circle" === f, v = " "; if ("polygon" === f) { v = ","; return { type: f, clipText: u, poses: B = (P = ls(d || "0% 0%, 100% 0%, 100% 100%, 0% 100%")).map(function (t) { var n = t.split(" "), e = n[0], r = n[1]; return { vertical: 1, horizontal: 1, pos: [xs(e, i), xs(r, o)] } }), splitter: v } } if (h || "ellipse" === f) { var g, m, b, x, E, y, S, M, w, D = "", C = "", R = 0, O = 0, P = cs(d); O = h ? (m = "", m = void 0 === (g = P[0]) ? "50%" : g, D = void 0 === (b = P[2]) ? "50%" : b, C = void 0 === (x = P[3]) ? "50%" : x, R = xs(m, Math.sqrt((i * i + o * o) / 2))) : (M = y = "", y = void 0 === (E = P[0]) ? "50%" : E, M = void 0 === (S = P[1]) ? "50%" : S, D = void 0 === (w = P[3]) ? "50%" : w, C = void 0 === (r = P[4]) ? "50%" : r, R = xs(y, i), xs(M, o)); var _ = [xs(D, i), xs(C, o)], B = xc([{ vertical: 1, horizontal: 1, pos: _, direction: "nesw" }], Ip.slice(0, h ? 1 : 2).map(function (t) { return { vertical: Math.abs(t[1]), horizontal: t[0], direction: t[2], sub: !0, pos: [_[0] + t[0] * R, _[1] + t[1] * O] } }), !0); return { type: f, clipText: u, radiusX: R, radiusY: O, left: _[0] - R, top: _[1] - O, poses: B, splitter: v } } if ("inset" === f) { var z = (P = cs(d || "0 0 0 0")).indexOf("round"), G = (-1 < z ? P.slice(0, z) : P).length, T = P.slice(G + 1), k = P.slice(0, G), A = k[0], F = k[1], I = void 0 === F ? A : F, N = k[2], j = void 0 === N ? A : N, Y = k[3], X = void 0 === Y ? I : Y, W = [A, j].map(function (t) { return xs(t, o) }), q = W[0], L = W[1], H = [X, I].map(function (t) { return xs(t, i) }), V = H[0], U = H[1], $ = i - U, Z = o - L, K = Tp(T, $ - V, Z - q, V, q); return { type: "inset", clipText: u, poses: B = xc(xc([], Yp(q, $, Z, V), !0), K, !0), top: q, left: V, right: $, bottom: Z, radius: T, splitter: v } } if ("rect" === f) { v = ","; var J = (P = ls(d || "0px, ".concat(i, "px, ").concat(o, "px, 0px"))).map(function (t) { return ps(t).value }); return { type: "rect", clipText: u, poses: B = Yp(q = J[0], U = J[1], L = J[2], V = J[3]), top: q, right: U, bottom: L, left: V, values: P, splitter: v } } } } var Wp = { name: "clippable", props: { clippable: Boolean, defaultClipPath: String, customClipPath: String, clipRelative: Boolean, clipArea: Boolean, dragWithClip: Boolean, clipTargetBounds: Boolean, clipVerticalGuidelines: Array, clipHorizontalGuidelines: Array, clipSnapThreshold: Boolean }, events: { onClipStart: "clipStart", onClip: "clip", onClipEnd: "clipEnd" }, css: [".control.clip-control {\n    background: #6d6;\n    cursor: pointer;\n}\n.control.clip-control.clip-radius {\n    background: #d66;\n}\n.line.clip-line {\n    background: #6e6;\n    cursor: move;\n    z-index: 1;\n}\n.clip-area {\n    position: absolute;\n    top: 0;\n    left: 0;\n}\n.clip-ellipse {\n    position: absolute;\n    cursor: move;\n    border: 1px solid #6d6;\n    border: var(--zoompx) solid #6d6;\n    border-radius: 50%;\n    transform-origin: 0px 0px;\n}", ":host {\n    --bounds-color: #d66;\n}", ".guideline {\n    pointer-events: none;\n    z-index: 2;\n}", ".line.guideline.bounds {\n    background: #d66;\n    background: var(--bounds-color);\n}"], render: function (t, s) { var n = t.props, e = n.customClipPath, r = n.defaultClipPath, i = n.clipArea, u = n.zoom, o = t.state, a = o.target, c = o.width, l = o.height, f = o.allMatrix, p = o.is3d, d = o.left, h = o.top, v = o.pos1, g = o.pos2, m = o.pos3, b = o.pos4, x = o.clipPathState, E = o.snapBoundInfos, y = o.rotation; if (!a) return []; var S = Xp(a, c, l, r || "inset", x || e); if (!S) return []; var M, w, D, C, R, O, P = p ? 4 : 3, _ = S.type, B = S.poses.map(function (t) { var n = Of(f, t.pos, P); return [n[0] - d, n[1] - h] }), z = [], G = [], T = "rect" === _, k = "inset" === _, A = "polygon" === _; if ((T || k || A) && (M = k ? B.slice(0, 8) : B, G = M.map(function (t, n) { var e = 0 === n ? M[M.length - 1] : M[n - 1], r = Ms(e, t), i = Tf(e, t); return s.createElement("div", { key: "clipLine".concat(n), className: vf("line", "clip-line", "snap-control"), "data-clip-index": n, style: { width: "".concat(i, "px"), transform: "translate(".concat(e[0], "px, ").concat(e[1], "px) rotate(").concat(r, "rad) scaleY(").concat(u, ")") } }) })), z = B.map(function (t, n) { return s.createElement("div", { key: "clipControl".concat(n), className: vf("control", "clip-control", "snap-control"), "data-clip-index": n, style: { transform: "translate(".concat(t[0], "px, ").concat(t[1], "px) rotate(").concat(y, "rad) scale(").concat(u, ")") } }) }), k && z.push.apply(z, B.slice(8).map(function (t, n) { return s.createElement("div", { key: "clipRadiusControl".concat(n), className: vf("control", "clip-control", "clip-radius", "snap-control"), "data-clip-index": 8 + n, style: { transform: "translate(".concat(t[0], "px, ").concat(t[1], "px) rotate(").concat(y, "rad) scale(").concat(u, ")") } }) })), "circle" === _ || "ellipse" === _) { var F = S.left, I = S.top, N = S.radiusX, j = S.radiusY, Y = Is(Of(f, [F, I], P), Of(f, [0, 0], P)), X = Y[0], W = Y[1], q = "none"; if (!i) { for (var L = Math.max(10, N / 5, j / 5), H = [], V = 0; V <= L; ++V) { var U = 2 * Math.PI / L * V; H.push([N + (N - u) * Math.cos(U), j + (j - u) * Math.sin(U)]) } H.push([N, -2]), H.push([-2, -2]), H.push([-2, 2 * j + 2]), H.push([2 * N + 2, 2 * j + 2]), H.push([2 * N + 2, -2]), H.push([N, -2]), q = "polygon(".concat(H.map(function (t) { return "".concat(t[0], "px ").concat(t[1], "px") }).join(", "), ")") } z.push(s.createElement("div", { key: "clipEllipse", className: vf("clip-ellipse", "snap-control"), style: { width: "".concat(2 * N, "px"), height: "".concat(2 * j, "px"), clipPath: q, transform: "translate(".concat(-d + X, "px, ").concat(-h + W, "px) ").concat(Cf(f)) } })) } return i && (D = (w = _f(xc([v, g, m, b], B, !0))).width, C = w.height, R = w.left, O = w.top, (A || T || k) && (H = k ? B.slice(0, 8) : B, z.push(s.createElement("div", { key: "clipArea", className: vf("clip-area", "snap-control"), style: { width: "".concat(D, "px"), height: "".concat(C, "px"), transform: "translate(".concat(R, "px, ").concat(O, "px)"), clipPath: "polygon(".concat(H.map(function (t) { return "".concat(t[0] - R, "px ").concat(t[1] - O, "px") }).join(", "), ")") } })))), E && ["vertical", "horizontal"].forEach(function (o) { var t = E[o], a = "horizontal" === o; t.isSnap && G.push.apply(G, t.snap.posInfos.map(function (t, n) { var e = t.pos, r = Is(Of(f, a ? [0, e] : [e, 0], P), [d, h]), i = Is(Of(f, a ? [c, e] : [e, l], P), [d, h]); return Nc(s, "", r, i, u, "clip".concat(o, "snap").concat(n), "guideline") })), t.isBound && G.push.apply(G, t.bounds.map(function (t, n) { var e = t.pos, r = Is(Of(f, a ? [0, e] : [e, 0], P), [d, h]), i = Is(Of(f, a ? [c, e] : [e, l], P), [d, h]); return Nc(s, "", r, i, u, "clip".concat(o, "bounds").concat(n), "guideline", "bounds", "bold") })) }), xc(xc([], z, !0), G, !0) }, dragControlCondition: function (t, n) { return n.inputEvent && -1 < (n.inputEvent.target.getAttribute("class") || "").indexOf("clip") }, dragStart: function (t, n) { var e = t.props.dragWithClip; return void 0 !== e && !e && this.dragControlStart(t, n) }, drag: function (t, n) { return this.dragControl(t, bc(bc({}, n), { isDragTarget: !0 })) }, dragEnd: function (t, n) { return this.dragControlEnd(t, n) }, dragControlStart: function (t, n) { var e = t.state, r = t.props, i = r.defaultClipPath, o = r.customClipPath, a = e.target, s = e.width, u = e.height, c = n.inputEvent ? n.inputEvent.target : null, l = c && c.getAttribute("class") || "", f = n.datas, p = Xp(a, s, u, i || "inset", o); if (!p) return !1; var d = p.clipText; return !1 === $f(t, "onClipStart", Hf(t, n, { clipType: p.type, clipStyle: d, poses: p.poses.map(function (t) { return t.pos }) })) ? f.isClipStart = !1 : (f.isControl = l && -1 < l.indexOf("clip-control"), f.isLine = -1 < l.indexOf("clip-line"), f.isArea = -1 < l.indexOf("clip-area") || -1 < l.indexOf("clip-ellipse"), f.index = c ? parseInt(c.getAttribute("data-clip-index"), 10) : -1, f.clipPath = p, f.isClipStart = !0, e.clipPathState = d, Vl(t, n), !0) }, dragControl: function (t, n) { var e, r = n.datas, i = n.originalDatas, o = n.isDragTarget; if (!r.isClipStart) return !1; var a = r.isControl, s = r.isLine, u = r.isArea, c = r.index, l = r.clipPath; if (!l) return !1; var f = 0, p = 0, d = i.draggable, h = Jl(n), p = o && d ? (e = d.prevBeforeDist, f = e[0], e[1]) : (f = h[0], h[1]), v = [f, p], g = t.props, m = t.state, b = m.width, x = m.height, E = !u && !a && !s, y = l.type, S = l.poses, M = l.splitter, w = S.map(function (t) { return t.pos }); E && (f = -f, p = -p); var D, C, R, O, P, _, B, z, G, T, k, A, F, I, N, j = !a || "nesw" === S[c].direction, Y = "inset" === y || "rect" === y, X = S.map(function () { return [0, 0] }); a && !j ? (C = (D = S[c]).horizontal, R = D.vertical, O = [f * Math.abs(C), p * Math.abs(R)], B = O, z = Y, k = (P = S)[_ = c], A = k.direction, F = k.sub, I = P.map(function () { return [0, 0] }), N = A ? A.split("") : [], z && _ < 8 ? (G = N.filter(function (t) { return "w" === t || "e" === t })[0], T = N.filter(function (t) { return "n" === t || "s" === t })[0], I[_] = B, P.forEach(function (t, n) { var e = t.direction; e && (-1 < e.indexOf(G) && (I[n][0] = B[0]), -1 < e.indexOf(T) && (I[n][1] = B[1])) }), G && (I[1][0] = B[0] / 2, I[5][0] = B[0] / 2), T && (I[3][1] = B[1] / 2, I[7][1] = B[1] / 2)) : A && !F ? N.forEach(function (o) { var a = "n" === o || "s" === o; P.forEach(function (t, n) { var e = t.direction, r = t.horizontal, i = t.vertical; e && -1 !== e.indexOf(o) && (I[n] = [a || !r ? 0 : B[0], a && i ? B[1] : 0]) }) }) : I[_] = B, X = I) : j && (X = w.map(function () { return [f, p] })); var W = w.map(function (t, n) { return Fs(t, X[n]) }), q = xc([], W, !0); m.snapBoundInfos = null; var L, H, V, U, $, Z, K = "circle" === l.type, J = "ellipse" === l.type; (K || J) && (L = _f(W), H = Math.abs(L.bottom - L.top), V = Math.abs(J ? L.right - L.left : H), U = W[0][1] + H, $ = W[0][0] - V, Z = W[0][0] + V, K && (q.push([Z, L.bottom]), X.push([1, 0])), q.push([L.left, U]), X.push([0, 1]), q.push([$, L.bottom]), X.push([1, 0])); var Q, tt = nl((g.clipHorizontalGuidelines || []).map(function (t) { return xs("".concat(t), x) }), (g.clipVerticalGuidelines || []).map(function (t) { return xs("".concat(t), b) }), b, x), nt = [], et = []; et = K || J ? (nt = [q[4][0], q[2][0]], [q[1][1], q[3][1]]) : Y ? (ot = [q[0], q[2], q[4], q[6]], Q = [X[0], X[2], X[4], X[6]], nt = ot.filter(function (t, n) { return Q[n][0] }).map(function (t) { return t[0] }), ot.filter(function (t, n) { return Q[n][1] }).map(function (t) { return t[1] })) : (nt = q.filter(function (t, n) { return X[n][0] }).map(function (t) { return t[0] }), q.filter(function (t, n) { return X[n][1] }).map(function (t) { return t[1] })); for (var rt = [0, 0], it = 0; it < 2; ++it) { if ("break" === function () { var t = Tl(tt, g.clipTargetBounds && { left: 0, top: 0, right: b, bottom: x }, nt, et, 5), n = t.horizontal, e = t.vertical, r = n.offset, i = e.offset; if (n.isBound && (rt[1] += r), e.isBound && (rt[0] += i), !J && !K || 0 !== X[0][0] || 0 !== X[0][1]) return q.forEach(function (t, n) { var e = X[n]; e[0] && (t[0] -= i), e[1] && (t[1] -= r) }), "break"; var o = _f(W), a = o.bottom - o.top, s = J ? o.right - o.left : a; s -= e.isBound ? Math.abs(i) : 0 === e.snapIndex ? -i : i, a -= n.isBound ? Math.abs(r) : 0 === n.snapIndex ? -r : r, K && (s = a = 0 < ll(e, n) ? a : s); var u = q[0]; q[1][1] = u[1] - a, q[2][0] = u[0] + s, q[3][1] = u[1] + a, q[4][0] = u[0] - s }()) break } var ot, at, st, ut, ct, lt = jp(t, l, W), ft = "".concat(y, "(").concat(lt.join(M), ")"); return m.clipPathState = ft, et = K || J ? (nt = [q[4][0], q[2][0]], [q[1][1], q[3][1]]) : Y ? (ot = [q[0], q[2], q[4], q[6]], nt = ot.map(function (t) { return t[0] }), ot.map(function (t) { return t[1] })) : (nt = q.map(function (t) { return t[0] }), q.map(function (t) { return t[1] })), m.snapBoundInfos = Tl(tt, g.clipTargetBounds && { left: 0, top: 0, right: b, bottom: x }, nt, et, 1), d && (at = m.is3d, st = m.allMatrix, ut = at ? 4 : 3, ct = rt, o && (ct = [v[0] + rt[0] - h[0], v[1] + rt[1] - h[1]]), d.deltaOffset = As(st, [ct[0], ct[1], 0, 0], ut)), $f(t, "onClip", Hf(t, n, { clipEventType: "changed", clipType: y, poses: W, clipStyle: ft, clipStyles: lt, distX: f, distY: p })), !0 }, dragControlEnd: function (t, n) { this.unset(t); var e = n.isDrag, r = n.datas, i = n.isDouble, o = r.isLine, a = r.isClipStart, s = r.isControl; return !!a && ($f(t, "onClipEnd", Vf(t, n, {})), i && (s ? function (t, n) { var e = n.datas, r = e.clipPath, i = e.index, o = r.type, a = r.poses, s = r.splitter, u = a.map(function (t) { return t.pos }), c = u.length; if ("polygon" === o) a.splice(i, 1), u.splice(i, 1); else { if ("inset" !== o) return; if (i < 8) return; if (kp(a, u, i, 8, c), c === a.length) return } var l = jp(t, r, u); $f(t, "onClip", Hf(t, n, { clipEventType: "removed", clipType: o, poses: u, clipStyles: l, clipStyle: "".concat(o, "(").concat(l.join(s), ")"), distX: 0, distY: 0 })) }(t, n) : o && function (t, n) { var e = Hl(t, n), r = e[0], i = e[1], o = n.datas, a = o.clipPath, s = o.index, u = a.type, c = a.poses, l = a.splitter, f = c.map(function (t) { return t.pos }); if ("polygon" === u) f.splice(s, 0, [r, i]); else { if ("inset" !== u) return; var p = Op.indexOf(s), d = Pp.indexOf(s), h = c.length; if (Ap(c, f, 8, p, d, r, i, f[4][0], f[4][1], f[0][0], f[0][1]), h === c.length) return } var v = jp(t, a, f); $f(t, "onClip", Hf(t, n, { clipEventType: "added", clipType: u, poses: f, clipStyles: v, clipStyle: "".concat(u, "(").concat(v.join(l), ")"), distX: 0, distY: 0 })) }(t, n)), i || e) }, unset: function (t) { t.state.clipPathState = "", t.state.snapBoundInfos = null } }, qp = { name: "originDraggable", props: { originDraggable: Boolean, originRelative: Boolean }, events: { onDragOriginStart: "dragOriginStart", onDragOrigin: "dragOrigin", onDragOriginEnd: "dragOriginEnd" }, css: [":host[data-able-origindraggable] .control.origin {\n    pointer-events: auto;\n}"], dragControlCondition: function (t, n) { return n.isRequest ? "originDraggable" === n.requestAble : Os(n.inputEvent.target, vf("origin")) }, dragControlStart: function (t, n) { var e = n.datas; Vl(t, n); var r = Hf(t, n, { dragStart: Ll.dragStart(t, (new Tc).dragStart([0, 0], n)) }), i = $f(t, "onDragOriginStart", r); return e.startOrigin = t.state.transformOrigin, e.startTargetOrigin = t.state.targetOrigin, e.prevOrigin = [0, 0], !(e.isDragOrigin = !0) === i ? e.isDragOrigin = !1 : r }, dragControl: function (t, n) { var e = n.datas, r = n.isPinch, i = n.isRequest; if (!e.isDragOrigin) return !1; var o, a = Jl(n), s = a[0], u = a[1], c = t.state, l = c.width, f = c.height, p = c.offsetMatrix, d = c.targetMatrix, h = c.is3d, v = t.props.originRelative, g = void 0 === v || v, m = h ? 4 : 3, b = [s, u]; !i || ((o = n.distOrigin)[0] || o[1]) && (b = o); var x = Fs(e.startOrigin, b), E = Fs(e.startTargetOrigin, b), y = Is(b, e.prevOrigin), S = ef(p, d, x, m), M = t.getRect(), w = _f(Pf(S, l, f, m)), D = [M.left - w.left, M.top - w.top], C = Hf(t, n, { width: l, height: f, origin: x, dist: e.prevOrigin = b, delta: y, transformOrigin: [rp(E[0], l, g), rp(E[1], f, g)].join(" "), drag: Ll.drag(t, Gc(n, t.state, D, !!r, !1)) }); return $f(t, "onDragOrigin", C), C }, dragControlEnd: function (t, n) { return !!n.datas.isDragOrigin && ($f(t, "onDragOriginEnd", Vf(t, n, {})), !0) }, dragGroupControlCondition: function (t, n) { return this.dragControlCondition(t, n) }, dragGroupControlStart: function (t, n) { return !!this.dragControlStart(t, n) }, dragGroupControl: function (t, n) { var e = this.dragControl(t, n); return !!e && (t.transformOrigin = e.transformOrigin, !0) }, request: function (t) { var n = {}, e = t.getRect(), r = 0, i = 0, o = e.transformOrigin, a = [0, 0]; return { isControl: !0, requestStart: function () { return { datas: n } }, request: function (t) { return "deltaOrigin" in t ? (a[0] += t.deltaOrigin[0], a[1] += t.deltaOrigin[1]) : "origin" in t ? (a[0] = t.origin[0] - o[0], a[1] = t.origin[1] - o[1]) : ("x" in t ? r = t.x - e.left : "deltaX" in t && (r += t.deltaX), "y" in t ? i = t.y - e.top : "deltaY" in t && (i += t.deltaY)), { datas: n, distX: r, distY: i, distOrigin: a } }, requestEnd: function () { return { datas: n, isDrag: !0 } } } } }; function Lp(t, n, e, r, i) { void 0 === r && (r = [0, 0]); var o, a; return Tp(!(a = i || ((o = Zf(t)) && o.borderRadius || "")) || !i && "0px" === a ? [] : cs(a), n, e, 0, 0, r) } function Hp(t, n, e, r, i, o) { var a = t.state, s = a.width, u = a.height, c = zp(o, i, t.props.roundRelative, s, u), l = c.raws, f = c.styles, p = Fp(i, l), d = p.horizontals, h = p.verticals, v = f.join(" "); $f(t, "onRound", Hf(t, n, { horizontals: d, verticals: h, borderRadius: a.borderRadiusState = v, width: s, height: u, delta: r, dist: e })) } var Vp = { name: "roundable", props: { roundable: Boolean, roundRelative: Boolean, minRoundControls: Array, maxRoundControls: Array, roundClickable: Boolean }, events: { onRoundStart: "roundStart", onRound: "round", onRoundEnd: "roundEnd" }, css: [".control.border-radius {\n    background: #d66;\n    cursor: pointer;\n}", ":host[data-able-roundable] .line.direction {\n    cursor: pointer;\n}"], render: function (t, i) { var n = t.state, e = n.target, r = n.width, o = n.height, a = n.allMatrix, s = n.is3d, u = n.left, c = n.top, l = n.borderRadiusState, f = t.props, p = f.minRoundControls, d = void 0 === p ? [0, 0] : p, h = f.maxRoundControls, v = void 0 === h ? [4, 4] : h, g = f.zoom; if (!e) return null; var m = s ? 4 : 3, b = Lp(e, r, o, d, l); if (!b) return null; var x = 0, E = 0; return b.map(function (t, n) { E += Math.abs(t.horizontal), x += Math.abs(t.vertical); var e = Is(Of(a, t.pos, m), [u, c]), r = t.vertical ? x <= v[1] : E <= v[0]; return i.createElement("div", { key: "borderRadiusControl".concat(n), className: vf("control", "border-radius"), "data-radius-index": n, style: { display: r ? "block" : "none", transform: "translate(".concat(e[0], "px, ").concat(e[1], "px) scale(").concat(g, ")") } }) }) }, dragControlCondition: function (t, n) { if (!n.inputEvent || n.isRequest) return !1; var e = n.inputEvent.target.getAttribute("class") || ""; return -1 < e.indexOf("border-radius") || -1 < e.indexOf("moveable-line") && -1 < e.indexOf("moveable-direction") }, dragControlStart: function (t, n) { var e = n.inputEvent, r = n.datas, i = e.target, o = i.getAttribute("class") || "", a = -1 < o.indexOf("border-radius"), s = -1 < o.indexOf("moveable-line") && -1 < o.indexOf("moveable-direction"), u = a ? parseInt(i.getAttribute("data-radius-index"), 10) : -1, c = s ? parseInt(i.getAttribute("data-line-index"), 10) : -1; if (!a && !s) return !1; if (!1 === $f(t, "onRoundStart", Hf(t, n, {}))) return !1; r.lineIndex = c, r.controlIndex = u, r.isControl = a, r.isLine = s, Vl(t, n); var l = t.props, f = l.roundRelative, p = l.minRoundControls, d = void 0 === p ? [0, 0] : p, h = t.state, v = h.target, g = h.width, m = h.height; r.isRound = !0, r.prevDist = [0, 0]; var b = Lp(v, g, m, d) || []; return r.controlPoses = b, h.borderRadiusState = zp(b.map(function (t) { return t.pos }), b, f, g, m).styles.join(" "), !0 }, dragControl: function (t, n) { var e = n.datas; if (!e.isRound || !e.isControl || !e.controlPoses.length) return !1; var r = e.controlIndex, i = e.controlPoses, o = Jl(n), a = o[0], s = o[1], u = [a, s], c = Is(u, e.prevDist), l = t.props.maxRoundControls, f = void 0 === l ? [4, 4] : l, p = t.state, d = p.width, h = p.height, v = i[r], g = v.vertical, m = v.horizontal, b = i.map(function (t) { var n = t.horizontal, e = t.vertical, r = [n * m * u[0], e * g * u[1]]; if (n) { if (1 === f[0]) return r; if (f[0] < 4 && n !== m) return r } else { if (0 === f[1]) return r[1] = e * m * u[0] / d * h, r; if (g) { if (1 === f[1]) return r; if (f[1] < 4 && e !== g) return r } } return [0, 0] }); b[r] = u; var x = i.map(function (t, n) { return Fs(t.pos, b[n]) }); return e.prevDist = [a, s], Hp(t, n, u, c, i, x), !0 }, dragControlEnd: function (t, n) { var e = t.state; e.borderRadiusState = ""; var r = n.datas, i = n.isDouble; if (!r.isRound) return !1; var o, a, s, u, c, l, f, p, d, h, v, g, m, b, x, E, y, S = e.width, M = e.height, w = r.isControl, D = r.controlIndex, C = r.isLine, R = r.lineIndex, O = r.controlPoses, P = O.map(function (t) { return t.pos }), _ = P.length, B = t.props.roundClickable; return i && (void 0 === B || B) && (w ? kp(O, P, D, 0) : C && (a = (o = Hl(t, n))[0], s = o[1], c = P, l = R, f = a, p = s, d = S, h = M, v = Fp(u = O), g = v.horizontals, m = v.verticals, b = g.length, x = m.length, y = E = -1, 0 === l ? 0 === b ? E = 0 : 1 === b && (E = 1) : 3 === l && (b <= 2 ? E = 2 : b <= 3 && (E = 3)), 2 === l ? 0 === x ? y = 0 : x < 4 && (y = 3) : 1 === l && (x <= 1 ? y = 1 : x <= 2 && (y = 2)), Ap(u, c, 0, E, y, f, p, d, h)), _ !== O.length && Hp(t, n, [0, 0], [0, 0], O, P)), $f(t, "onRoundEnd", Vf(t, n, {})), !(e.borderRadiusState = "") }, unset: function (t) { t.state.borderRadiusState = "" } }; var Up = { isPinch: !0, name: "beforeRenderable", props: {}, events: { onBeforeRenderStart: "beforeRenderStart", onBeforeRender: "beforeRender", onBeforeRenderEnd: "beforeRenderEnd", onBeforeRenderGroupStart: "beforeRenderGroupStart", onBeforeRenderGroup: "beforeRenderGroup", onBeforeRenderGroupEnd: "beforeRenderGroupEnd" }, dragRelation: "weak", setTransform: function (t, n) { var e, r = t.state, i = r.is3d, o = r.target, a = r.targetMatrix, s = null == o ? void 0 : o.style.transform, u = i ? "matrix3d(".concat(a.join(","), ")") : "matrix(".concat(Ns(a, !0), ")"), c = s && "none" !== s ? s : u; n.datas.startTransforms = (e = c) === (i ? "matrix3d(".concat($s(4)) : "matrix(".concat($s(3), ")")) || "matrix(1,0,0,1,0,0)" === e ? [] : cs(c) }, resetTransform: function (t) { t.datas.nextTransforms = t.datas.startTransforms, t.datas.nextTransformAppendedIndexes = [] }, fillDragStartParams: function (t, n) { return Hf(t, n, { setTransform: function (t) { n.datas.startTransforms = rs(t) ? t : cs(t) }, isPinch: !!n.isPinch }) }, fillDragParams: function (t, n) { return Hf(t, n, { isPinch: !!n.isPinch }) }, dragStart: function (t, n) { this.setTransform(t, n), $f(t, "onBeforeRenderStart", this.fillDragStartParams(t, n)) }, drag: function (t, n) { this.resetTransform(n), $f(t, "onBeforeRender", Hf(t, n, { isPinch: !!n.isPinch })) }, dragEnd: function (t, n) { $f(t, "onBeforeRenderEnd", Hf(t, n, { isPinch: !!n.isPinch, isDrag: n.isDrag })) }, dragGroupStart: function (t, n) { var r = this; this.dragStart(t, n); var e = kc(t, "beforeRenderable", n), i = t.moveables, o = e.map(function (t, n) { var e = i[n]; return r.setTransform(e, t), r.fillDragStartParams(e, t) }); $f(t, "onBeforeRenderGroupStart", Hf(t, n, { isPinch: !!n.isPinch, targets: t.props.targets, setTransform: function () { }, events: o })) }, dragGroup: function (t, n) { var r = this; this.drag(t, n); var e = kc(t, "beforeRenderable", n), i = t.moveables, o = e.map(function (t, n) { var e = i[n]; return r.resetTransform(t), r.fillDragParams(e, t) }); $f(t, "onBeforeRenderGroup", Hf(t, n, { isPinch: !!n.isPinch, targets: t.props.targets, events: o })) }, dragGroupEnd: function (t, n) { this.dragEnd(t, n), $f(t, "onBeforeRenderGroupEnd", Hf(t, n, { isPinch: !!n.isPinch, isDrag: n.isDrag, targets: t.props.targets })) }, dragControlStart: function (t, n) { return this.dragStart(t, n) }, dragControl: function (t, n) { return this.drag(t, n) }, dragControlEnd: function (t, n) { return this.dragEnd(t, n) }, dragGroupControlStart: function (t, n) { return this.dragGroupStart(t, n) }, dragGroupControl: function (t, n) { return this.dragGroup(t, n) }, dragGroupControlEnd: function (t, n) { return this.dragGroupEnd(t, n) } }, $p = { name: "renderable", props: {}, events: { onRenderStart: "renderStart", onRender: "render", onRenderEnd: "renderEnd", onRenderGroupStart: "renderGroupStart", onRenderGroup: "renderGroup", onRenderGroupEnd: "renderGroupEnd" }, dragRelation: "weak", dragStart: function (t, n) { $f(t, "onRenderStart", Hf(t, n, { isPinch: !!n.isPinch })) }, drag: function (t, n) { $f(t, "onRender", this.fillDragParams(t, n)) }, dragAfter: function (t, n) { if (n.resultCount) return this.drag(t, n) }, dragEnd: function (t, n) { $f(t, "onRenderEnd", this.fillDragEndParams(t, n)) }, dragGroupStart: function (t, n) { $f(t, "onRenderGroupStart", Hf(t, n, { isPinch: !!n.isPinch, targets: t.props.targets })) }, dragGroup: function (t, n) { var r = this, e = kc(t, "beforeRenderable", n), i = t.moveables, o = e.map(function (t, n) { var e = i[n]; return r.fillDragParams(e, t) }); $f(t, "onRenderGroup", Hf(t, n, { isPinch: !!n.isPinch, targets: t.props.targets, transform: uf(n), events: o })) }, dragGroupEnd: function (t, n) { var r = this, e = kc(t, "beforeRenderable", n), i = t.moveables, o = e.map(function (t, n) { var e = i[n]; return r.fillDragEndParams(e, t) }); $f(t, "onRenderGroupEnd", Hf(t, n, { isPinch: !!n.isPinch, isDrag: n.isDrag, targets: t.props.targets, events: o })) }, dragControlStart: function (t, n) { return this.dragStart(t, n) }, dragControl: function (t, n) { return this.drag(t, n) }, dragControlAfter: function (t, n) { return this.dragAfter(t, n) }, dragControlEnd: function (t, n) { return this.dragEnd(t, n) }, dragGroupControlStart: function (t, n) { return this.dragGroupStart(t, n) }, dragGroupControl: function (t, n) { return this.dragGroup(t, n) }, dragGroupControlEnd: function (t, n) { return this.dragGroupEnd(t, n) }, fillDragParams: function (t, n) { return Hf(t, n, { isPinch: !!n.isPinch, transform: uf(n) }) }, fillDragEndParams: function (t, n) { return Hf(t, n, { isPinch: !!n.isPinch, isDrag: n.isDrag }) } }; function Zp(i, t, n, e, r, o, a) { var s = "Start" === r, u = i.state.target, c = o.isRequest; if (!u || s && -1 < e.indexOf("Control") && !c && i.areaElement === o.inputEvent.target) return !1; var l = "".concat(n).concat(e).concat(r), f = "".concat(n).concat(e, "Condition"), p = "End" === r, d = "After" === r, h = !(!s || i.targetGesto && i.controlGesto && i.targetGesto.isFlag() && i.controlGesto.isFlag()); h && i.updateRect(r, !0, !1), "" !== r || c || np(i.state, o); var v, g = xc([], i[t], !0); if (c && (v = o.requestAble, g.some(function (t) { return t.name === v }) || g.push.apply(g, i.props.ables.filter(function (t) { return t.name === v }))), !g.length) return !1; var m = xc(xc([Up], g, !0), [$p], !1).filter(function (t) { return t[l] }), b = o.datas; h && m.forEach(function (t) { t.unset && t.unset(i) }); var x, E = o.inputEvent; p && E && (x = document.elementFromPoint(o.clientX, o.clientY) || E.target); var y = 0, S = m.filter(function (t) { var n = t.name, e = b[n] || (b[n] = {}); if (s && (e.isEventStart = !t[f] || t[f](i, o)), e.isEventStart) { var r = t[l](i, bc(bc({}, o), { resultCount: y, datas: e, originalDatas: b, inputTarget: x })); return i._emitter.off(), s && !1 === r && (e.isEventStart = !1), y += r ? 1 : 0, r } return !1 }).length, M = !1; return s && m.length && !S && (M = 0 === m.filter(function (t) { var n = t.name, e = b[n]; return !!e.isEventStart && ("strong" !== t.dragRelation || (e.isEventStart = !1)) }).length), (p || M) && (i.state.gesto = null, i.moveables && i.moveables.forEach(function (t) { t.state.gesto = null })), h && M && m.forEach(function (t) { t.unset && t.unset(i) }), s && !c && S && null != o && o.preventDefault(), !i.isUnmounted && !M && ((!s && S && !a || p) && (i.updateRect(p ? r : "", !0, !1), i.forceUpdate()), s || p || d || !S || a || Zp(i, t, n, e, r + "After", o), !0) } function Kp(e, t, n) { var r = e.controlBox.getElement(), i = []; i.push(r), e.props.dragArea && !e.props.dragTarget || i.push(t); function o(t) { var n = t.inputEvent.target; return n === e.areaElement || !e.isMoveableElement(n) && !e.controlBox.getElement().contains(n) || Os(n, "moveable-area") || Os(n, "moveable-padding") } return Jp(e, i, "targetAbles", n, { dragStart: o, pinchStart: o }) } function Jp(i, t, o, a, s) { void 0 === s && (s = {}); var n = i.props, e = n.pinchOutside, r = n.pinchThreshold, u = { preventDefault: !1, container: window, pinchThreshold: r, pinchOutside: e }, c = new ic(t, u); return ["drag", "pinch"].forEach(function (r) { ["Start", "", "End"].forEach(function (e) { c.on("".concat(r).concat(e), function (t) { var n = t.eventType; (!s[n] || s[n](t)) && Zp(i, o, r, a, e, t) || t.stop() }) }) }), c } var Qp = function () { function t(t, n, e) { var i = this; this.target = t, this.moveable = n, this.eventName = e, this.ables = [], this._onEvent = function (n) { var e = i.eventName, r = i.moveable; r.state.disableNativeEvent || i.ables.forEach(function (t) { t[e](r, { inputEvent: n }) }) }, t.addEventListener(e.toLowerCase(), this._onEvent) } var n = t.prototype; return n.setAbles = function (t) { this.ables = t }, n.destroy = function () { this.target.removeEventListener(this.eventName.toLowerCase(), this._onEvent), this.target = null, this.moveable = null }, t }(), td = function (t) { function n() { var n = null !== t && t.apply(this, arguments) || this; return n.state = bc({ container: null, gesto: null, renderPoses: [[0, 0], [0, 0], [0, 0], [0, 0]], disableNativeEvent: !1 }, Nf(null)), n.enabledAbles = [], n.targetAbles = [], n.controlAbles = [], n.rotation = 0, n.scale = [1, 1], n.isUnmounted = !1, n.events = { mouseEnter: null, mouseLeave: null }, n._emitter = new gc, n._prevTarget = null, n._prevDragArea = !1, n._observer = null, n._observerId = 0, n.onPreventClick = function (t) { t.stopPropagation(), _s(window, "click", n.onPreventClick, !0) }, n.checkUpdateRect = function () { var t; n.isDragging() || ((t = n.props.parentMoveable) ? t.checkUpdateRect() : (bs(n._observerId), n._observerId = ms(function () { n.isDragging() || n.updateRect() }))) }, n } !function (t, n) { if ("function" != typeof n && null !== n) throw new TypeError("Class extends value " + String(n) + " is not a constructor or null"); function e() { this.constructor = t } mc(t, n), t.prototype = null === n ? Object.create(n) : (e.prototype = n.prototype, new e) }(n, t); var e = n.prototype; return e.render = function () { var t = this.props, n = this.state, e = t.parentPosition, r = t.className, i = t.target, o = t.zoom, a = t.cspNonce, s = t.translateZ, u = t.cssStyled, c = t.portalContainer; this.checkUpdate(), this.updateRenderPoses(); var l = e || { left: 0, top: 0 }, f = l.left, p = l.top, d = n.left, h = n.top, v = n.target, g = n.direction, m = n.hasFixed, b = t.targets, x = (b && b.length || i) && v, E = this.isDragging(), y = {}; return this.getEnabledAbles().forEach(function (t) { y["data-able-".concat(t.name.toLowerCase())] = !0 }), ku(u, bc({ cspNonce: a, ref: La(this, "controlBox"), className: "".concat(vf("control-box", -1 === g ? "reverse" : "", E ? "dragging" : ""), " ").concat(r) }, y, { onClick: this.onPreventClick, portalContainer: c, style: { position: m ? "fixed" : "absolute", display: x ? "block" : "none", transform: "translate3d(".concat(d - f, "px, ").concat(h - p, "px, ").concat(s, ")"), "--zoom": o, "--zoompx": "".concat(o, "px") } }), this.renderAbles(), this._renderLines()) }, e.componentDidMount = function () { this.isUnmounted = !1, this.controlBox.getElement(); var t = this.props, n = t.parentMoveable, e = t.container, r = t.wrapperMoveable; this._updateTargets(), this._updateNativeEvents(), this._updateEvents(), e || n || r || this.updateRect("", !1, !0), this.updateCheckInput(), this._updateObserver(this.props) }, e.componentDidUpdate = function (t) { this._updateNativeEvents(), this._updateEvents(), this._updateTargets(), this.updateCheckInput(), this._updateObserver(t) }, e.componentWillUnmount = function () { this.isUnmounted = !0, this._emitter.off(), Lf(this, "targetGesto"), Lf(this, "controlGesto"); var t = this.events; for (var n in t) { var e = t[n]; e && e.destroy() } }, e.getContainer = function () { var t = this.props, n = t.parentMoveable, e = t.wrapperMoveable; return t.container || e && e.getContainer() || n && n.getContainer() || this.controlBox.getElement().parentElement }, e.isMoveableElement = function (t) { return t && -1 < (t.getAttribute("class") || "").indexOf(Cc) }, e.dragStart = function (t) { var n = this.targetGesto; return n && !n.isFlag() && n.triggerDragStart(t), this }, e.hitTest = function (t) { var n, e, r = this.state, i = r.target, o = r.pos1, a = r.pos2, s = r.pos3, u = r.pos4, c = r.targetClientRect; if (!i) return 0; var l = (e = t instanceof Element ? { left: (n = t.getBoundingClientRect()).left, top: n.top, width: n.width, height: n.height } : bc({ width: 0, height: 0 }, t)).left, f = e.top, p = e.width, d = e.height, h = fu([o, a, u, s], c), v = bu(h, [[l, f], [l + p, f], [l + p, f + d], [l, f + d]]), g = lu(h); return v && g ? Math.min(100, v / g * 100) : 0 }, e.isInside = function (t, n) { var e = this.state, r = e.target, i = e.pos1, o = e.pos2, a = e.pos3, s = e.pos4, u = e.targetClientRect; return !!r && du([t, n], fu([i, o, s, a], u)) }, e.updateRect = function (t, n, e) { void 0 === e && (e = !0); var r = this.props, i = r.parentMoveable, o = this.state.target || this.props.target, a = this.getContainer(), s = i ? i.props.rootContainer : r.rootContainer; this.updateState(Nf(this.controlBox && this.controlBox.getElement(), o, a, a, s || a), !i && e) }, e.isDragging = function () { return !!this.targetGesto && this.targetGesto.isFlag() || !!this.controlGesto && this.controlGesto.isFlag() }, e.updateTarget = function (t) { this.updateRect(t, !0) }, e.getRect = function () { var t = this.state, n = qf(this.state), e = n[0], r = n[1], i = n[2], o = n[3], a = _f(n), s = t.width, u = t.height, c = a.width, l = a.height, f = a.left, p = a.top, d = [t.left, t.top], h = Fs(d, t.origin); return { width: c, height: l, left: f, top: p, pos1: e, pos2: r, pos3: i, pos4: o, offsetWidth: s, offsetHeight: u, beforeOrigin: Fs(d, t.beforeOrigin), origin: h, transformOrigin: t.transformOrigin, rotation: this.getRotation() } }, e.getManager = function () { return this }, e.getRotation = function () { var t, n, e = this.state, r = e.pos1, i = e.pos2, o = e.direction; return t = o, n = Ms(r, i) / Math.PI * 180, n = 0 <= (n = 0 <= t ? n : 180 - n) ? n : 360 + n }, e.request = function (n, t, e) { void 0 === t && (t = {}); var r = this.props, i = r.ables, o = r.groupable, a = i.filter(function (t) { return t.name === n })[0]; if (this.isDragging() || !a || !a.request) return { request: function () { return this }, requestEnd: function () { return this } }; var s = this, u = a.request(this), c = e || t.isInstant, l = u.isControl ? "controlAbles" : "targetAbles", f = "".concat(o ? "Group" : "").concat(u.isControl ? "Control" : ""), p = { request: function (t) { return Zp(s, l, "drag", f, "", bc(bc({}, u.request(t)), { requestAble: n, isRequest: !0 }), c), this }, requestEnd: function () { return Zp(s, l, "drag", f, "End", bc(bc({}, u.requestEnd()), { requestAble: n, isRequest: !0 }), c), this } }; return Zp(s, l, "drag", f, "Start", bc(bc({}, u.requestStart(t)), { requestAble: n, isRequest: !0 }), c), c ? p.request(t).requestEnd() : p }, e.destroy = function () { this.componentWillUnmount() }, e.updateRenderPoses = function () { var t = this.state, n = this.props, e = t.originalBeforeOrigin, r = t.transformOrigin, i = t.allMatrix, o = t.is3d, a = t.pos1, s = t.pos2, u = t.pos3, c = t.pos4, l = t.left, f = t.top, p = n.padding || {}, d = p.left, h = void 0 === d ? 0 : d, v = p.top, g = void 0 === v ? 0 : v, m = p.bottom, b = void 0 === m ? 0 : m, x = p.right, E = void 0 === x ? 0 : x, y = o ? 4 : 3, S = n.groupable ? e : Fs(e, [l, f]); t.renderPoses = [Fs(a, ep(i, [-h, -g], r, S, y)), Fs(s, ep(i, [E, -g], r, S, y)), Fs(u, ep(i, [-h, b], r, S, y)), Fs(c, ep(i, [E, b], r, S, y))] }, e.checkUpdate = function () { var t, n = this.props, e = n.target, r = n.container, i = n.parentMoveable, o = this.state, a = o.target, s = o.container; (a || e) && (this.updateAbles(), Jf(a, e) && Jf(s, r) || ((t = r || this.controlBox) && this.unsetAbles(), this.updateState({ target: e, container: r }), !i && t && this.updateRect("End", !1, !1))) }, e.triggerEvent = function (t, n) { this._emitter.trigger(t, n); var e = this.props[t]; return e && e(n) }, e.useCSS = function (t, n) { var e, r, i = this.props.customStyledMap, o = t + n; return i[o] || (i[o] = (e = t, r = lc(n), function (n) { function t() { var t = null !== n && n.apply(this, arguments) || this; return t.injector = r, t.tag = e, t } return pc(t, n), t }(hc))), i[o] }, e.unsetAbles = function () { var n = this; this.targetAbles.forEach(function (t) { t.unset && t.unset(n) }) }, e.updateAbles = function (t, n) { void 0 === t && (t = this.props.ables), void 0 === n && (n = ""); var e = this.props, r = e.triggerAblesSimultaneously, i = t.filter(function (t) { return t && (t.always && !1 !== e[t.name] || e[t.name]) }), o = "drag".concat(n, "Start"), a = "pinch".concat(n, "Start"), s = "drag".concat(n, "ControlStart"), u = Kf(i, [o, a], r), c = Kf(i, [s], r); this.enabledAbles = i, this.targetAbles = u, this.controlAbles = c }, e.updateState = function (t, n) { if (n) { if (this.isUnmounted) return; this.setState(t) } else { var e = this.state; for (var r in t) e[r] = t[r] } }, e.getEnabledAbles = function () { var n = this.props; return n.ables.filter(function (t) { return t && n[t.name] }) }, e.renderAbles = function () { var i, o, a, s, t, n = this, e = this.props.triggerAblesSimultaneously, r = { createElement: ku }; return t = Kf(this.getEnabledAbles(), ["render"], e).map(function (t) { return (0, t.render)(n, r) || [] }), i = t.reduce(function (t, n) { return t.concat(n) }, []).filter(function (t) { return t }), o = function (t) { return t.key }, a = [], s = {}, i.forEach(function (t, n) { var e = o(t, n, i), r = s[e]; r || (r = [], s[e] = r, a.push(r)), r.push(t) }), a.map(function (t) { return t[0] }) }, e.updateCheckInput = function () { this.targetGesto && (this.targetGesto.options.checkInput = this.props.checkInput) }, e._updateObserver = function (t) { var n, e, r = this.props, i = r.target; window.ResizeObserver && i && r.useResizeObserver ? t.target === i && this._observer || ((e = new ResizeObserver(this.checkUpdateRect)).observe(i, { box: "border-box" }), this._observer = e) : null !== (n = this._observer) && void 0 !== n && n.disconnect() }, e._updateEvents = function () { var t = this.controlBox.getElement(), n = this.targetAbles.length, e = this.controlAbles.length, r = this.props, i = r.dragTarget || r.target; (!n && this.targetGesto || this._isTargetChanged(!0)) && (Lf(this, "targetGesto"), this.updateState({ gesto: null })), e || Lf(this, "controlGesto"), i && n && !this.targetGesto && (this.targetGesto = Kp(this, i, "")), !this.controlGesto && e && (this.controlGesto = Jp(this, t, "controlAbles", "Control")) }, e._updateTargets = function () { var t = this.props; this._prevTarget = t.dragTarget || t.target, this._prevDragArea = t.dragArea }, e._renderLines = function () { var t = this.props, n = t.edge, e = t.zoom; if (t.hideDefaultLines) return []; var r = this.state.renderPoses, i = { createElement: ku }; return [Nc(i, n ? "n" : "", r[0], r[1], e, 0), Nc(i, n ? "e" : "", r[1], r[3], e, 1), Nc(i, n ? "w" : "", r[0], r[2], e, 2), Nc(i, n ? "s" : "", r[2], r[3], e, 3)] }, e._isTargetChanged = function (t) { var n = this.props, e = n.dragTarget || n.target, r = this._prevTarget, i = this._prevDragArea, o = n.dragArea; return !o && r !== e || (t || o) && i !== o }, e._updateNativeEvents = function () { var i, o = this, a = this.props.dragArea ? this.areaElement : this.state.target, s = this.events, t = function (t) { if (Object.keys) return Object.keys(t); var n = []; for (var e in n) n.push(e); return n }(s); if (this._isTargetChanged()) for (var n in s) { var e = s[n]; e && e.destroy(), s[n] = null } a && (i = this.enabledAbles, t.forEach(function (t) { var n = Kf(i, [t]), e = 0 < n.length, r = s[t]; e ? (r || (r = new Qp(a, o, t), s[t] = r), r.setAbles(n)) : r && (r.destroy(), s[t] = null) })) }, n.defaultProps = { target: null, dragTarget: null, container: null, rootContainer: null, origin: !0, edge: !1, parentMoveable: null, wrapperMoveable: null, parentPosition: null, portalContainer: null, useResizeObserver: !1, ables: [], pinchThreshold: 20, dragArea: !1, passDragArea: !1, transformOrigin: "", className: "", zoom: 1, triggerAblesSimultaneously: !1, padding: {}, pinchOutside: !0, checkInput: !1, groupable: !1, hideDefaultLines: !1, cspNonce: "", translateZ: 0, cssStyled: null, customStyledMap: {}, props: {} }, n }(Lu), nd = { name: "groupable", props: { defaultGroupRotate: Number, defaultGroupOrigin: String, groupable: Boolean }, events: {}, render: function (o, a) { var t = o.props.targets || []; o.moveables = []; var n = o.state, s = { left: n.left, top: n.top }, u = o.props; return t.map(function (t, n) { return a.createElement(td, { key: "moveable" + n, ref: (e = o, i = n, function (t) { t && (e[r][i] = t) }), target: t, origin: !(r = "moveables"), cssStyled: u.cssStyled, customStyledMap: u.customStyledMap, useResizeObserver: u.useResizeObserver, parentMoveable: o, parentPosition: s }); var e, r, i }) } }, ed = Ec("clickable", { props: { clickable: Boolean }, events: { onClick: "click", onClickGroup: "clickGroup" }, always: !0, dragRelation: "weak", dragStart: function (t, n) { n.isRequest || Ps(window, "click", t.onPreventClick, !0) }, dragControlStart: function (t, n) { this.dragStart(t, n) }, dragGroupStart: function (t, n) { this.dragStart(t, n), n.datas.inputTarget = n.inputEvent && n.inputEvent.target }, dragEnd: function (t, n) { this.endEvent(t); var e, r = t.state.target, i = n.inputEvent, o = n.inputTarget, a = !t.isMoveableElement(o) && t.controlBox.getElement().contains(o); n.isDrag && !a || this.unset(t), !i || !o || n.isDrag || t.isMoveableElement(o) || a || (e = r.contains(o), $f(t, "onClick", Hf(t, n, { isDouble: n.isDouble, inputTarget: o, isTarget: r === o, containsTarget: e }))) }, dragGroupEnd: function (t, n) { this.endEvent(t); var e, r, i, o, a = n.inputEvent, s = n.inputTarget; a && s && !n.isDrag && !t.isMoveableElement(s) && n.datas.inputTarget !== s && (i = -1 < (r = (e = t.props.targets).indexOf(s)), o = !1, -1 === r && (o = -1 < (r = vs(e, function (t) { return t.contains(s) }))), $f(t, "onClickGroup", Hf(t, n, { isDouble: n.isDouble, targets: e, inputTarget: s, targetIndex: r, isTarget: i, containsTarget: o }))) }, dragControlEnd: function (t, n) { this.dragEnd(t, n) }, dragGroupControlEnd: function (t, n) { this.dragEnd(t, n) }, endEvent: function (t) { var n = this; ms(function () { n.unset(t) }) }, unset: function (t) { _s(window, "click", t.onPreventClick, !0) } }); function rd(t) { var n = t.originalDatas.draggable; return n || (t.originalDatas.draggable = {}, n = t.originalDatas.draggable), bc(bc({}, t), { datas: n }) } var id = Ec("edgeDraggable", { dragControlCondition: function (t, n) { if (!t.props.edgeDraggable || !n.inputEvent) return !1; var e = n.inputEvent.target; return Os(e, vf("direction")) && Os(e, vf("line")) }, dragControlStart: function (t, n) { return Ll.dragStart(t, rd(n)) }, dragControl: function (t, n) { return Ll.drag(t, rd(n)) }, dragControlEnd: function (t, n) { return Ll.dragEnd(t, rd(n)) }, dragGroupControlCondition: function (t, n) { if (!t.props.edgeDraggable || !n.inputEvent) return !1; var e = n.inputEvent.target; return Os(e, vf("direction")) && Os(e, vf("line")) }, dragGroupControlStart: function (t, n) { return Ll.dragGroupStart(t, rd(n)) }, dragGroupControl: function (t, n) { return Ll.dragGroup(t, rd(n)) }, dragGroupControlEnd: function (t, n) { return Ll.dragGroupEnd(t, rd(n)) }, unset: function (t) { return Ll.unset(t) } }), od = { name: "individualGroupable", props: { individualGroupable: Boolean }, events: {} }, ad = Da, sd = qe, ud = wa, cd = [Up, wp, ql, cp, Ll, id, Vc, lp, fp, hp, Mp, Dp, yp, qp, Wp, Vp, nd, od, ed, Ep, $p].reduce(function (t, n) { return bc(bc({}, t), n.props) }, {}), ld = function (t) { function n() { return null !== t && t.apply(this, arguments) || this } return i(n, t), n }(function (s) { function t(t, n) { void 0 === n && (n = {}); var e = s.call(this) || this; e.tempElement = document.createElement("div"); var r = u({}, n), i = {}; ud.forEach(function (n) { i[("on " + n).replace(/[\s-_]([a-z])/g, function (t, n) { return n.toUpperCase() })] = function (t) { return e.trigger(n, t) } }), H(_(Ba, u({ ref: y(e, "innerMoveable"), parentElement: t }, r, i)), e.tempElement); var o, a = r.target; return o = a, Array.isArray(o) && 1 < a.length && e.updateRect(), e } i(t, s); var n = t.prototype; return n.setState = function (t, n) { this.innerMoveable.setState(t, n) }, n.forceUpdate = function (t) { this.innerMoveable.forceUpdate(t) }, n.dragStart = function (t) { this.innerMoveable.$_timer && this.forceUpdate(), this.getMoveable().dragStart(t) }, n.destroy = function () { H(null, this.tempElement), this.off(), this.tempElement = null, this.innerMoveable = null }, n.getMoveable = function () { return this.innerMoveable.moveable }, function (t, n, e, r) { var i, o = arguments.length, a = o < 3 ? n : null === r ? r = Object.getOwnPropertyDescriptor(n, e) : r; if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(t, n, e, r); else for (var s = t.length - 1; 0 <= s; s--)(i = t[s]) && (a = (o < 3 ? i(a) : 3 < o ? i(n, e, a) : i(n, e)) || a); return 3 < o && a && Object.defineProperty(n, e, a), a }([e(sd, function (t, r) { t[r] || (t[r] = function () { for (var t = [], n = 0; n < arguments.length; n++)t[n] = arguments[n]; var e = this.getMoveable(); if (e && e[r]) return e[r].apply(e, t) }) }), e(ad, function (t, e) { Object.defineProperty(t, e, { get: function () { return this.getMoveable().props[e] }, set: function (t) { var n; this.setState(((n = {})[e] = t, n)) }, enumerable: !0, configurable: !0 }) })], t) }(Wn)); var fd = { __proto__: null, default: ld, PROPERTIES: ad, METHODS: sd, EVENTS: ud, PROPS_MAP: cd, getElementInfo: function (t, n, e) { return r = n, void 0 === (i = e) && (i = r), Ai(t, r, i, !0); var r, i }, makeAble: Oe }; for (var pd in fd) ld[pd] = fd[pd]; return ld });